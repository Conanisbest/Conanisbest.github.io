{"meta":{"title":"Conan的博客","subtitle":"","description":"愚者不努力，懒人盼巅峰","author":"John Doe","url":"https://Conanisbest.github.io","root":"/"},"pages":[{"title":"个人简介","date":"2020-07-02T08:34:49.000Z","updated":"2020-07-03T08:15:12.539Z","comments":true,"path":"about/index.html","permalink":"https://conanisbest.github.io/about/index.html","excerpt":"","text":"愚者不努力，懒人盼巅峰"}],"posts":[{"title":"工作流","slug":"工作流","date":"2020-07-03T08:25:36.000Z","updated":"2020-07-03T08:38:09.471Z","comments":true,"path":"2020/07/03/工作流/","link":"","permalink":"https://conanisbest.github.io/2020/07/03/%E5%B7%A5%E4%BD%9C%E6%B5%81/","excerpt":"","text":"博主更新中…","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"解决java导出文件时文件名中文不显示/乱码","slug":"five","date":"2020-07-02T07:39:23.000Z","updated":"2020-07-03T08:41:17.067Z","comments":true,"path":"2020/07/02/five/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/five/","excerpt":"","text":"解决java导出文件时文件名中文不显示/乱码 直接把中文文件名改为iso-8859-1就可以了~ response.setHeader(“Content-Disposition”, “attachment;filename=” + new String(fileName.getBytes(),”iso-8859-1”) + “.xls”);","categories":[],"tags":[{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}]},{"title":"hibernate工作原理及作用","slug":"four","date":"2020-07-02T07:30:06.000Z","updated":"2020-07-03T08:40:21.862Z","comments":true,"path":"2020/07/02/four/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/four/","excerpt":"","text":"hibernate工作原理及作用 2015年08月04日 15:00:17 进击的LTQ 阅读数 54747 转载自 http://www.cnblogs.com/dashi/p/3597969.html#commentform JAVA Hibernate工作原理及为什么要用 hibernate 简介： hibernate是一个开源框架，它是对象关联关系映射的框架，它对JDBC做了轻量级的封装，而我们java程序员可以使用面向对象的思想来操纵数据库。 hibernate核心接口 session：负责被持久化对象CRUD操作 sessionFactory:负责初始化hibernate，创建session对象 configuration:负责配置并启动hibernate，创建SessionFactory Transaction:负责事物相关的操作 Query和Criteria接口：负责执行各种数据库查询 hibernate工作原理： 1.通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件 2.由hibernate.cfg.xml中的读取并解析映射信息 3.通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory 4.Session session = sf.openSession();//打开Sesssion 5.Transaction tx = session.beginTransaction();//创建并启动事务Transation 6.persistent operate操作数据，持久化操作 7.tx.commit();//提交事务 8.关闭Session 9.关闭SesstionFactory 为什么要用hibernate： \\1. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 \\2. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 \\3. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 \\4. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 Hibernate是如何延迟加载?get与load的区别 \\1. 对于Hibernate get方法，Hibernate会确认一下该id对应的数据是否存在，首先在session缓存中查找，然后在二级缓存中查找，还没有就查询数据库，数据 库中没有就返回null。这个相对比较简单，也没有太大的争议。主要要说明的一点就是在这个版本(bibernate3.2以上)中get方法也会查找二级缓存！ \\2. Hibernate load方法加载实体对象的时候，根据映射文件上类级别的lazy属性的配置(默认为true)，分情况讨论： (1)若为true,则首先在Session缓存中查找，看看该id对应的对象是否存在，不存在则使用延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)。等到具体使用该对象(除获取OID以外)的时候，再查询二级缓存和数据库，若仍没发现符合条件的记录，则会抛出一个ObjectNotFoundException。 (2)若为false,就跟Hibernateget方法查找顺序一样，只是最终若没发现符合条件的记录，则会抛出一个ObjectNotFoundException。 这里get和load有两个重要区别: 如果未能发现符合条件的记录，Hibernate get方法返回null，而load方法会抛出一个ObjectNotFoundException。 load方法可返回没有加载实体数据的代 理类实例，而get方法永远返回有实体数据的对象。 (对于load和get方法返回类型：好多书中都说：“get方法永远只返回实体类”，实际上并不正 确，get方法如果在session缓存中找到了该id对应的对象，如果刚好该对象前面是被代理过的，如被load方法使用过，或者被其他关联对象延迟加 载过，那么返回的还是原先的代理对象，而不是实体类对象，如果该代理对象还没有加载实体数据（就是id以外的其他属性数据），那么它会查询二级缓存或者数 据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据。) 总之对于get和load的根本区别，一句话，hibernate对于 load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get方 法，hibernate一定要获取到真实的数据，否则返回null。 Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系) 类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、 说下Hibernate的缓存机制： Hibernate缓存的作用： Hibernate是一个持久层框架，经常访问物理数据库，为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据 Hibernate缓存分类： Hibernate缓存包括两大类：Hibernate一级缓存和Hibernate二级缓存 Hibernate一级缓存又称为“Session的缓存”，它是内置的，意思就是说，只要你使用hibernate就必须使用session缓存。由于Session对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。在第一级缓存中，持久化类的每个实例都具有唯一的OID。 Hibernate二级缓存又称为“SessionFactory的缓存”，由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。第二级缓存是可选的，是一个可配置的插件，在默认情况下，SessionFactory不会启用这个插件。 什么样的数据适合存放到第二级缓存中？ 1 很少被修改的数据 2 不是很重要的数据，允许出现偶尔并发的数据 3 不会被并发访问的数据 4 常量数据 不适合存放到第二级缓存的数据？ 1经常被修改的数据 2 .绝对不允许出现并发访问的数据，如财务数据，绝对不允许出现并发 3 与其他应用共享的数据。 Hibernate查找对象如何应用缓存？ 当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；如果都查不到，再查询数据库，把结果按照ID放入到缓存 删除、更新、增加数据的时候，同时更新缓存 Hibernate管理缓存实例 无论何时，我们在管理Hibernate缓存（Managing the caches）时，当你给save()、update()或saveOrUpdate()方法传递一个对象时，或使用load()、 get()、list()、iterate() 或scroll()方法获得一个对象时, 该对象都将被加入到Session的内部缓存中。 当随后flush()方法被调用时，对象的状态会和数据库取得同步。 如果你不希望此同步操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用evict() 方法，从一级缓存中去掉这些对象及其集合。 Hibernate的查询方式 Sql、Criteria,object comptosition Hql： 1、 属性查询 2、 参数查询、命名参数查询 3、 关联查询 4、 分页查询 5、 统计函数 如何优化Hibernate？ 1.使用双向一对多关联，不使用单向一对多 2.灵活使用单向一对多关联 3.不用一对一，用多对一取代 4.配置对象缓存，不使用集合缓存 5.一对多集合使用Bag,多对多集合使用Set \\6. 继承类使用显式多态 \\7. 表字段要少，表关联不要怕多，有二级缓存撑腰 hibernate的开发步骤： 开发步骤 1)搭建好环境 ​ 引入hibernate最小的jar包 ​ 准备Hibernate.cfg.xml启动配置文件 2)写实体类(pojo) 3)为实体类写映射文件”User.hbm.xml” ​ 在hibernate.cfg.xml添加映射的实体 4)创建库表 5)写测试类 ​ 获得Configuration ​ 创建SessionFactory ​ 打开Session ​ 开启事务 ​ 使用session操作数据 ​ 提交事务 ​ 关闭资源","categories":[],"tags":[{"name":"hibernate","slug":"hibernate","permalink":"https://conanisbest.github.io/tags/hibernate/"}]},{"title":"JVM 发生 OOM 的 8 种原因、及解决办法","slug":"three","date":"2020-07-02T07:26:13.000Z","updated":"2020-07-03T08:17:04.826Z","comments":true,"path":"2020/07/02/three/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/three/","excerpt":"","text":"JVM 发生 OOM（out of memory 内存溢出） 的 8 种原因、及解决办法 来源：www.importnew.com/author/tangyouhua 1. Java 堆空间 发生频率：5颗星 造成原因 无法在 Java 堆中分配对象 吞吐量增加 应用程序无意中保存了对象引用，对象无法被 GC 回收 应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长 解决方案 使用 -Xmx 增加堆大小 修复应用程序中的内存泄漏 2. GC 开销超过限制 发生频率：5颗星 造成原因 Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。 解决方案 使用 -Xmx 增加堆大小 使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制 修复应用程序中的内存泄漏 3. 请求的数组大小超过虚拟机限制 发生频率：2颗星 造成原因 应用程序试图分配一个超过堆大小的数组 解决方案 使用 -Xmx 增加堆大小 修复应用程序中分配巨大数组的 bug 4. Perm gen 空间 发生频率：3颗星 造成原因 Perm gen 空间包含： 类的名字、字段、方法 与类相关的对象数组和类型数组 JIT 编译器优化 当 Perm gen 空间用尽时，将抛出异常。 解决方案 使用 -XX: MaxPermSize 增加 Permgen 大小 不重启应用部署应用程序可能会导致此问题。重启 JVM 解决 5. Metaspace 发生频率：3颗星 造成原因 从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常 解决方案 通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小 取消 -XX: maxmetsspacedize 减小 Java 堆大小,为 MetaSpace 提供更多的可用空间 为服务器分配更多的内存 可能是应用程序 bug，修复 bug 6. 无法新建本机线程 发生频率：5颗星 造成原因 内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足 解决方案 为机器分配更多的内存 减少 Java 堆空间 修复应用程序中的线程泄漏。 增加操作系统级别的限制 ulimit -a 用户进程数增大 (-u) 1800 使用 -Xss 减小线程堆栈大小 7. 杀死进程或子进程 发生频率：1颗星 造成原因 内核任务：内存不足结束器，在可用内存极低的情况下会杀死进程 解决方案 将进程迁移到不同的机器上 给机器增加更多内存 与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的。 8. 发生 stack_trace_with_native_method 发生频率：1颗星 造成原因 本机方法（native method）分配失败 打印的堆栈跟踪信息，最顶层的帧是本机方法 解决方案 使用操作系统本地工具进行诊断","categories":[],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://conanisbest.github.io/tags/JVM/"}]},{"title":"Java多线程学习","slug":"second","date":"2020-07-02T07:18:50.000Z","updated":"2020-07-03T08:16:44.278Z","comments":true,"path":"2020/07/02/second/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/second/","excerpt":"","text":"Java总结篇系列：Java多线程（一） 多线程作为Java中很重要的一个知识点，在此还是有必要总结一下的。 一.线程的生命周期及五种基本状态 关于Java中线程的生命周期，首先看一下下面这张较为经典的图： 上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括： Java线程具有五种基本状态 新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread(); 就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行； 运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种： 1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态； 2.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态； 3.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 二. Java多线程的创建及启动 Java中线程的创建常见有如三种基本形式 1.继承Thread类，重写该类的run()方法。 1234567891011 1 class MyThread extends Thread &#123; 2 3 private int i = 0; 4 5 @Override 6 public void run() &#123; 7 for (i = 0; i &lt; 100; i++) &#123; 8 System.out.println(Thread.currentThread().getName() + \" \" + i); 9 &#125;10 &#125;11 &#125; 123456789101112131415 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 for (int i = 0; i &lt; 100; i++) &#123; 5 System.out.println(Thread.currentThread().getName() + \" \" + i); 6 if (i == 30) &#123; 7 Th; // 调用start()方法使得线程进入就绪状态11 &#125;12 &#125;13 &#125;14 &#125;read myThread1 = new MyThread(); // 创建一个新的线程 myThread1 此线程进入新建状态 8 Thread myThread2 = new MyThread(); // 创建一个新的线程 myThread2 此线程进入新建状态 9 myThread1.start(); // 调用start()方法使得线程进入就绪状态10 myThread2.start() 如上所示，继承Thread类，通过重写run()方法定义了一个新的线程类MyThread，其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。 2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。 12345678910 1 class MyRunnable implements Runnable &#123; 2 private int i = 0; 3 4 @Override 5 public void run() &#123; 6 for (i = 0; i &lt; 100; i++) &#123; 7 System.out.println(Thread.currentThread().getName() + \" \" + i); 8 &#125; 9 &#125;10 &#125; 1234567891011121314151 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 for (int i = 0; i &lt; 100; i++) &#123; 5 System.out.println(Thread.currentThread().getName() + \" \" + i); 6 if (i == 30) &#123; 7 Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象 8 Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程 9 Thread thread2 = new Thread(myRunnable);10 thread1.start(); // 调用start()方法使得线程进入就绪状态11 thread2.start();12 &#125;13 &#125;14 &#125;15 &#125; 相信以上两种创建新线程的方式大家都很熟悉了，那么Thread和Runnable之间到底是什么关系呢？我们首先来看一下下面这个例子。 123456789101112131415161718192021222324252627282930313233343536373839404142 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 for (int i = 0; i &lt; 100; i++) &#123; 5 System.out.println(Thread.currentThread().getName() + \" \" + i); 6 if (i == 30) &#123; 7 Runnable myRunnable = new MyRunnable(); 8 Thread thread = new MyThread(myRunnable); 9 thread.start();10 &#125;11 &#125;12 &#125;13 &#125;14 15 class MyRunnable implements Runnable &#123;16 private int i = 0;17 18 @Override19 public void run() &#123;20 System.out.println(\"in MyRunnable run\");21 for (i = 0; i &lt; 100; i++) &#123;22 System.out.println(Thread.currentThread().getName() + \" \" + i);23 &#125;24 &#125;25 &#125;26 27 class MyThread extends Thread &#123;28 29 private int i = 0;30 31 public MyThread(Runnable runnable)&#123;32 super(runnable);33 &#125;34 35 @Override36 public void run() &#123;37 System.out.println(\"in MyThread run\");38 for (i = 0; i &lt; 100; i++) &#123;39 System.out.println(Thread.currentThread().getName() + \" \" + i);40 &#125;41 &#125;42 &#125; 同样的，与实现Runnable接口创建线程方式相似，不同的地方在于 11 Thread thread = new MyThread(myRunnable); 那么这种方式可以顺利创建出一个新的线程么？答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的run()方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而run()方法最先是在Runnable接口中定义的方法。 123451 public interface Runnable &#123;2 3 public abstract void run();4 5 &#125; 我们看一下Thread类中对Runnable接口中run()方法的实现： 123456 @Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 也就是说，当执行到Thread类中的run()方法时，会首先判断target是否存在，存在则执行target中的run()方法，也就是实现了Runnable接口并重写了run()方法的类中的run()方法。但是上述给到的列子中，由于多态的存在，根本就没有执行到Thread类中的run()方法，而是直接先执行了运行时类型即MyThread类中的run()方法。 3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。 看着好像有点复杂，直接来看一个例子就清晰了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 Callable&lt;Integer&gt; myCallable = new MyCallable(); // 创建MyCallable对象 6 FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(myCallable); //使用FutureTask来包装MyCallable对象 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 Thread thread = new Thread(ft); //FutureTask对象作为Thread对象的target创建新的线程12 thread.start(); //线程进入到就绪状态13 &#125;14 &#125;15 16 System.out.println(\"主线程for循环执行完毕..\");17 18 try &#123;19 int sum = ft.get(); //取得新创建的新线程中的call()方法返回的结果20 System.out.println(\"sum = \" + sum);21 &#125; catch (InterruptedException e) &#123;22 e.printStackTrace();23 &#125; catch (ExecutionException e) &#123;24 e.printStackTrace();25 &#125;26 27 &#125;28 &#125;29 30 31 class MyCallable implements Callable&lt;Integer&gt; &#123;32 private int i = 0;33 34 // 与run()方法不同的是，call()方法具有返回值35 @Override36 public Integer call() &#123;37 int sum = 0;38 for (; i &lt; 100; i++) &#123;39 System.out.println(Thread.currentThread().getName() + \" \" + i);40 sum += i;41 &#125;42 return sum;43 &#125;44 45 &#125; 首先，我们发现，在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyCallable对象，同时作为了Thread对象的target。那么看下FutureTask类的定义： 123451 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;2 3 //....4 5 &#125; 123451 public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;2 3 void run();4 5 &#125; 于是，我们发现FutureTask类实际上是同时实现了Runnable和Future接口，由此才使得其具有Future和Runnable双重特性。通过Runnable特性，可以作为Thread对象的target，而Future特性，使得其可以取得新创建线程中的call()方法的返回值。 执行下此程序，我们发现sum = 4950永远都是最后输出的。而“主线程for循环执行完毕..”则很可能是在子线程循环中间输出。由CPU的线程调度机制，我们知道，“主线程for循环执行完毕..”的输出时机是没有任何问题的，那么为什么sum =4950会永远最后输出呢？ 原因在于通过ft.get()方法获取子线程call()方法的返回值时，当子线程此方法还未执行完毕，ft.get()方法会一直阻塞，直到call()方法执行完毕才能取到返回值。 上述主要讲解了三种常见的线程创建方式，对于线程的启动而言，都是调用线程对象的start()方法，需要特别注意的是：不能对同一线程对象两次调用start()方法。 三. Java多线程的就绪、运行和死亡状态 就绪状态转换为运行状态：当此线程得到处理器资源； 运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。 运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。 此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。 由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。如： 1234567891011121314151617181920212223242526272829303132333435 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 MyRunnable myRunnable = new MyRunnable(); 6 Thread thread = new Thread(myRunnable); 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 thread.start();12 &#125;13 if(i == 40)&#123;14 myRunnable.stopThread();15 &#125;16 &#125;17 &#125;18 &#125;19 20 class MyRunnable implements Runnable &#123;21 22 private boolean stop;23 24 @Override25 public void run() &#123;26 for (int i = 0; i &lt; 100 &amp;&amp; !stop; i++) &#123;27 System.out.println(Thread.currentThread().getName() + \" \" + i);28 &#125;29 &#125;30 31 public void stopThread() &#123;32 this.stop = true;33 &#125;34 35 &#125; Java总结篇系列：Java多线程（二） 本文承接上一篇文章《Java总结篇系列：Java多线程（一）》。 四.Java多线程的阻塞状态与线程控制 上文已经提到Java阻塞的几种具体类型。下面分别看下引起Java线程阻塞的主要方法。 1.join() join —— 让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，知道B线程执行完为止，A才能得以继续执行。 123456789101112131415161718192021222324252627282930 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 MyRunnable myRunnable = new MyRunnable(); 6 Thread thread = new Thread(myRunnable); 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 thread.start();12 try &#123;13 thread.join(); // main线程需要等待thread线程执行完后才能继续执行14 &#125; catch (InterruptedException e) &#123;15 e.printStackTrace();16 &#125;17 &#125;18 &#125;19 &#125;20 &#125;21 22 class MyRunnable implements Runnable &#123;23 24 @Override25 public void run() &#123;26 for (int i = 0; i &lt; 100; i++) &#123;27 System.out.println(Thread.currentThread().getName() + \" \" + i);28 &#125;29 &#125;30 &#125; 2.sleep() sleep —— 让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。在其睡眠的时间段内，该线程由于不是处于就绪状态，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，出于sleep()中的线程也不会执行。因此sleep()方法常用来暂停线程执行。 前面有讲到，当调用了新建的线程的start()方法后，线程进入到就绪状态，可能会在接下来的某个时间获取CPU时间片得以执行，如果希望这个新线程必然性的立即执行，直接调用原来线程的sleep(1)即可。 123456789101112131415161718192021222324252627282930 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 MyRunnable myRunnable = new MyRunnable(); 6 Thread thread = new Thread(myRunnable); 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 thread.start();12 try &#123;13 Thread.sleep(1); // 使得thread必然能够马上得以执行14 &#125; catch (InterruptedException e) &#123;15 e.printStackTrace();16 &#125;17 &#125;18 &#125;19 &#125;20 &#125;21 22 class MyRunnable implements Runnable &#123;23 24 @Override25 public void run() &#123;26 for (int i = 0; i &lt; 100; i++) &#123;27 System.out.println(Thread.currentThread().getName() + \" \" + i);28 &#125;29 &#125;30 &#125; 注：睡一个毫秒级够了，因为CPU不会空闲，会切换到新建的线程。 3.后台线程（Daemon Thread） 概念/目的：后台线程主要是为其他线程（相对可以称之为前台线程）提供服务，或“守护线程”。如JVM中的垃圾回收线程。 生命周期：后台线程的生命周期与前台线程生命周期有一定关联。主要体现在：当所有的前台线程都进入死亡状态时，后台线程会自动死亡(其实这个也很好理解，因为后台线程存在的目的在于为前台线程服务的，既然所有的前台线程都死亡了，那它自己还留着有什么用…伟大啊 ! !)。 设置后台线程：调用Thread对象的setDaemon(true)方法可以将指定的线程设置为后台线程。 1234567891011121314151617181920212223242526272829 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Thread myThread = new MyThread(); 5 for (int i = 0; i &lt; 100; i++) &#123; 6 System.out.println(\"main thread i = \" + i); 7 if (i == 20) &#123; 8 myThread.setDaemon(true); 9 myThread.start();10 &#125;11 &#125;12 &#125;13 14 &#125;15 16 class MyThread extends Thread &#123;17 18 public void run() &#123;19 for (int i = 0; i &lt; 100; i++) &#123;20 System.out.println(\"i = \" + i);21 try &#123;22 Thread.sleep(1);23 &#125; catch (InterruptedException e) &#123;24 // TODO Auto-generated catch block25 e.printStackTrace();26 &#125;27 &#125;28 &#125;29 &#125; 判断线程是否是后台线程：调用thread对象的isDeamon()方法。 注：main线程默认是前台线程，前台线程创建中创建的子线程默认是前台线程，后台线程中创建的线程默认是后台线程。调用setDeamon(true)方法将前台线程设置为后台线程时，需要在start()方法调用之前。前天线程都死亡后，JVM通知后台线程死亡，但从接收指令到作出响应，需要一定的时间。 4.改变线程的优先级/setPriority()： 每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。 设置线程优先级：setPriority(int priorityLevel)。参数priorityLevel范围在1-10之间，常用的有如下三个静态常量值： MAX_PRIORITY:10 MIN_PRIORITY:1 NORM_PRIORITY:5 获取线程优先级：getPriority()。 注：具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。 1234567891011121314151617181920212223 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Thread myThread = new MyThread(); 5 for (int i = 0; i &lt; 100; i++) &#123; 6 System.out.println(\"main thread i = \" + i); 7 if (i == 20) &#123; 8 myThread.setPriority(Thread.MAX_PRIORITY); 9 myThread.start();10 &#125;11 &#125;12 &#125;13 14 &#125;15 16 class MyThread extends Thread &#123;17 18 public void run() &#123;19 for (int i = 0; i &lt; 100; i++) &#123;20 System.out.println(\"i = \" + i);21 &#125;22 &#125;23 &#125; 5.线程让步：yield() 上一篇博文中已经讲到了yield()的基本作用，同时，yield()方法还与线程优先级有关，当某个线程调用yiled()方法从运行状态转换到就绪状态后，CPU从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。 123456789101112131415161718192021222324252627282930313233343536 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Thread myThread1 = new MyThread1(); 5 Thread myThread2 = new MyThread2(); 6 myThread1.setPriority(Thread.MAX_PRIORITY); 7 myThread2.setPriority(Thread.MIN_PRIORITY); 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(\"main thread i = \" + i);10 if (i == 20) &#123;11 myThread1.start();12 myThread2.start();13 Thread.yield();14 &#125;15 &#125;16 &#125;17 18 &#125;19 20 class MyThread1 extends Thread &#123;21 22 public void run() &#123;23 for (int i = 0; i &lt; 100; i++) &#123;24 System.out.println(\"myThread 1 -- i = \" + i);25 &#125;26 &#125;27 &#125;28 29 class MyThread2 extends Thread &#123;30 31 public void run() &#123;32 for (int i = 0; i &lt; 100; i++) &#123;33 System.out.println(\"myThread 2 -- i = \" + i);34 &#125;35 &#125;36 &#125; Java总结篇系列：Java多线程（三） 本文主要接着前面多线程的两篇文章总结Java多线程中的线程安全问题。 一.一个典型的Java线程安全例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Account account = new Account(\"123456\", 1000); 5 DrawMoneyRunnable drawMoneyRunnable = new DrawMoneyRunnable(account, 700); 6 Thread myThread1 = new Thread(drawMoneyRunnable); 7 Thread myThread2 = new Thread(drawMoneyRunnable); 8 myThread1.start(); 9 myThread2.start();10 &#125;11 12 &#125;13 14 class DrawMoneyRunnable implements Runnable &#123;15 16 private Account account;17 private double drawAmount;18 19 public DrawMoneyRunnable(Account account, double drawAmount) &#123;20 super();21 this.account = account;22 this.drawAmount = drawAmount;23 &#125;24 25 public void run() &#123;26 if (account.getBalance() &gt;= drawAmount) &#123; //127 System.out.println(\"取钱成功， 取出钱数为：\" + drawAmount);28 double balance = account.getBalance() - drawAmount;29 account.setBalance(balance);30 System.out.println(\"余额为：\" + balance);31 &#125;32 &#125;33 &#125;34 35 class Account &#123;36 37 private String accountNo;38 private double balance;39 40 public Account() &#123;41 42 &#125;43 44 public Account(String accountNo, double balance) &#123;45 this.accountNo = accountNo;46 this.balance = balance;47 &#125;48 49 public String getAccountNo() &#123;50 return accountNo;51 &#125;52 53 public void setAccountNo(String accountNo) &#123;54 this.accountNo = accountNo;55 &#125;56 57 public double getBalance() &#123;58 return balance;59 &#125;60 61 public void setBalance(double balance) &#123;62 this.balance = balance;63 &#125;64 65 &#125; 上面例子很容易理解，有一张银行卡，里面有1000的余额，程序模拟你和你老婆同时在取款机进行取钱操作的场景。多次运行此程序，可能具有多个不同组合的输出结果。其中一种可能的输出为： 1 取钱成功， 取出钱数为：700.0 2 余额为：300.0 3 取钱成功， 取出钱数为：700.0 4 余额为：-400.0 也就是说，对于一张只有1000余额的银行卡，你们一共可以取出1400，这显然是有问题的。 经过分析，问题在于Java多线程环境下的执行的不确定性。CPU可能随机的在多个处于就绪状态中的线程中进行切换，因此，很有可能出现如下情况：当thread1执行到//1处代码时，判断条件为true，此时CPU切换到thread2，执行//1处代码，发现依然为真，然后执行完thread2，接着切换到thread1，接着执行完毕。此时，就会出现上述结果。 因此，讲到线程安全问题，其实是指多线程环境下对共享资源的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问。 二.同步方法 对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。可以简单理解成对此方法进行了加锁，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推… 在上例中，共享资源为account对象，当使用同步方法时，可以解决线程安全问题。只需在run()方法前加上synshronized关键字即可。 123451 public synchronized void run() &#123;2 3 // ....4 5 &#125; 三.同步代码块 正如上面所分析的那样，解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。 同步代码块的格式为： 123451 synchronized (obj) &#123;2 3 //...4 5 &#125; 其中，obj为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是选择此共享资源对象作为锁对象。 如上例中，最好选用account对象作为锁对象。（当然，选用this也是可以的，那是因为创建线程使用了runnable方式，如果是直接继承Thread方式创建的线程，使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心…） 四.Lock对象同步锁 上面我们可以看出，正因为对同步锁对象的选择需要如此小心，有没有什么简单点的解决方案呢？以方便同步锁对象与共享资源解耦，同时又能很好的解决线程安全问题。 使用Lock对象同步锁可以方便的解决此问题，唯一需要注意的一点是Lock对象需要与资源对象同样具有一对一的关系。Lock对象同步锁一般格式为： 12345678910111213141516 1 class X &#123; 2 3 // 显示定义Lock同步锁对象，此对象与共享资源具有一对一关系 4 private final Lock lock = new ReentrantLock(); 5 6 public void m()&#123; 7 // 加锁 8 lock.lock(); 9 10 //... 需要进行线程安全同步的代码11 12 // 释放Lock锁13 lock.unlock();14 &#125;15 16 &#125; 五.wait()/notify()/notifyAll()线程通信 在博文《Java总结篇系列：java.lang.Object》中有提及到这三个方法，虽然这三个方法主要都是用于多线程中，但实际上都是Object类中的本地方法。因此，理论上，任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，只有同步锁对象调这三个方法，才能完成对多线程间的线程通信。 wait()：导致当前线程等待并使其进入到等待阻塞状态。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。 notify()：唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。 notifyAll()：唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150 1 package com.qqyumidi; 2 3 public class ThreadTest &#123; 4 5 public static void main(String[] args) &#123; 6 Account account = new Account(\"123456\", 0); 7 8 Thread drawMoneyThread = new DrawMoneyThread(\"取钱线程\", account, 700); 9 Thread depositeMoneyThread = new DepositeMoneyThread(\"存钱线程\", account, 700); 10 11 drawMoneyThread.start(); 12 depositeMoneyThread.start(); 13 &#125; 14 15 &#125; 16 17 class DrawMoneyThread extends Thread &#123; 18 19 private Account account; 20 private double amount; 21 22 public DrawMoneyThread(String threadName, Account account, double amount) &#123; 23 super(threadName); 24 this.account = account; 25 this.amount = amount; 26 &#125; 27 28 public void run() &#123; 29 for (int i = 0; i &lt; 100; i++) &#123; 30 account.draw(amount, i); 31 &#125; 32 &#125; 33 &#125; 34 35 class DepositeMoneyThread extends Thread &#123; 36 37 private Account account; 38 private double amount; 39 40 public DepositeMoneyThread(String threadName, Account account, double amount) &#123; 41 super(threadName); 42 this.account = account; 43 this.amount = amount; 44 &#125; 45 46 public void run() &#123; 47 for (int i = 0; i &lt; 100; i++) &#123; 48 account.deposite(amount, i); 49 &#125; 50 &#125; 51 &#125; 52 53 class Account &#123; 54 55 private String accountNo; 56 private double balance; 57 // 标识账户中是否已有存款 58 private boolean flag = false; 59 60 public Account() &#123; 61 62 &#125; 63 64 public Account(String accountNo, double balance) &#123; 65 this.accountNo = accountNo; 66 this.balance = balance; 67 &#125; 68 69 public String getAccountNo() &#123; 70 return accountNo; 71 &#125; 72 73 public void setAccountNo(String accountNo) &#123; 74 this.accountNo = accountNo; 75 &#125; 76 77 public double getBalance() &#123; 78 return balance; 79 &#125; 80 81 public void setBalance(double balance) &#123; 82 this.balance = balance; 83 &#125; 84 85 /** 86 * 存钱 87 * 88 * @param depositeAmount 89 */ 90 public synchronized void deposite(double depositeAmount, int i) &#123; 91 92 if (flag) &#123; 93 // 账户中已有人存钱进去，此时当前线程需要等待阻塞 94 try &#123; 95 System.out.println(Thread.currentThread().getName() + \" 开始要执行wait操作\" + \" -- i=\" + i); 96 wait(); 97 // 1 98 System.out.println(Thread.currentThread().getName() + \" 执行了wait操作\" + \" -- i=\" + i); 99 &#125; catch (InterruptedException e) &#123;100 e.printStackTrace();101 &#125;102 &#125; else &#123;103 // 开始存钱104 System.out.println(Thread.currentThread().getName() + \" 存款:\" + depositeAmount + \" -- i=\" + i);105 setBalance(balance + depositeAmount);106 flag = true;107 108 // 唤醒其他线程109 notifyAll();110 111 // 2112 try &#123;113 Thread.sleep(3000);114 &#125; catch (InterruptedException e) &#123;115 e.printStackTrace();116 &#125;117 System.out.println(Thread.currentThread().getName() + \"-- 存钱 -- 执行完毕\" + \" -- i=\" + i);118 &#125;119 &#125;120 121 /**122 * 取钱123 * 124 * @param drawAmount125 */126 public synchronized void draw(double drawAmount, int i) &#123;127 if (!flag) &#123;128 // 账户中还没人存钱进去，此时当前线程需要等待阻塞129 try &#123;130 System.out.println(Thread.currentThread().getName() + \" 开始要执行wait操作\" + \" 执行了wait操作\" + \" -- i=\" + i);131 wait();132 System.out.println(Thread.currentThread().getName() + \" 执行了wait操作\" + \" 执行了wait操作\" + \" -- i=\" + i);133 &#125; catch (InterruptedException e) &#123;134 e.printStackTrace();135 &#125;136 &#125; else &#123;137 // 开始取钱138 System.out.println(Thread.currentThread().getName() + \" 取钱：\" + drawAmount + \" -- i=\" + i);139 setBalance(getBalance() - drawAmount);140 141 flag = false;142 143 // 唤醒其他线程144 notifyAll();145 146 System.out.println(Thread.currentThread().getName() + \"-- 取钱 -- 执行完毕\" + \" -- i=\" + i); // 3147 &#125;148 &#125;149 150 &#125; 上面的例子演示了wait()/notify()/notifyAll()的用法。部分输出结果为： 1234567891011121314151617181920212223242526272829303132 1 取钱线程 开始要执行wait操作 执行了wait操作 -- i=0 2 存钱线程 存款:700.0 -- i=0 3 存钱线程-- 存钱 -- 执行完毕 -- i=0 4 存钱线程 开始要执行wait操作 -- i=1 5 取钱线程 执行了wait操作 执行了wait操作 -- i=0 6 取钱线程 取钱：700.0 -- i=1 7 取钱线程-- 取钱 -- 执行完毕 -- i=1 8 取钱线程 开始要执行wait操作 执行了wait操作 -- i=2 9 存钱线程 执行了wait操作 -- i=110 存钱线程 存款:700.0 -- i=211 存钱线程-- 存钱 -- 执行完毕 -- i=212 取钱线程 执行了wait操作 执行了wait操作 -- i=213 取钱线程 取钱：700.0 -- i=314 取钱线程-- 取钱 -- 执行完毕 -- i=315 取钱线程 开始要执行wait操作 执行了wait操作 -- i=416 存钱线程 存款:700.0 -- i=317 存钱线程-- 存钱 -- 执行完毕 -- i=318 存钱线程 开始要执行wait操作 -- i=419 取钱线程 执行了wait操作 执行了wait操作 -- i=420 取钱线程 取钱：700.0 -- i=521 取钱线程-- 取钱 -- 执行完毕 -- i=522 取钱线程 开始要执行wait操作 执行了wait操作 -- i=623 存钱线程 执行了wait操作 -- i=424 存钱线程 存款:700.0 -- i=525 存钱线程-- 存钱 -- 执行完毕 -- i=526 存钱线程 开始要执行wait操作 -- i=627 取钱线程 执行了wait操作 执行了wait操作 -- i=628 取钱线程 取钱：700.0 -- i=729 取钱线程-- 取钱 -- 执行完毕 -- i=730 取钱线程 开始要执行wait操作 执行了wait操作 -- i=831 存钱线程 执行了wait操作 -- i=632 存钱线程 存款:700.0 -- i=7 由此，我们需要注意如下几点： 1.wait()方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行； 2.notify()/notifyAll()方法执行后，将唤醒此同步锁对象上的（任意一个-notify()/所有-notifyAll()）线程对象，但是，此时还并没有释放同步锁对象，也就是说，如果notify()/notifyAll()后面还有代码，还会继续进行，知道当前线程执行完毕才会释放同步锁对象； 3.notify()/notifyAll()执行后，如果右面有sleep()方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程，接下来同2； 4.wait()/notify()/nitifyAll()完成线程间的通信或协作都是基于不同对象锁的，因此，如果是不同的同步对象锁将失去意义，同时，同步对象锁最好是与共享资源对象保持一一对应关系； 5.当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的。 当然，上面的例子相对来说比较简单，只是为了简单示例wait()/notify()/noitifyAll()方法的用法，但其本质上说，已经是一个简单的生产者-消费者模式了。","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"Java高级特性——反射","slug":"first","date":"2020-07-02T06:34:39.000Z","updated":"2020-07-03T08:10:30.216Z","comments":true,"path":"2020/07/02/first/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/first/","excerpt":"","text":"Java高级特性——反射 peter_RD_nj 122018.08.27 16:40:42字数 1,009阅读 151,828 概述 定义 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 用途 在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。 反射机制的相关类 与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 Class类 Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。 获得类相关的方法 方法 用途 asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或是接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 类中其他重要的方法 方法 用途 isAnnotation() 如果是注解类型则返回true isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回true isAnonymousClass() 如果是匿名类则返回true isArray() 如果是一个数组类则返回true isEnum() 如果是枚举类则返回true isInstance(Object obj) 如果obj是该类的实例则返回true isInterface() 如果是接口类则返回true isLocalClass() 如果是局部类则返回true isMemberClass() 如果是内部类则返回true Field类 Field代表类的成员变量（成员变量也称为类的属性）。 方法 用途 equals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 Method类 Method代表类的方法。 方法 用途 invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类 Constructor代表类的构造方法。 方法 用途 newInstance(Object… initargs) 根据传递的参数创建类的对象 示例 为了演示反射的使用，首先构造一个与书籍相关的model——Book.java，然后通过反射方法示例创建对象、反射私有构造方法、反射私有属性、反射私有方法，最后给出两个比较复杂的反射示例——获得当前ZenMode和关机Shutdown。 被反射类Book.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Book&#123; private final static String TAG = \"BookTag\"; private String name; private String author; @Override public String toString() &#123; return \"Book&#123;\" + \"name='\" + name + '\\'' + \", author='\" + author + '\\'' + '&#125;'; &#125; public Book() &#123; &#125; private Book(String name, String author) &#123; this.name = name; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; private String declaredMethod(int index) &#123; String string = null; switch (index) &#123; case 0: string = \"I am declaredMethod 1 !\"; break; case 1: string = \"I am declaredMethod 2 !\"; break; default: string = \"I am declaredMethod 1 !\"; &#125; return string; &#125;&#125; 反射逻辑封装在ReflectClass.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class ReflectClass &#123; private final static String TAG = \"peter.log.ReflectClass\"; // 创建对象 public static void reflectNewInstance() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Object objectBook = classBook.newInstance(); Book book = (Book) objectBook; book.setName(\"Android进阶之光\"); book.setAuthor(\"刘望舒\"); Log.d(TAG,\"reflectNewInstance book = \" + book.toString()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有的构造方法 public static void reflectPrivateConstructor() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Constructor&lt;?&gt; declaredConstructorBook = classBook.getDeclaredConstructor(String.class,String.class); declaredConstructorBook.setAccessible(true); Object objectBook = declaredConstructorBook.newInstance(\"Android开发艺术探索\",\"任玉刚\"); Book book = (Book) objectBook; Log.d(TAG,\"reflectPrivateConstructor book = \" + book.toString()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有属性 public static void reflectPrivateField() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Object objectBook = classBook.newInstance(); Field fieldTag = classBook.getDeclaredField(\"TAG\"); fieldTag.setAccessible(true); String tag = (String) fieldTag.get(objectBook); Log.d(TAG,\"reflectPrivateField tag = \" + tag); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有方法 public static void reflectPrivateMethod() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Method methodBook = classBook.getDeclaredMethod(\"declaredMethod\",int.class); methodBook.setAccessible(true); Object objectBook = classBook.newInstance(); String string = (String) methodBook.invoke(objectBook,0); Log.d(TAG,\"reflectPrivateMethod string = \" + string); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 获得系统Zenmode值 public static int getZenMode() &#123; int zenMode = -1; try &#123; Class&lt;?&gt; cServiceManager = Class.forName(\"android.os.ServiceManager\"); Method mGetService = cServiceManager.getMethod(\"getService\", String.class); Object oNotificationManagerService = mGetService.invoke(null, Context.NOTIFICATION_SERVICE); Class&lt;?&gt; cINotificationManagerStub = Class.forName(\"android.app.INotificationManager$Stub\"); Method mAsInterface = cINotificationManagerStub.getMethod(\"asInterface\",IBinder.class); Object oINotificationManager = mAsInterface.invoke(null,oNotificationManagerService); Method mGetZenMode = cINotificationManagerStub.getMethod(\"getZenMode\"); zenMode = (int) mGetZenMode.invoke(oINotificationManager); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return zenMode; &#125; // 关闭手机 public static void shutDown() &#123; try &#123; Class&lt;?&gt; cServiceManager = Class.forName(\"android.os.ServiceManager\"); Method mGetService = cServiceManager.getMethod(\"getService\",String.class); Object oPowerManagerService = mGetService.invoke(null,Context.POWER_SERVICE); Class&lt;?&gt; cIPowerManagerStub = Class.forName(\"android.os.IPowerManager$Stub\"); Method mShutdown = cIPowerManagerStub.getMethod(\"shutdown\",boolean.class,String.class,boolean.class); Method mAsInterface = cIPowerManagerStub.getMethod(\"asInterface\",IBinder.class); Object oIPowerManager = mAsInterface.invoke(null,oPowerManagerService); mShutdown.invoke(oIPowerManager,true,null,true); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; public static void shutdownOrReboot(final boolean shutdown, final boolean confirm) &#123; try &#123; Class&lt;?&gt; ServiceManager = Class.forName(\"android.os.ServiceManager\"); // 获得ServiceManager的getService方法 Method getService = ServiceManager.getMethod(\"getService\", java.lang.String.class); // 调用getService获取RemoteService Object oRemoteService = getService.invoke(null, Context.POWER_SERVICE); // 获得IPowerManager.Stub类 Class&lt;?&gt; cStub = Class.forName(\"android.os.IPowerManager$Stub\"); // 获得asInterface方法 Method asInterface = cStub.getMethod(\"asInterface\", android.os.IBinder.class); // 调用asInterface方法获取IPowerManager对象 Object oIPowerManager = asInterface.invoke(null, oRemoteService); if (shutdown) &#123; // 获得shutdown()方法 Method shutdownMethod = oIPowerManager.getClass().getMethod( \"shutdown\", boolean.class, String.class, boolean.class); // 调用shutdown()方法 shutdownMethod.invoke(oIPowerManager, confirm, null, false); &#125; else &#123; // 获得reboot()方法 Method rebootMethod = oIPowerManager.getClass().getMethod(\"reboot\", boolean.class, String.class, boolean.class); // 调用reboot()方法 rebootMethod.invoke(oIPowerManager, confirm, null, false); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 调用相应反射逻辑方法 1234567891011121314151617try &#123; // 创建对象 ReflectClass.reflectNewInstance(); // 反射私有的构造方法 ReflectClass.reflectPrivateConstructor(); // 反射私有属性 ReflectClass.reflectPrivateField(); // 反射私有方法 ReflectClass.reflectPrivateMethod(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; Log.d(TAG,\" zenmode = \" + ReflectClass.getZenMode()); Log输出结果如下： 1234508-27 15:11:37.999 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectNewInstance book = Book&#123;name='Android进阶之光', author='刘望舒'&#125;08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateConstructor book = Book&#123;name='Android开发艺术探索', author='任玉刚'&#125;08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateField tag = BookTag08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateMethod string = I am declaredMethod 1 !08-27 15:11:38.004 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectDemo: zenmode = 0 总结 本文列举了反射机制使用过程中常用的、重要的一些类及其方法，更多信息和用法需要近一步的阅读Google提供的相关文档和示例。 在阅读Class类文档时发现一个特点，以通过反射获得Method对象为例，一般会提供四种方法，getMethod(parameterTypes)、getMethods()、getDeclaredMethod(parameterTypes)和getDeclaredMethods()。getMethod(parameterTypes)用来获取某个公有的方法的对象，getMethods()获得该类所有公有的方法，getDeclaredMethod(parameterTypes)获得该类某个方法，getDeclaredMethods()获得该类所有方法。带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法。其他的Annotation、Field、Constructor也是如此。 在ReflectClass类中还提供了两种反射PowerManager.shutdown()的方法，在调用的时候会输出如下log，提示没有相关权限。之前在项目中尝试反射其他方法的时候还遇到过有权限和没权限返回的值不一样的情况。如果源码中明确进行了权限验证，而你的应用又无法获得这个权限的话，建议就不要浪费时间反射了。 1234567891011121314151617W&#x2F;System.err: java.lang.reflect.InvocationTargetExceptionW&#x2F;System.err: at java.lang.reflect.Method.invoke(Native Method)W&#x2F;System.err: at .ReflectClass.shutDown(ReflectClass.java:104)W&#x2F;System.err: at .MainActivity$1.onClick(MainActivity.java:25)W&#x2F;System.err: at android.view.View.performClick(View.java:6259)W&#x2F;System.err: at android.view.View$PerformClick.run(View.java:24732)W&#x2F;System.err: at android.os.Handler.handleCallback(Handler.java:789)W&#x2F;System.err: at android.os.Handler.dispatchMessage(Handler.java:98)W&#x2F;System.err: at android.os.Looper.loop(Looper.java:164)W&#x2F;System.err: at android.app.ActivityThread.main(ActivityThread.java:6592)W&#x2F;System.err: at java.lang.reflect.Method.invoke(Native Method)W&#x2F;System.err: at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)W&#x2F;System.err: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:769)W&#x2F;System.err: Caused by: java.lang.SecurityException: Neither user 10224 nor current process has android.permission.REBOOT.W&#x2F;System.err: at android.os.Parcel.readException(Parcel.java:1942)W&#x2F;System.err: at android.os.Parcel.readException(Parcel.java:1888)W&#x2F;System.err: at android.os.IPowerManager$Stub$Proxy.shutdown(IPowerManager.java:787) ReflectDemo 参考文献 认识反射机制（Reflection） Java 反射机制 一个例子让你了解Java反射机制 Java反射机制的原理及在Android下的简单应用 java中的反射机制 Android注解与反射机制 java.lang.reflect.Method","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"辨析 Sass 中的 Map 和 List","slug":"demo","date":"2019-10-21T02:34:12.000Z","updated":"2020-07-03T08:41:53.354Z","comments":true,"path":"2019/10/21/demo/","link":"","permalink":"https://conanisbest.github.io/2019/10/21/demo/","excerpt":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。","text":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。 使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。 测试表格 Variable Description site Sitewide information. page Page specific information and custom variables set in front-matter. config Site configuration theme Theme configuration. Inherits from site configuration. _ (single underscore) Lodash library path Path of current page url Full URL of current page env Environment variables 语法比较 测试标题 在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。 Map 语法下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。 1234567891011121314151617181920212223242526$breakpoint-map: ( small: ( min-width: null, max-width: 479px, base-font: 16px, vertical-rhythm: 1.3 ), medium: ( min-width: 480px, max-width: 959px, base-font: 18px, vertical-rhythm: 1.414 ), large: ( min-width: 960px, max-width: 1099px, base-font: 18px, vertical-rhythm: 1.5 ), xlarge: ( min-width: 1100px, max-width: null, base-font: 21px, vertical-rhythm: 1.618 )); 多重列表语法下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 nth() 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。 123456$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, null, 21px, 1.618)); 遍历比较 测试标题 从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？ 遍历 Map我们可以使用如下的代码遍历 Map： 1@each $label, $map in $breakpoint-map &#123;&#125; 这里的变量 $label 和 $map 会随着对 $breakpoint-map 的遍历被动态地赋值，$label 将会被赋值为 $breakpoint-map 的 Key，而 $map 会被赋值为 $breakpoint-map 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 map-get() 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。 具体的做法就是使用 @each 遍历 Map，然后使用 map-get() 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历： 123456@each $label, $map in $breakpoint-map &#123; $min-width: map-get($map, min-width); $max-width: map-get($map, max-width); $base-font: map-get($map, base-font); $vertical-rhythm: map-get($map, vertical-rhythm);&#125; 遍历多重列表遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 map-get() 函数取特定值，直接遍历一遍即可获得特定值。 因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 map-get()，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符： 12@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#125; 慎用多重列表 测试标题 经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。 遗漏键值如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况： 1234567891011121314151617181920$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, 21px, 1.618));p &#123; @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123; @if $min-width &#123; @include breakpoint( $min-width ) &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125; @else &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125;&#125; 当我们尝试运行这段代码时，结果肯定是错误地，因为在 $breakpoint-list 的最后一行，xlarge 被赋值给了 $label，1100px 被赋值给了 $min-width，21px 被赋值给了 $max-width, 1.618 被赋值给了 $base-font，最终导致 $vertical-rhythm 没有被赋值，结果就是 font-size 的属性值是错的，line-height 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。 如果我们使用 Map 来代替这里的多重列表，那么使用 map-get() 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。 查找特定列表在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 map-get() 函数可以快速定位到特定子 Map： 1$medium-map: map-get($maps, medium); 但如果要获取多种列表 medium 列表，麻烦可就大了： 123456789@function get-list($label) &#123; @each $list in $breakpoint-list &#123; @if nth($list, 1) &#x3D;&#x3D; $label &#123; @return $list; &#125; &#125; @return null;&#125;$medium-list: get-list(medium); 这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 null。这实际上就是手工实现了 map-get() 的逻辑。 缺少原生的 Map 函数Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 map-merge() 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 join() 或 append() 来增加新列表，从而模拟出 map-merge() 的效果。 另一个实用的 Map 函数就是 map-has-key()，对于依赖 map-get() 的自定义函数来说，map-has-key() 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。 总结 Test Title 相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。 虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://conanisbest.github.io/tags/css/"}]}],"categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"},{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"hibernate","slug":"hibernate","permalink":"https://conanisbest.github.io/tags/hibernate/"},{"name":"JVM","slug":"JVM","permalink":"https://conanisbest.github.io/tags/JVM/"},{"name":"css","slug":"css","permalink":"https://conanisbest.github.io/tags/css/"}]}