{"meta":{"title":"Conan的博客","subtitle":"","description":"愚者不努力，懒人盼巅峰","author":"John Doe","url":"https://Conanisbest.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-07-13T09:04:31.116Z","updated":"2020-07-13T09:04:31.116Z","comments":true,"path":"categories/index.html","permalink":"https://conanisbest.github.io/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2020-07-02T08:34:49.000Z","updated":"2020-07-14T04:36:26.388Z","comments":true,"path":"about/index.html","permalink":"https://conanisbest.github.io/about/index.html","excerpt":"","text":"A Coder, live in Beijing, China. 姓名：Conan现居：北京GitHub: ConanisbestQQ: 1437354122微信: Conan_keepmoving 愚者不努力，懒人盼巅峰"},{"title":"tags","date":"2020-07-07T09:23:32.000Z","updated":"2020-07-13T09:04:22.530Z","comments":true,"path":"tags/index.html","permalink":"https://conanisbest.github.io/tags/index.html","excerpt":"","text":""},{"title":"Gallery","date":"2020-07-14T04:38:17.415Z","updated":"2020-07-14T04:38:17.415Z","comments":true,"path":"photos/index.html","permalink":"https://conanisbest.github.io/photos/index.html","excerpt":"","text":""}],"posts":[{"title":"数据库索引","slug":"数据库索引","date":"2020-08-27T07:32:17.000Z","updated":"2020-08-27T07:48:21.266Z","comments":true,"path":"2020/08/27/数据库索引/","link":"","permalink":"https://conanisbest.github.io/2020/08/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/","excerpt":"","text":"数据库索引原理，及MySQL索引类型\\MySQL索引类型一览 让MySQL高效运行起来**本文介绍了七种MySQL索引类型。在数据库表中，对字段建立索引可以大大提高查询速度。通过善用这些索引，可以令MySQL的查询和运行更加高效。 索引是快速搜索的关键。MySQL索引的建立对于MySQL的高效运行是很重要的。下面介绍几种常见的MySQL索引类型。 在数据库表中，对字段建立索引可以大大提高查询速度。假如我们创建了一个 mytable表： CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL ); 12345678910111213141516171819 我们随机向里面插入了10000条记录，其中有一条：5555, admin。在查找username&#x3D;&quot;admin&quot;的记录 SELECT * FROM mytable WHERE username&#x3D;&#39;admin&#39;;时，如果在username上已经建立了索引，MySQL无须任何扫描，即准确可找到该记录。相反，MySQL会扫描所有记录，即要查询10000条记录。索引分单列索引和组合索引。单列索引，即一个索引只包含单个列，一个表可以有多个单列索引，但这不是组合索引。组合索引，即一个索包含多个列。MySQL索引类型包括：**（1）普通索引**这是最基本的索引，它没有任何限制。它有以下几种创建方式：◆创建索引1. &#96;&#96;&#96;sql CREATE INDEX indexName ON mytable(username(length)); 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length，下同。 ◆修改表结构 ALTER mytable ADD INDEX [indexName] ON (username(length)) &lt;!--￼1--&gt; 删除索引的语法： DROP INDEX [indexName] ON mytable; 1234567891011 **（2）唯一索引**它与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。它有以下几种创建方式：◆创建索引1. &#96;&#96;&#96;sql CREATE UNIQUE INDEX indexName ON mytable(username(length)) ◆修改表结构 ALTER mytable ADD UNIQUE [indexName] ON (username(length)) &lt;!--￼3--&gt; （3）主键索引 它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引： CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, PRIMARY KEY(ID) ); 123456789101112131415161718192021 当然也可以用 ALTER 命令。记住：一个表只能有一个主键。**（4）组合索引**为了形象地对比单列索引和组合索引，为表添加多个字段：&#96;&#96;&#96;sqlCREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, city VARCHAR(50) NOT NULL, age INT NOT NULL ); 为了进一步榨取MySQL的效率，就要考虑建立组合索引。就是将 name, city, age建到一个索引里： 1ALTER TABLE mytable ADD INDEX name_city_age (name(10),city,age); 建表时，usernname长度为 16，这里用 10。这是因为一般情况下名字的长度不会超过10，这样会加速索引查询速度，还会减少索引文件的大小，提高INSERT的更新速度。 如果分别在 usernname，city，age上建立单列索引，让该表有3个单列索引，查询时和上述的组合索引效率也会大不一样，远远低于我们的组合索引。虽然此时有了三个索引，但MySQL只能用到其中的那个它认为似乎是最有效率的单列索引。 建立这样的组合索引，其实是相当于分别建立了下面三组组合索引： 1 usernname,city,age usernname,city usernname 为什么没有 city，age这样的组合索引呢？这是因为MySQL组合索引“最左前缀”的结果。简单的理解就是只从最左面的开始组合。并不是只要包含这三列的查询都会用到该组合索引，下面的几个SQL就会用到这个组合索引： 123 SELECT * FROM mytable WHREE username=\"admin\" AND city=\"郑州\" SELECT * FROM mytable WHREE username=\"admin\" 而下面几个则不会用到： 123 SELECT * FROM mytable WHREE age=20 AND city=\"郑州\" SELECT * FROM mytable WHREE city=\"郑州\" （5）建立索引的时机 到这里我们已经学会了建立索引，那么我们需要在什么情况下建立索引呢？一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。例如： 12345SELECT t.Name FROM mytable t LEFT JOIN mytable m ON t.Name=m.username WHERE m.age=20 AND m.city='郑州' 此时就需要对city和age建立索引，由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。 刚才提到只有某些时候的LIKE才需建立索引。因为在以通配符%和_开头作查询时，MySQL不会使用索引。例如下句会使用索引： 1SELECT * FROM mytable WHERE username like'admin%' 而下句就不会使用： 1SELECT * FROM mytable WHEREt Name like'%admin' 因此，在使用LIKE时应注意以上的区别。 （6）索引的不足之处 上面都在说使用索引的好处，但过多的使用索引将会造成滥用。因此索引也会有它的缺点： ◆虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 ◆建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快。 索引只是提高效率的一个因素，如果你的MySQL有大数据量的表，就需要花时间研究建立最优秀的索引，或优化查询语句。 （7）使用索引的注意事项 使用索引时，有以下一些技巧和注意事项： ◆索引不会包含有NULL值的列 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 ◆使用短索引 对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的列，如果在前10个或20个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。 ◆索引列排序 MySQL查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。 ◆like语句操作 一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。 ◆不要在列上进行运算 1select * from users where YEAR(adddate)&lt;2007; 将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成 1select * from users where adddate&lt;‘2007-01-01’; ◆不使用NOT IN和&lt;&gt;操作 索引原理：想要理解索引原理必须清楚一种数据结构「平衡树」(非二叉)，也就是b tree或者 b+ tree，重要的事情说三遍：“平衡树，平衡树，平衡树”。当然， 有的数据库也使用哈希桶作用索引的数据结构 ， 然而， 主流的RDBMS都是把平衡树当做数据表默认的索引数据结构的。 我们平时建表的时候都会为表加上主键， 在某些关系数据库中， 如果建表时不指定主键，数据库会拒绝建表的语句执行。 事实上， 一个加了主键的表，并不能被称之为「表」。一个没加主键的表，它的数据无序的放置在磁盘存储器上，一行一行的排列的很整齐， 跟我认知中的「表」很接近。如果给表上了主键，那么表在磁盘上的存储结构就由整齐排列的结构转变成了树状结构，也就是上面说的「平衡树」结构，换句话说，就是整个表就变成了一个索引。没错， 再说一遍， 整个表变成了一个索引，也就是所谓的「聚集索引」。 这就是为什么一个表只能有一个主键， 一个表只能有一个「聚集索引」，因为主键的作用就是把「表」的数据格式转换成「索引（平衡树）」的格式放置。 上图就是带有主键的表（聚集索引）的结构图。图画的不是很好， 将就着看。其中树的所有结点（底部除外）的数据都是由主键字段中的数据构成，也就是通常我们指定主键的id字段。最下面部分是真正表中的数据。 假如我们执行一个SQL语句： select * from table where id = 1256; 首先根据索引定位到1256这个值所在的叶结点，然后再通过叶结点取到id等于1256的数据行。 这里不讲解平衡树的运行细节， 但是从上图能看出，树一共有三层， 从根节点至叶节点只需要经过三次查找就能得到结果。如下图 假如一张表有一亿条数据 ，需要查找其中某一条数据，按照常规逻辑， 一条一条的去匹配的话， 最坏的情况下需要匹配一亿次才能得到结果，用大O标记法就是O(n)最坏时间复杂度，这是无法接受的，而且这一亿条数据显然不能一次性读入内存供程序使用， 因此， 这一亿次匹配在不经缓存优化的情况下就是一亿次IO开销，以现在磁盘的IO能力和CPU的运算能力， 有可能需要几个月才能得出结果 。如果把这张表转换成平衡树结构（一棵非常茂盛和节点非常多的树），假设这棵树有10层，那么只需要10次IO开销就能查找到所需要的数据， 速度以指数级别提升，用大O标记法就是O(log n)，n是记录总树，底数是树的分叉数，结果就是树的层次数。换言之，查找次数是以树的分叉数为底，记录总数的对数，用公式来表示就是 用程序来表示就是Math.Log(100000000,10)，100000000是记录数，10是树的分叉数（真实环境下分叉数远不止10）， 结果就是查找次数，这里的结果从亿降到了个位数。因此，利用索引会使数据库查询有惊人的性能提升。 然而， 事物都是有两面的， 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。 讲完聚集索引 ， 接下来聊一下非聚集索引， 也就是我们平时经常提起和使用的常规索引。 非聚集索引和聚集索引一样， 同样是采用平衡树作为索引的数据结构。索引树结构中各节点的值来自于表中的索引字段， 假如给user表的name字段加上索引 ， 那么索引就是由name字段中的值构成，在数据改变时， DBMS需要一直维护索引结构的正确性。如果给表中多个字段加上索引 ， 那么就会出现多个独立的索引结构，每个索引（非聚集索引）互相之间不存在关联。 如下图 每次给字段建一个新索引， 字段中的数据就会被复制一份出来， 用于生成索引。 因此， 给表添加索引，会增加表的体积， 占用磁盘存储空间。 非聚集索引和聚集索引的区别在于， 通过聚集索引可以查到需要查找的数据， 而通过非聚集索引可以查到记录对应的主键值 ， 再使用主键的值通过聚集索引查找到需要的数据，如下图 不管以任何方式查询表， 最终都会利用主键通过聚集索引来定位到数据， 聚集索引（主键）是通往真实数据所在的唯一路径。 然而， 有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。 文章上面的内容已经指出， 当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。 先看下面这个SQL语句 //建立索引 create index index_birthday on user_info(birthday); //查询生日在1991年11月1日出生用户的用户名 select user_name from user_info where birthday = ‘1991-11-1’ 这句SQL语句的执行过程如下 首先，通过非聚集索引index_birthday查找birthday等于1991-11-1的所有记录的主键ID值 然后，通过得到的主键ID值执行聚集索引查找，找到主键ID值对就的真实数据（数据行）存储的位置 最后， 从得到的真实数据中取得user_name字段的值返回， 也就是取得最终的结果 我们把birthday字段上的索引改成双字段的覆盖索引 create index index_birthday_and_user_name on user_info(birthday, user_name); 这句SQL语句的执行过程就会变为 通过非聚集索引index_birthday_and_user_name查找birthday等于1991-11-1的叶节点的内容，然而， 叶节点中除了有user_name表主键ID的值以外， user_name字段的值也在里面， 因此不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中user_name的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能，如下图 数据库索引的大致工作原理就是像文中所述， 然而细节方面可能会略有偏差，这但并不会对概念阐述的结果产生影响 。 最后， 推荐三本关系数据库方面的书籍， 文中所讲解的概念内容都是来自于此。 《SQL Server2005技术内幕之T-SQL查询》 这本书虽然是针对SQL Server写的， 但是里面的大部份内容同样适用于其它关系数据库，此书对查询编写的技巧和优化讲解的非常透彻。 《关系数据库系统概论》第四版 王珊和萨师煊写的那本， 是大学计算机教材， 讲的通俗易懂， 在国内计算机书图书出版领域质量是排的上号的。 《数据库系统概念》 这本书在数据库领域非常出名， 被称之为帆船书， 书中内容博大精深，非一朝一夕可参透的。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://conanisbest.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://conanisbest.github.io/tags/mysql/"}]},{"title":"Java中static关键字的作用与用法","slug":"static","date":"2020-08-26T10:25:13.000Z","updated":"2020-08-26T10:27:23.885Z","comments":true,"path":"2020/08/26/static/","link":"","permalink":"https://conanisbest.github.io/2020/08/26/static/","excerpt":"","text":"Java中static关键字的作用与用法一、static关键字的特点：static是一个修饰符，用于修饰类的成员方法、类的成员变量，另外可以编写static代码块来优化程序性能。 static修饰成员方法 ​ static修饰的方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都必须依赖具体的对象才能够被调用。 ​ 但是要注意的是，虽然在静态方法中不能访问非静态成员方法和非静态成员变量，但是在非静态成员方法中是可以访问静态成员方法/变量的。例如： 在上面的代码中，由于print2方法是独立于对象存在的，可以直接用类名调用。 假如说可以在静态方法中访问非静态方法/变量的话，那么如果在main方法中有下面一条语句： MyObject.print2(); 此时对象都没有，str2根本就不存在，所以就会产生矛盾了。同样对于方法也是一样，由于你无法预知在print1方法中是否访问了非静态成员变量，所以也禁止在静态成员方法中访问非静态成员方法。 而对于非静态成员方法，它访问静态成员方法/变量显然是毫无限制的。 因此，如果说想在不创建对象的情况下调用某个方法，就可以将这个方法设置为static。我们最常见的static方法就是main方法，至于为什么main方法必须是static的，现在就很清楚了。因为程序在执行main方法的时候没有创建任何对象，因此只有通过类名来访问。 \\2. static修饰成员变量 ​ static修饰的变量也称为静态变量，静态变量和非静态变量的区别是：静态变量被所有对象共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 ​ static成员变量的初始化顺序按照定义的顺序进行初始化。 \\3. static修饰代码块 ​ static关键字还有一个比较重要的作用就是用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来依次执行每个static块，并且只会执行一次。 ​ static块可以优化程序性能，是因为它的特性：只会在类被初次加载的时候执行一次。如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class Person&#123; private Date birthDate; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; Date startDate = Date.valueOf(\"1946\"); Date endDate = Date.valueOf(\"1964\"); return birthDate.compareTo(startDate)&gt;=0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; isBornBoomer是用来判断一个人是否是1946-1964年出生的，而每次isBornBoomer被调用的时候，都会生成startDate和birthDate两个对象，造成了空间浪费，如果改成下面这样效率会更高： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Person &#123; private Date birthDate; private static Date startDate, endDate; static &#123; startDate = Date.valueOf(\"1946\"); endDate = Date.valueOf(\"1964\"); &#125; public Person(Date birthDate) &#123; this.birthDate = birthDate; &#125; boolean isBornBoomer() &#123; return birthDate.compareTo(startDate) &gt;= 0 &amp;&amp; birthDate.compareTo(endDate) &lt; 0; &#125;&#125; 因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 二、static关键字的误区\\1. 与C/C++中的static不同，Java中的static关键字不会影响到变量的变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected这几个关键字。示例如下： 提示错误，说明static关键字并不会改变变量和方法的访问权限。 \\2. 虽然对于静态方法来说没有this，但是我们在非静态方法中能够通过this访问静态方法成员变量。如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Test &#123; static int value = 11; public static void main(String[] args) &#123; new Test().printValue(); &#125; private void printValue() &#123; int value = 22; System.out.println(this.value); &#125;&#125; 输出的结果是：11 这里的this表示的是当前对象，那么通过new Test()来调用printValue的话，当前对象就是通过new Test()生成的对象。而static变量是被对象所享有的，因此在printValue中的this.value的值毫无疑问是11。在printValue方法内部的value是局部变量，根本不可能与this关联，所以输出11。需要记住的是：静态成员变量虽然独立于对象，但是不代表不可以通过对象去访问，所有的静态方法和静态变量都可以通过对象访问（只要权限足够）。 \\3. 在C/C++中static关键字是可以作用于局部变量的，但是在Java中是不允许使用static修饰局部变量的。这是Java语法的规定。","categories":[{"name":"static关键字","slug":"static关键字","permalink":"https://conanisbest.github.io/categories/static%E5%85%B3%E9%94%AE%E5%AD%97/"}],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"java中拆箱装箱","slug":"拆箱装箱","date":"2020-08-19T03:45:49.000Z","updated":"2020-08-19T05:05:18.376Z","comments":true,"path":"2020/08/19/拆箱装箱/","link":"","permalink":"https://conanisbest.github.io/2020/08/19/%E6%8B%86%E7%AE%B1%E8%A3%85%E7%AE%B1/","excerpt":"","text":"深入剖析Java中的装箱和拆箱 自动装箱和拆箱问题是Java中一个老生常谈的问题了，今天我们就来一些看一下装箱和拆箱中的若干问题。本文先讲述装箱和拆箱最基本的东西，再来看一下面试笔试中经常遇到的与装箱、拆箱相关的问题。 以下是本文的目录大纲： 一.什么是装箱？什么是拆箱？ 二.装箱和拆箱是如何实现的 三.面试中相关的问题 若有不正之处，请谅解和批评指正，不胜感激。 请尊重作者劳动成果，转载请标明原文链接： http://www.cnblogs.com/dolphin0520/p/3780005.html 一.什么是装箱？什么是拆箱？ 在前面的文章中提到，Java为每种基本数据类型都提供了对应的包装器类型，至于为什么会为每种基本数据类型提供包装器类型在此不进行阐述，有兴趣的朋友可以查阅相关资料。在Java SE5之前，如果要生成一个数值为10的Integer对象，必须这样进行： 1Integer i = new Integer(10); 而在从Java SE5开始就提供了自动装箱的特性，如果要生成一个数值为10的Integer对象，只需要这样就可以了： 1Integer i = 10; 这个过程中会自动根据数值创建对应的 Integer对象，这就是装箱。 那什么是拆箱呢？顾名思义，跟装箱对应，就是自动将包装器类型转换为基本数据类型： 12Integer i = 10; //装箱int n = i; //拆箱 简单一点说，装箱就是 自动将基本数据类型转换为包装器类型；拆箱就是 自动将包装器类型转换为基本数据类型。 下表是基本数据类型对应的包装器类型： int（4字节） Integer byte（1字节） Byte short（2字节） Short long（8字节） Long float（4字节） Float double（8字节） Double char（2字节） Character boolean（未定） Boolean 二.装箱和拆箱是如何实现的 上一小节了解装箱的基本概念之后，这一小节来了解一下装箱和拆箱是如何实现的。 我们就以Interger类为例，下面看一段代码： 1234567public class Main &#123; public static void main(String[] args) &#123; Integer i = 10; int n = i; &#125;&#125; 反编译class文件之后得到如下内容： 从反编译得到的字节码内容可以看出，在装箱的时候自动调用的是Integer的valueOf(int)方法。而在拆箱的时候自动调用的是Integer的intValue方法。 其他的也类似，比如Double、Character，不相信的朋友可以自己手动尝试一下。 因此可以用一句话总结装箱和拆箱的实现过程： 装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。 三.面试中相关的问题 虽然大多数人对装箱和拆箱的概念都清楚，但是在面试和笔试中遇到了与装箱和拆箱的问题却不一定会答得上来。下面列举一些常见的与装箱/拆箱有关的面试题。 1.下面这段代码的输出结果是什么？ 123456789101112public class Main &#123; public static void main(String[] args) &#123; Integer i1 = 100; Integer i2 = 100; Integer i3 = 200; Integer i4 = 200; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 也许有些朋友会说都会输出false，或者也有朋友会说都会输出true。但是事实上输出结果是： 12truefalse 为什么会出现这样的结果？输出结果表明i1和i2指向的是同一个对象，而i3和i4指向的是不同的对象。此时只需一看源码便知究竟，下面这段代码是Integer的valueOf方法的具体实现： 123456public static Integer valueOf(int i) &#123; if(i &gt;= -128 &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + 128]; else return new Integer(i); &#125; 而其中IntegerCache类的实现为： 123456789101112131415161718192021222324252627private static class IntegerCache &#123; static final int high; static final Integer cache[]; static &#123; final int low = -128; // high value may be configured by property int h = 127; if (integerCacheHighPropValue != null) &#123; // Use Long.decode here to avoid invoking methods that // require Integer's autoboxing cache to be initialized int i = Long.decode(integerCacheHighPropValue).intValue(); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - -low); &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); &#125; private IntegerCache() &#123;&#125; &#125; 从这2段代码可以看出，在通过valueOf方法创建Integer对象的时候，如果数值在[-128,127]之间，便返回指向IntegerCache.cache中已经存在的对象的引用；否则创建一个新的Integer对象。 上面的代码中i1和i2的数值为100，因此会直接从cache中取已经存在的对象，所以i1和i2指向的是同一个对象，而i3和i4则是分别指向不同的对象。 2.下面这段代码的输出结果是什么？ 123456789101112public class Main &#123; public static void main(String[] args) &#123; Double i1 = 100.0; Double i2 = 100.0; Double i3 = 200.0; Double i4 = 200.0; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 也许有的朋友会认为跟上面一道题目的输出结果相同，但是事实上却不是。实际输出结果为： 12falsefalse 至于具体为什么，读者可以去查看Double类的valueOf的实现。 在这里只解释一下为什么Double类的valueOf方法会采用与Integer类的valueOf方法不同的实现。很简单：在某个范围内的整型数值的个数是有限的，而浮点数却不是。 注意，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的。 Double、Float的valueOf方法的实现是类似的。 3.下面这段代码输出结果是什么： 123456789101112public class Main &#123; public static void main(String[] args) &#123; Boolean i1 = false; Boolean i2 = false; Boolean i3 = true; Boolean i4 = true; System.out.println(i1==i2); System.out.println(i3==i4); &#125;&#125; 输出结果是： 12truetrue 至于为什么是这个结果，同样地，看了Boolean类的源码也会一目了然。下面是Boolean的valueOf方法的具体实现： 123public static Boolean valueOf(boolean b) &#123; return (b ? TRUE : FALSE); &#125; 而其中的 TRUE 和FALSE又是什么呢？在Boolean中定义了2个静态成员属性： 1234567public static final Boolean TRUE = new Boolean(true); /** * The &lt;code&gt;Boolean&lt;/code&gt; object corresponding to the primitive * value &lt;code&gt;false&lt;/code&gt;. */ public static final Boolean FALSE = new Boolean(false); 至此，大家应该明白了为何上面输出的结果都是true了。 4.谈谈Integer i = new Integer(xxx)和Integer i =xxx;这两种方式的区别。 当然，这个题目属于比较宽泛类型的。但是要点一定要答上，我总结一下主要有以下这两点区别： 1）第一种方式不会触发自动装箱的过程；而第二种方式会触发； 2）在执行效率和资源占用上的区别。第二种方式的执行效率和资源占用在一般性情况下要优于第一种情况（注意这并不是绝对的）。 5.下面程序的输出结果是什么？ 123456789101112131415161718192021public class Main &#123; public static void main(String[] args) &#123; Integer a = 1; Integer b = 2; Integer c = 3; Integer d = 3; Integer e = 321; Integer f = 321; Long g = 3L; Long h = 2L; System.out.println(c==d); System.out.println(e==f); System.out.println(c==(a+b)); System.out.println(c.equals(a+b)); System.out.println(g==(a+b)); System.out.println(g.equals(a+b)); System.out.println(g.equals(a+h)); &#125;&#125; 先别看输出结果，读者自己想一下这段代码的输出结果是什么。这里面需要注意的是：当 “==”运算符的两个操作数都是 包装器类型的引用，则是比较指向的是否是同一个对象，而如果其中有一个操作数是表达式（即包含算术运算）则比较的是数值（即会触发自动拆箱的过程）。另外，对于包装器类型，equals方法并不会进行类型转换。明白了这2点之后，上面的输出结果便一目了然： 1234567truefalsetruetruetruefalsetrue 第一个和第二个输出结果没有什么疑问。第三句由于 a+b包含了算术运算，因此会触发自动拆箱过程（会调用intValue方法），因此它们比较的是数值是否相等。而对于c.equals(a+b)会先触发自动拆箱过程，再触发自动装箱过程，也就是说a+b，会先各自调用intValue方法，得到了加法运算后的数值之后，便调用Integer.valueOf方法，再进行equals比较。同理对于后面的也是这样，不过要注意倒数第二个和最后一个输出的结果（如果数值是int类型的，装箱过程调用的是Integer.valueOf；如果是long类型的，装箱调用的Long.valueOf方法）。","categories":[{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"jsp","slug":"jsp","date":"2020-08-19T03:43:45.000Z","updated":"2020-08-19T03:45:19.144Z","comments":true,"path":"2020/08/19/jsp/","link":"","permalink":"https://conanisbest.github.io/2020/08/19/jsp/","excerpt":"","text":"JSP九大内置对象 JSP中一共预先定义了9个这样的对象，分别为：request、response、session、application、out、pagecontext、config、page、exception 1、request对象 request 对象是 javax.servlet.httpServletRequest类型的对象。 该对象代表了客户端的请求信息，主要用于接受通过HTTP协议传送到服务器的数据。（包括头信息、系统信息、请求方式以及请求参数等）。request对象的作用域为一次请求。 2、response对象 response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端。response对象也具有作用域，它只在JSP页面内有效。 3、session对象 session 对象是由服务器自动创建的与用户请求相关的对象。服务器为每个用户都生成一个session对象，用于保存该用户的信息，跟踪用户的操作状态。session对象内部使用Map类来保存数据，因此保存数据的格式为 “Key/value”。 session对象的value可以使复杂的对象类型，而不仅仅局限于字符串类型。 4、application对象 application 对象可将信息保存在服务器中，直到服务器关闭，否则application对象中保存的信息会在整个应用中都有效。与session对象相比，application对象生命周期更长，类似于系统的“全局变量”。 5、out 对象 out 对象用于在Web浏览器内输出信息，并且管理应用服务器上的输出缓冲区。在使用 out 对象输出数据时，可以对数据缓冲区进行操作，及时清除缓冲区中的残余数据，为其他的输出让出缓冲空间。待数据输出完毕后，要及时关闭输出流。 6、pageContext 对象 pageContext 对象的作用是取得任何范围的参数，通过它可以获取 JSP页面的out、request、reponse、session、application 等对象。pageContext对象的创建和初始化都是由容器来完成的，在JSP页面中可以直接使用 pageContext对象。 7、config 对象 config 对象的主要作用是取得服务器的配置信息。通过 pageConext对象的 getServletConfig() 方法可以获取一个config对象。当一个Servlet 初始化时，容器把某些信息通过config对象传递给这个 Servlet。 开发者可以在web.xml 文件中为应用程序环境中的Servlet程序和JSP页面提供初始化参数。 8、page 对象 page 对象代表JSP本身，只有在JSP页面内才是合法的。 page隐含对象本质上包含当前 Servlet接口引用的变量，类似于Java编程中的 this 指针。 9、exception 对象 exception 对象的作用是显示异常信息，只有在包含 isErrorPage=”true” 的页面中才可以被使用，在一般的JSP页面中使用该对象将无法编译JSP文件。excepation对象和Java的所有对象一样，都具有系统提供的继承结构。exception 对象几乎定义了所有异常情况。在Java程序中，可以使用try/catch关键字来处理异常情况； 如果在JSP页面中出现没有捕获到的异常，就会生成 exception 对象，并把 exception 对象传送到在page指令中设定的错误页面中，然后在错误页面中处理相应的 exception 对象。","categories":[{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"https://conanisbest.github.io/tags/jsp/"}]},{"title":"HashMap","slug":"hashmap","date":"2020-08-19T02:08:05.000Z","updated":"2020-08-19T02:09:56.551Z","comments":true,"path":"2020/08/19/hashmap/","link":"","permalink":"https://conanisbest.github.io/2020/08/19/hashmap/","excerpt":"","text":"深入浅出学Java——HashMap 哈希表（hash table）也叫散列表，是一种非常重要的数据结构，应用场景及其丰富，许多缓存技术（比如memcached）的核心其实就是在内存中维护一张大的哈希表，本文会对java集合框架中HashMap的实现原理进行讲解，并对JDK7的HashMap源码进行分析。 一、什么是哈希表 在讨论哈希表之前，我们先大概了解下其他数据结构在新增，查找等基础操作执行性能 数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为O(1)；通过给定值进行查找，需要遍历数组，逐一比对给定关键字和数组元素，时间复杂度为O(n)，当然，对于有序数组，则可采用二分查找，插值查找，斐波那契查找等方式，可将查找复杂度提高为O(logn)；对于一般的插入删除操作，涉及到数组元素的移动，其平均复杂度也为O(n) 线性链表：对于链表的新增，删除等操作（在找到指定操作位置后），仅需处理结点间的引用即可，时间复杂度为O(1)，而查找操作需要遍历链表逐一进行比对，复杂度为O(n) 二叉树：对一棵相对平衡的有序二叉树，对其进行插入，查找，删除等操作，平均复杂度均为O(logn)。 哈希表：相比上述几种数据结构，在哈希表中进行添加，删除，查找等操作，性能十分之高，不考虑哈希冲突的情况下（后面会探讨下哈希冲突的情况），仅需一次定位即可完成，时间复杂度为O(1)，接下来我们就来看看哈希表是如何实现达到惊艳的常数阶O(1)的。 我们知道，数据结构的物理存储结构只有两种：顺序存储结构和链式存储结构（像栈，队列，树，图等是从逻辑结构去抽象的，映射到内存中，也这两种物理组织形式），而在上面我们提到过，在数组中根据下标查找某个元素，一次定位就可以达到，哈希表利用了这种特性，哈希表的主干就是数组。 比如我们要新增或查找某个元素，我们通过把当前元素的关键字 通过某个函数映射到数组中的某个位置，通过数组下标一次定位就可完成操作。 这个函数可以简单描述为：存储位置 = f(关键字) ，这个函数f一般称为哈希函数，这个函数的设计好坏会直接影响到哈希表的优劣。举个例子，比如我们要在哈希表中执行插入操作：插入过程如下图所示 查找操作同理，先通过哈希函数计算出实际存储地址，然后从数组中对应地址取出即可。 哈希冲突 然而万事无完美，如果两个不同的元素，通过哈希函数得出的实际存储地址相同怎么办？也就是说，当我们对某个元素进行哈希运算，得到一个存储地址，然后要进行插入的时候，发现已经被其他元素占用了，其实这就是所谓的哈希冲突，也叫哈希碰撞。前面我们提到过，哈希函数的设计至关重要，好的哈希函数会尽可能地保证 计算简单和散列地址分布均匀,但是，我们需要清楚的是，数组是一块连续的固定长度的内存空间，再好的哈希函数也不能保证得到的存储地址绝对不发生冲突。那么哈希冲突如何解决呢？哈希冲突的解决方案有多种:开放定址法（发生冲突，继续寻找下一块未被占用的存储地址），再散列函数法，链地址法，而HashMap即是采用了链地址法，也就是数组+链表的方式。 二、HashMap的实现原理 HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。（其实所谓Map其实就是保存了两个对象之间的映射关系的一种集合） 1234//HashMap的主干数组，可以看到就是一个Entry数组，初始值为空数组&#123;&#125;，主干数组的长度一定是2的次幂。//至于为什么这么做，后面会有详细分析。transient Entry&lt;K,V&gt;[] table = (Entry&lt;K,V&gt;[]) EMPTY_TABLE;123 Entry是HashMap中的一个静态内部类。代码如下 12345678910111213141516 static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final K key; V value; Entry&lt;K,V&gt; next;//存储指向下一个Entry的引用，单链表结构 int hash;//对key的hashcode值进行hash运算后得到的值，存储在Entry，避免重复计算 /** * Creates new entry. */ Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123; value = v; next = n; key = k; hash = h; &#125; 123456789101112131415 所以，HashMap的总体结构如下： 简单来说，HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的，如果定位到的数组位置不含链表（当前entry的next指向null）,那么查找，添加等操作很快，仅需一次寻址即可；如果定位到的数组包含链表，对于添加操作，其时间复杂度为O(n)，首先遍历链表，存在即覆盖，否则新增；对于查找操作来讲，仍需遍历链表，然后通过key对象的equals方法逐一比对查找。所以，性能考虑，HashMap中的链表出现越少，性能才会越好。 其他几个重要字段 123456789101112131415161718/**实际存储的key-value键值对的个数*/transient int size;/**阈值，当table == &#123;&#125;时，该值为初始容量（初始容量默认为16）；当table被填充了，也就是为table分配内存空间后，threshold一般为 capacity*loadFactory。HashMap在进行扩容时需要参考threshold，后面会详细谈到*/int threshold;/**负载因子，代表了table的填充度有多少，默认是0.75加载因子存在的原因，还是因为减缓哈希冲突，如果初始桶为16，等到满16个元素才扩容，某些桶里可能就有不止一个元素了。所以加载因子默认为0.75，也就是说大小为16的HashMap，到了第13个元素，就会扩容成32。*/final float loadFactor;/**HashMap被改变的次数，由于HashMap非线程安全，在对HashMap进行迭代时，如果期间其他线程的参与导致HashMap的结构发生变化了（比如put，remove等操作），需要抛出异常ConcurrentModificationException*/transient int modCount;1234567891011121314151617 HashMap有4个构造器，其他构造器如果用户没有传入initialCapacity 和loadFactor这两个参数，会使用默认值 initialCapacity默认为16，loadFactory默认为0.75 我们看下其中一个 1234567891011121314151617public HashMap(int initialCapacity, float loadFactor) &#123; //此处对传入的初始容量进行校验，最大不能超过MAXIMUM_CAPACITY = 1&lt;&lt;30(230) if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; threshold = initialCapacity; init();//init方法在HashMap中没有实际实现，不过在其子类如 linkedHashMap中就会有对应实现 &#125;12345678910111213141516 从上面这段代码我们可以看出，在常规构造器中，没有为数组table分配内存空间（有一个入参为指定Map的构造器例外），而是在执行put操作的时候才真正构建table数组 OK,接下来我们来看看put操作的实现 1234567891011121314151617181920212223242526public V put(K key, V value) &#123; //如果table数组为空数组&#123;&#125;，进行数组填充（为table分配实际内存空间），入参为threshold， //此时threshold为initialCapacity 默认是1&lt;&lt;4(24=16) if (table == EMPTY_TABLE) &#123; inflateTable(threshold); &#125; //如果key为null，存储位置为table[0]或table[0]的冲突链上 if (key == null) return putForNullKey(value); int hash = hash(key);//对key的hashcode进一步计算，确保散列均匀 int i = indexFor(hash, table.length);//获取在table中的实际位置 for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123; //如果该对应数据已存在，执行覆盖操作。用新value替换旧value，并返回旧value Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; modCount++;//保证并发访问时，若HashMap内部结构发生变化，快速响应失败 addEntry(hash, key, value, i);//新增一个entry return null; &#125;12345678910111213141516171819202122232425 inflateTable这个方法用于为主干数组table在内存中分配存储空间，通过roundUpToPowerOf2(toSize)可以确保capacity为大于或等于toSize的最接近toSize的二次幂，比如toSize=13,则capacity=16;to_size=16,capacity=16;to_size=17,capacity=32. 123456789private void inflateTable(int toSize) &#123; int capacity = roundUpToPowerOf2(toSize);//capacity一定是2的次幂 /**此处为threshold赋值，取capacity*loadFactor和MAXIMUM_CAPACITY+1的最小值， capaticy一定不会超过MAXIMUM_CAPACITY，除非loadFactor大于1 */ threshold = (int) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1); table = new Entry[capacity]; initHashSeedAsNeeded(capacity); &#125;12345678 roundUpToPowerOf2中的这段处理使得数组长度一定为2的次幂，Integer.highestOneBit是用来获取最左边的bit（其他bit位为0）所代表的数值. 12345678 private static int roundUpToPowerOf2(int number) &#123; // assert number &gt;= 0 : \"number must be non-negative\"; return number &gt;= MAXIMUM_CAPACITY ? MAXIMUM_CAPACITY : (number &gt; 1) ? Integer.highestOneBit((number - 1) &lt;&lt; 1) : 1; &#125;1234567 hash函数 1234567891011121314/**这是一个神奇的函数，用了很多的异或，移位等运算对key的hashcode进一步进行计算以及二进制位的调整等来保证最终获取的存储位置尽量分布均匀*/final int hash(Object k) &#123; int h = hashSeed; if (0 != h &amp;&amp; k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h ^= k.hashCode(); h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125;12345678910111213 以上hash函数计算出的值，通过indexFor进一步处理来获取实际的存储位置 1234567/** * 返回数组下标 */ static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125;123456 h&amp;（length-1）保证获取的index一定在数组范围内，举个例子，默认容量16，length-1=15，h=18,转换成二进制计算为index=2。位运算对计算机来说，性能更高一些（HashMap中有大量位运算） 所以最终存储位置的确定流程是这样的： 再来看看addEntry的实现： 12345678910void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123; resize(2 * table.length);//当size超过临界阈值threshold，并且即将发生哈希冲突时进行扩容 hash = (null != key) ? hash(key) : 0; bucketIndex = indexFor(hash, table.length); &#125; createEntry(hash, key, value, bucketIndex); &#125;123456789 通过以上代码能够得知，当发生哈希冲突并且size大于阈值的时候，需要进行数组扩容，扩容时，需要新建一个长度为之前数组2倍的新的数组，然后将当前的Entry数组中的元素全部传输过去，扩容后的新数组长度为之前的2倍，所以扩容相对来说是个耗资源的操作。 三、为何HashMap的数组长度一定是2的次幂？ 我们来继续看上面提到的resize方法 1234567891011121314void resize(int newCapacity) &#123; Entry[] oldTable = table; int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry[] newTable = new Entry[newCapacity]; transfer(newTable, initHashSeedAsNeeded(newCapacity)); table = newTable; threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1); &#125;12345678910111213 如果数组进行扩容，数组长度发生变化，而存储位置 index = h&amp;(length-1),index也可能会发生变化，需要重新计算index，我们先来看看transfer这个方法 123456789101112131415161718void transfer(Entry[] newTable, boolean rehash) &#123; int newCapacity = newTable.length; //for循环中的代码，逐个遍历链表，重新计算索引位置，将老数组数据复制到新数组中去（数组不存储实际数据，所以仅仅是拷贝引用而已） for (Entry&lt;K,V&gt; e : table) &#123; while(null != e) &#123; Entry&lt;K,V&gt; next = e.next; if (rehash) &#123; e.hash = null == e.key ? 0 : hash(e.key); &#125; int i = indexFor(e.hash, newCapacity); //将当前entry的next链指向新的索引位置,newTable[i]有可能为空，有可能也是个entry链，如果是entry链，直接在链表头部插入。 e.next = newTable[i]; newTable[i] = e; e = next; &#125; &#125; &#125;1234567891011121314151617 这个方法将老数组中的数据逐个链表地遍历，扔到新的扩容后的数组中，我们的数组索引位置的计算是通过 对key值的hashcode进行hash扰乱运算后，再通过和 length-1进行位运算得到最终数组索引位置。 HashMap的数组长度一定保持2的次幂，比如16的二进制表示为 10000，那么length-1就是15，二进制为01111，同理扩容后的数组长度为32，二进制表示为100000，length-1为31，二进制表示为011111。从下图可以我们也能看到这样会保证低位全为1，而扩容后只有一位差异，也就是多出了最左位的1，这样在通过 h&amp;(length-1)的时候，只要h对应的最左边的那一个差异位为0，就能保证得到的新的数组索引和老数组索引一致(大大减少了之前已经散列良好的老数组的数据位置重新调换)，个人理解。 还有，数组长度保持2的次幂，length-1的低位都为1，会使得获得的数组索引index更加均匀 我们看到，上面的&amp;运算，高位是不会对结果产生影响的（hash函数采用各种位运算可能也是为了使得低位更加散列），我们只关注低位bit，如果低位全部为1，那么对于h低位部分来说，任何一位的变化都会对结果产生影响，也就是说，要得到index=21这个存储位置，h的低位只有这一种组合。这也是数组长度设计为必须为2的次幂的原因。如果不是2的次幂，也就是低位不是全为1此时，要使得index=21，h的低位部分不再具有唯一性了，哈希冲突的几率会变的更大，同时，index对应的这个bit位无论如何不会等于1了，而对应的那些数组位置也就被白白浪费了。 get方法： 12345678 public V get(Object key) &#123; //如果key为null,则直接去table[0]处去检索即可。 if (key == null) return getForNullKey(); Entry&lt;K,V&gt; entry = getEntry(key); return null == entry ? null : entry.getValue(); &#125;1234567 get方法通过key值返回对应value，如果key为null，直接去table[0]处检索。我们再看一下getEntry这个方法 12345678910111213141516171819final Entry&lt;K,V&gt; getEntry(Object key) &#123; if (size == 0) &#123; return null; &#125; //通过key的hashcode值计算hash值 int hash = (key == null) ? 0 : hash(key); //indexFor (hash&amp;length-1) 获取最终数组索引，然后遍历链表，通过equals方法比对找出对应记录 for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 123456789101112131415161718 可以看出，get方法的实现相对简单，key(hashcode)–&gt;hash–&gt;indexFor–&gt;最终索引位置，找到对应位置table[i]，再查看是否有链表，遍历链表，通过key的equals方法比对查找对应的记录。要注意的是，有人觉得上面在定位到数组位置之后然后遍历链表的时候，e.hash == hash这个判断没必要，仅通过equals判断就可以。其实不然，试想一下，如果传入的key对象重写了equals方法却没有重写hashCode，而恰巧此对象定位到这个数组位置，如果仅仅用equals判断可能是相等的，但其hashCode和当前对象不一致，这种情况，根据Object的hashCode的约定，不能返回当前对象，而应该返回null，后面的例子会做出进一步解释。 四、重写equals方法需同时重写hashCode方法 最后我们再聊聊老生常谈的一个问题，各种资料上都会提到，“重写equals时也要同时覆盖hashcode”，我们举个小例子来看看，如果重写了equals而不重写hashcode会发生什么样的问题 1234567891011121314151617181920212223242526272829303132333435public class MyTest &#123; private static class Person&#123; int idCard; String name; public Person(int idCard, String name) &#123; this.idCard = idCard; this.name = name; &#125; @Override public boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (o == null || getClass() != o.getClass())&#123; return false; &#125; Person person = (Person) o; //两个对象是否等值，通过idCard来确定 return this.idCard == person.idCard; &#125; &#125; public static void main(String []args)&#123; HashMap&lt;Person,String&gt; map = new HashMap&lt;Person, String&gt;(); Person person = new Person(1234,\"乔峰\"); //put到hashmap中去 map.put(person,\"天龙八部\"); //get取出，从逻辑上讲应该能输出“天龙八部” System.out.println(\"结果:\"+map.get(new Person(1234,\"萧峰\"))); &#125;&#125;实际输出结果：null1234567891011121314151617181920212223242526272829303132333435 如果我们已经对HashMap的原理有了一定了解，这个结果就不难理解了。尽管我们在进行get和put操作的时候，使用的key从逻辑上讲是等值的（通过equals比较是相等的），但由于没有重写hashCode方法，所以put操作时，key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置 ，而通过key取出value的时候 key(hashcode1)–&gt;hash–&gt;indexFor–&gt;最终索引位置，由于hashcode1不等于hashcode2，导致没有定位到一个数组位置而返回逻辑上错误的值null（也有可能碰巧定位到一个数组位置，但是也会判断其entry的hash值是否相等，上面get方法中有提到。） 所以，在重写equals的方法的时候，必须注意重写hashCode方法，同时还要保证通过equals判断相等的两个对象，调用hashCode方法要返回同样的整数值。而如果equals判断不相等的两个对象，其hashCode可以相同（只不过会发生哈希冲突，应尽量避免）。 五、JDK1.8中HashMap的性能优化 假如一个数组槽位上链上数据过多（即拉链过长的情况）导致性能下降该怎么办？JDK1.8在JDK1.7的基础上针对增加了红黑树来进行优化。即当链表超过8时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。关于这方面的探讨我们以后的文章再做说明。附：HashMap put方法逻辑图（JDK1.8）","categories":[{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"}],"tags":[{"name":"hashmap","slug":"hashmap","permalink":"https://conanisbest.github.io/tags/hashmap/"}]},{"title":"HTTP和HTTPS","slug":"test","date":"2020-08-18T03:02:58.000Z","updated":"2020-08-18T03:21:34.464Z","comments":true,"path":"2020/08/18/test/","link":"","permalink":"https://conanisbest.github.io/2020/08/18/test/","excerpt":"","text":"一、前言：先来观察这两张图，第一张访问域名http://www.12306.cn，谷歌浏览器提示不安全链接，第二张是https://kyfw.12306.cn/otn/regist/init，浏览器显示安全，为什么会这样子呢？2017年1月发布的Chrome 56浏览器开始把收集密码或信用卡数据的HTTP页面标记为“不安全”，若用户使用2017年10月推出的Chrome 62，带有输入数据的HTTP页面和所有以无痕模式浏览的HTTP页面都会被标记为“不安全”，此外，苹果公司强制所有iOS App在2017年1月1日前使用HTTPS加密。 二、HTTP和HTTPS发展历史什么是HTTP? 超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。设计HTTP的初衷是为了提供一种发布和接收HTML页面的方法。 发展历史： 版本 产生时间 内容 发展现状 HTTP/0.9 1991年 不涉及数据包传输，规定客户端和服务器之间通信格式，只能GET请求 没有作为正式的标准 HTTP/1.0 1996年 传输内容格式不限制，增加PUT、PATCH、HEAD、 OPTIONS、DELETE命令 正式作为标准 HTTP/1.1 1997年 持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码 2015年前使用最广泛 HTTP/2 2015年 多路复用、服务器推送、头信息压缩、二进制协议等 逐渐覆盖市场 这个Akamai公司建立的一个官方的演示，使用HTTP/1.1和HTTP/2同时请求379张图片，观察请求的时间，明显看出HTTP/2性能占优势。多路复用：通过单一的HTTP/2连接请求发起多重的请求-响应消息，多个请求stream共享一个TCP连接，实现多留并行而不是依赖建立多个TCP连接。 HTTP报文格式 什么是HTTPS？ 《图解HTTP》这本书中曾提过HTTPS是身披SSL外壳的HTTP。HTTPS是一种通过计算机网络进行安全通信的传输协议，经由HTTP进行通信，利用SSL/TLS建立全信道，加密数据包。HTTPS使用的主要目的是提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性。 PS:TLS是传输层加密协议，前身是SSL协议，由网景公司1995年发布，有时候两者不区分。 参考连接：1.https://kamranahmed.info/blog/2016/08/13/http-in-depth/ 2.https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol 3.https://tools.ietf.org/html/rfc1945 4.https://http2.github.io/http2-spec/ 5.https://www.zhihu.com/question/34074946 三、HTTP VS HTTPSHTTP特点： 无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作 无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。 基于请求和响应：基本的特性，由客户端发起请求，服务端响应 简单快速、灵活 通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性 下面通过一个简单的抓包实验观察使用HTTP请求传输的数据： 结果分析：HTTP协议传输数据以明文形式显示针对无状态的一些解决策略：场景：逛电商商场用户需要使用的时间比较长，需要对用户一段时间的HTTP通信状态进行保存，比如执行一次登陆操作，在30分钟内所有的请求都不需要再次登陆。 通过Cookie/Session技术 HTTP/1.1持久连接（HTTP keep-alive）方法，只要任意一端没有明确提出断开连接，则保持TCP连接状态，在请求首部字段中的Connection: keep-alive即为表明使用了持久连接 HTTPS特点：基于HTTP协议，通过SSL或TLS提供加密处理数据、验证对方身份以及数据完整性保护 通过抓包可以看到数据不是明文传输，而且HTTPS有如下特点： 内容加密：采用混合加密技术，中间者无法直接查看明文内容 验证身份：通过证书认证客户端访问的是自己的服务器 保护数据完整性：防止传输的内容被中间人冒充或者篡改 混合加密：结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。 数字摘要：通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文。 数字签名技术：数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术。 收方能够证实发送方的真实身份； 发送方事后不能否认所发送过的报文； 收方或非法者不能伪造、篡改报文。 非对称加密过程需要用到公钥进行加密，那么公钥从何而来？其实公钥就被包含在数字证书中，数字证书通常来说是由受信任的数字证书颁发机构CA，在验证服务器身份后颁发，证书中包含了一个密钥对（公钥和私钥）和所有者识别信息。数字证书被放到服务端，具有服务器身份验证和数据传输加密功能。 四、HTTP通信传输 客户端输入URL回车，DNS解析域名得到服务器的IP地址，服务器在80端口监听客户端请求，端口通过TCP/IP协议（可以通过Socket实现）建立连接。HTTP属于TCP/IP模型中的运用层协议，所以通信的过程其实是对应数据的入栈和出栈。报文从运用层传送到运输层，运输层通过TCP三次握手和服务器建立连接，四次挥手释放连接。 为什么需要三次握手呢？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。 比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。 为什么需要四次挥手呢？TCP是全双工模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。 五、HTTPS实现原理SSL建立连接过程 client向server发送请求https://baidu.com，然后连接到server的443端口，发送的信息主要是随机值1和客户端支持的加密算法。 server接收到信息之后给予client响应握手信息，包括随机值2和匹配好的协商加密算法，这个加密算法一定是client发送给server加密算法的子集。 随即server给client发送第二个响应报文是数字证书。服务端必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面，这套证书其实就是一对公钥和私钥。传送证书，这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间、服务端的公钥，第三方证书认证机构(CA)的签名，服务端的域名信息等内容。 客户端解析证书，这部分工作是由客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值（预主秘钥）。 客户端认证证书通过之后，接下来是通过随机值1、随机值2和预主秘钥组装会话秘钥。然后通过证书的公钥加密会话秘钥。 传送加密信息，这部分传送的是用证书加密后的会话秘钥，目的就是让服务端使用秘钥解密得到随机值1、随机值2和预主秘钥。 服务端解密得到随机值1、随机值2和预主秘钥，然后组装会话秘钥，跟客户端会话秘钥相同。 客户端通过会话秘钥加密一条消息发送给服务端，主要验证服务端是否正常接受客户端加密的消息。 同样服务端也会通过会话秘钥加密一条消息回传给客户端，如果客户端能够正常接受的话表明SSL层连接建立完成了。 问题：1.怎么保证保证服务器给客户端下发的公钥是真正的公钥，而不是中间人伪造的公钥呢？ 2.证书如何安全传输，被掉包了怎么办？ 数字证书内容包括了加密后服务器的公钥、权威机构的信息、服务器域名，还有经过CA私钥签名之后的证书内容（经过先通过Hash函数计算得到证书数字摘要，然后用权威机构私钥加密数字摘要得到数字签名)，签名计算方法以及证书对应的域名。 验证证书安全性过程 当客户端收到这个证书之后，使用本地配置的权威机构的公钥对证书进行解密得到服务端的公钥和证书的数字签名，数字签名经过CA公钥解密得到证书信息摘要。 然后证书签名的方法计算一下当前证书的信息摘要，与收到的信息摘要作对比，如果一样，表示证书一定是服务器下发的，没有被中间人篡改过。因为中间人虽然有权威机构的公钥，能够解析证书内容并篡改，但是篡改完成之后中间人需要将证书重新加密，但是中间人没有权威机构的私钥，无法加密，强行加密只会导致客户端无法解密，如果中间人强行乱修改证书，就会导致证书内容和证书签名不匹配。 那第三方攻击者能否让自己的证书显示出来的信息也是服务端呢？（伪装服务端一样的配置）显然这个是不行的，因为当第三方攻击者去CA那边寻求认证的时候CA会要求其提供例如域名的whois信息、域名管理邮箱等证明你是服务端域名的拥有者，而第三方攻击者是无法提供这些信息所以他就是无法骗CA他拥有属于服务端的域名。 六、运用与总结安全性考虑： HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用 SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行 中间人攻击（MITM攻击）是指，黑客拦截并篡改网络中的通信数据。又分为被动MITM和主动MITM，被动MITM只窃取通信数据而不修改，而主动MITM不但能窃取数据，还会篡改通信数据。最常见的中间人攻击常常发生在公共wifi或者公共路由上。 成本考虑： SSL证书需要购买申请，功能越强大的证书费用越高 SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗（SSL有扩展可以部分解决这个问题，但是比较麻烦，而且要求浏览器、操作系统支持，Windows XP就不支持这个扩展，考虑到XP的装机量，这个特性几乎没用）。 根据ACM CoNEXT数据显示，使用HTTPS协议会使页面的加载时间延长近50%，增加10%到20%的耗电。 HTTPS连接缓存不如HTTP高效，流量成本高。 HTTPS连接服务器端资源占用高很多，支持访客多的网站需要投入更大的成本。 HTTPS协议握手阶段比较费时，对网站的响应速度有影响，影响用户体验。比较好的方式是采用分而治之，类似12306网站的主页使用HTTP协议，有关于用户信息等方面使用HTTPS。","categories":[{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"}],"tags":[{"name":"http","slug":"http","permalink":"https://conanisbest.github.io/tags/http/"}]},{"title":"23种设计模式及实现原理","slug":"sjms","date":"2020-08-05T01:28:41.000Z","updated":"2020-08-05T01:34:43.483Z","comments":true,"path":"2020/08/05/sjms/","link":"","permalink":"https://conanisbest.github.io/2020/08/05/sjms/","excerpt":"","text":"23种设计模式及实现原理 一、常用23种设计模式原理图 二、何为设计模式，为什么需要 设计模式是一种模式，在面向对象语言中，它运用类与他们的方法来达到目标。开发人员通常回在学习编程语言，并在编写一段时间的代码之后才会考虑设计。或许我们已经注意到，某些人的代码简洁而实用，那么他们究竟是怎么样才能让代码拥有如此的简单之美？设计模式提升了代码的水准，通常会使用更少的类完成目标。模式是思想的体现，而非具体的实现。 三、为什么选择Java 选择Java的一个重要原因在于它是一门面向对象语言，并且骄Java的包容性使得Java语言变得越来越流行，也确保了未来的语言将基于Java进行演变。 四、设计模式的意图 设计模式的意图在于用更为方便的方式表达需求，而这些却是Java体哦那个的常规机制所无法满足的。列如，Java为定义一个接口提供了丰富的支持，以便类能够实现接口。然而，倘若我们能够拥有一个实现了“错误”接口类，却又需要满足客户的需求，就需要运用适配器模式。适配器的模式设计意图是内置于Java语言中的接口所无法满足的。所以我们将设计模式分为以下5类： 接口型模式 职责型模式 构造型模式 操作型模式 扩展型模式 接口型模式：抽象地讲，类的接口是类允许其他类对象访问的方法与字段集。接口通常代表一种承诺，即方法需要实现接口方法名表示的操作，遵循代码注释、测试和其他文档说明。类的实现就是位于方法体中的代码。 Java将接口概念提升为独立的结构，体现了接口（对象必须遵循的承诺）与实现（对象如何履行承诺）的分离。Java接口允许多个类提供相同的功能，也允许一个类同时实现多个类。","categories":[{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://conanisbest.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"union和union all （记录合并）","slug":"sql1","date":"2020-07-30T07:25:36.000Z","updated":"2020-07-30T07:29:44.236Z","comments":true,"path":"2020/07/30/sql1/","link":"","permalink":"https://conanisbest.github.io/2020/07/30/sql1/","excerpt":"","text":"Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All 两个要联合的SQL语句字段个数必须一样，而且字段类型要“相容”（一致）； 如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。 union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； Union All：对两个结果集进行并集操作，包括重复行，不进行排序； Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序； Minus：对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。 可以在最后一个结果集中指定Order by子句改变排序方式。 union 语法：（去重、默认规则排序） 1234select employee_id,job_id from employees union select employee_id,job_id from job_history 123 union all 语法 1234select employee_id,job_id from employees union allselect employee_id,job_id from job_history 123 注意事项 1.union 和 union all都可以将多个结果集合并，而不仅仅是两个，你可以将多个结果集串起来。 2.使用union和union all必须保证各个select 集合的结果有相同个数的列，并且每个列的类型是一样的。但列名则不一定需要相同，oracle会将第一个结果的列名作为结果集的列名。例如下面是一个例子： 1234select empno,ename from emp union select deptno,dname from dept 123 3.没有必要在每一个select结果集中使用order by子句来进行排序，我们可以在最后使用一条order by来对整个结果进行排序。例如： 1234select empno,ename from emp union select deptno,dname from dept order by ename;","categories":[{"name":"数据库","slug":"数据库","permalink":"https://conanisbest.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://conanisbest.github.io/tags/sql/"}]},{"title":"sql语句的连接查询","slug":"sql","date":"2020-07-30T07:11:32.000Z","updated":"2020-07-30T07:17:23.346Z","comments":true,"path":"2020/07/30/sql/","link":"","permalink":"https://conanisbest.github.io/2020/07/30/sql/","excerpt":"","text":"基本定义： left join （左连接）：返回包括左表中的所有记录和右表中连接字段相等的记录。 right join （右连接）：返回包括右表中的所有记录和左表中连接字段相等的记录。 inner join （等值连接或者叫内连接）：只返回两个表中连接字段相等的行。 full join （全外连接）：返回左右表中所有的记录和左右表中连接字段相等的记录。举个例子： 123456789101112131415161718 A表 id name 1 小王 2 小李 3 小刘 B表 id A_id job 1 2 老师 2 4 程序员 内连接：（只有2张表匹配的行才能显示） 123456select a.name,b.job from A a inner join B b on a.id=b.A_id 只能得到一条记录 小李 老师 左连接：（左边的表不加限制） 12345678910select a.name,b.job from A a left join B b on a.id=b.A_id 三条记录 小王 null 小李 老师 小刘 null 右连接：（右边的表不加限制） 1234567select a.name,b.job from A a right join B b on a.id=b.A_id 两条记录 小李 老师 null 程序员 全外连接：(左右2张表都不加限制） 1234567891011select a.name,b.job from A a full join B b on a.id=b.A_id 四条数据 小王 null 小李 老师 小刘 null null 程序员 注：在sql中外连接包括左连接（left join ）和右连接（right join），全外连接（full join），等值连接（inner join）又叫内连接。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://conanisbest.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://conanisbest.github.io/tags/sql/"}]},{"title":"序列化和反序列化的详解","slug":"xuliehua","date":"2020-07-24T01:49:15.000Z","updated":"2020-07-24T01:59:12.847Z","comments":true,"path":"2020/07/24/xuliehua/","link":"","permalink":"https://conanisbest.github.io/2020/07/24/xuliehua/","excerpt":"","text":"一、基本概念1、序列化和反序列化的定义： 123(1)Java序列化就是指把Java对象转换为字节序列的过程 Java反序列化就是指把字节序列恢复为Java对象的过程。 (2)序列化最重要的作用：在传递和保存对象时.保证对象的完整性和可传递性。对象转换为有序字节流,以便在网络上传输或者保存在本地文件中。 1反序列化的最重要的作用：根据字节流中保存的对象状态及描述信息，通过反序列化重建对象。 总结：核心作用就是对象状态的保存和重建。（整个过程核心点就是字节流中所保存的对象状态及描述信息） 2、json/xml的数据传递： 在数据传输(也可称为网络传输)前，先通过序列化工具类将Java对象序列化为json/xml文件。 在数据传输(也可称为网络传输)后，再将json/xml文件反序列化为对应语言的对象 3、序列化优点： ①将对象转为字节流存储到硬盘上，当JVM停机的话，字节流还会在硬盘上默默等待，等待下一次JVM的启动，把序列化的对象，通过反序列化为原来的对象，并且序列化的二进制序列能够减少存储空间（永久性保存对象）。 ②序列化成字节流形式的对象可以进行网络传输(二进制形式)，方便了网络传输。 ③通过序列化可以在进程间传递对象。 4、序列化算法需要做的事： ① 将对象实例相关的类元数据输出。 ② 递归地输出类的超类描述直到不再有超类。 ③ 类元数据输出完毕后，从最顶端的超类开始输出对象实例的实际数据值。 ④ 从上至下递归输出实例的数据。 二、Java实现序列化和反序列化的过程 1、实现序列化的必备要求： 只有实现了Serializable或者Externalizable接口的类的对象才能被序列化为字节序列。（不是则会抛出异常） 2、JDK中序列化和反序列化的API： ①java.io.ObjectInputStream：对象输入流。 该类的readObject()方法从输入流中读取字节序列，然后将字节序列反序列化为一个对象并返回。 ②java.io.ObjectOutputStream：对象输出流。 该类的writeObject(Object obj)方法将将传入的obj对象进行序列化，把得到的字节序列写入到目标输出流中进行输出。 3、实现序列化和反序列化的三种实现： ①若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化。 ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。 ObjcetInputStream采用默认的反序列化方式，对Student对象的非transient的实例变量进行反序列化。 ②若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。 ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。 ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。 ③若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。 ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。 ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。4、序列化和反序列化代码示例 123456789101112131415161718public class SerializableTest &#123; public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //序列化 FileOutputStream fos = new FileOutputStream(\"object.out\"); ObjectOutputStream oos = new ObjectOutputStream(fos); Student student1 = new Student(\"lihao\", \"wjwlh\", \"21\"); oos.writeObject(student1); oos.flush(); oos.close(); //反序列化 FileInputStream fis = new FileInputStream(\"object.out\"); ObjectInputStream ois = new ObjectInputStream(fis); Student student2 = (Student) ois.readObject(); System.out.println(student2.getUserName()+ \" \" + student2.getPassword() + \" \" + student2.getYear()); &#125;&#125; ​​ 12345678910111213141516171819202122232425262728293031323334353637public class Student implements Serializable&#123; private static final long serialVersionUID = -6060343040263809614L; private String userName; private String password; private String year; public String getUserName() &#123; return userName; &#125; public String getPassword() &#123; return password; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getYear() &#123; return year; &#125; public void setYear(String year) &#123; this.year = year; &#125; public Student(String userName, String password, String year) &#123; this.userName = userName; this.password = password; this.year = year; &#125; &#125; ①序列化图示 ②反序列化图示 三、序列化和反序列化的注意点：①序列化时，只对对象的状态进行保存，而不管对象的方法； ②当一个父类实现序列化，子类自动实现序列化，不需要显式实现Serializable接口； ③当一个对象的实例变量引用其他对象，序列化该对象时也把引用对象进行序列化； ④并非所有的对象都可以序列化，至于为什么不可以，有很多原因了，比如： 安全方面的原因，比如一个对象拥有private，public等field，对于一个要传输的对象，比如写到文件，或者进行RMI传输等等，在序列化进行传输的过程中，这个对象的private等域是不受保护的； 资源分配方面的原因，比如socket，thread类，如果可以序列化，进行传输或者保存，也无法对他们进行重新的资源分配，而且，也是没有必要这样实现； ⑤声明为static和transient类型的成员数据不能被序列化。因为static代表类的状态，transient代表对象的临时数据。 ⑥序列化运行时使用一个称为 serialVersionUID 的版本号与每个可序列化类相关联，该序列号在反序列化过程中用于验证序列化对象的发送者和接收者是否为该对象加载了与序列化兼容的类。为它赋予明确的值。显式地定义serialVersionUID有两种用途： 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的serialVersionUID； 在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的serialVersionUID。 ⑦Java有很多基础类已经实现了serializable接口，比如String,Vector等。但是也有一些没有实现serializable接口的； ⑧如果一个对象的成员变量是一个对象，那么这个对象的数据成员也会被保存！这是能用序列化解决深拷贝的重要原因； 注意：浅拷贝请使用Clone接口的原型模式。————————————————版权声明：本文为CSDN博主「tree_ifconfig」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/tree_ifconfig/java/article/details/82766587","categories":[{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"},{"name":"序列化","slug":"序列化","permalink":"https://conanisbest.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Windows10远程桌面连接提示：出现身份验证错误，要求的函数不受支持。。。","slug":"yczm","date":"2020-07-17T02:38:56.000Z","updated":"2020-07-17T02:50:17.767Z","comments":true,"path":"2020/07/17/yczm/","link":"","permalink":"https://conanisbest.github.io/2020/07/17/yczm/","excerpt":"","text":"Windows10远程桌面连接提示：出现身份验证错误，要求的函数不受支持。。。分类专栏： Windows 错误信息：出现身份验证错误，要求的函数不受支持。。。 解决办法：1、按Windows键+R，或者在CMD命令窗口，输入“运行”，打开运行窗口， 2、输入regedit，打开注册表编辑器， 找到路径：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System 然后在System文件夹内创建文件夹项：\\CredSSP\\Parameters 然后在Parameters文件夹内，新建 DWORD（32）位值（D），文件名为 AllowEncryptionOracle，值为2 3、重新远程连接一下，错误消失，可以正常连接。 也可以尝试使用：IIS7服务器管理工具 ————————————————版权声明：本文为CSDN博主「daqiang012」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/daqiang012/java/article/details/82385720","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://conanisbest.github.io/tags/Windows/"}]},{"title":"redis全面解析","slug":"redis","date":"2020-07-14T02:51:13.000Z","updated":"2020-08-18T02:53:58.415Z","comments":true,"path":"2020/07/14/redis/","link":"","permalink":"https://conanisbest.github.io/2020/07/14/redis/","excerpt":"","text":"redis全面解析分类专栏： 数据库 什么是Redis?Redis 是开源免费的，遵守BSD协议，是一个高性能的key-value非关系型数据库。 redis单线程问题所谓的单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。 redis采用多路复用机制：即多个网络socket复用一个io线程，实际是单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流. Redis特点：Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供String，list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, 设置key有效期等等特性。 redis作用:可以减轻数据库压力，查询内存比查询数据库效率高。 Redis应用：token生成、session共享、分布式锁、自增id、验证码等。 比较重要的3个可执行文件：redis-server：Redis服务器程序 redis-cli：Redis客户端程序，它是一个命令行操作工具。也可以使用telnet根据其纯文本协议操作。 redis-benchmark：Redis性能测试工具，测试Redis在你的系统及配置下的读写性能。 redis数据结构123456789存储字符串1.set key value：设定key持有指定的字符串value，如果该key存在则进行覆盖操作,总是返回OK2.get key: 获取key的value。如果与该key关联的value不是String类型，redis将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回null。3.getset key value：先获取该key的值，然后在设置该key的值。4.incr key：将指定的key的value原子性的递增1. 如果该key不存在，其初始值为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息5.decr key：将指定的key的value原子性的递减1.如果该key不存在，其初始值为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执 行失败并返回相应的错误信息。6.incrby key increment：将指定的key的value原子性增加increment，如果该key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成 整型，如hello则失败并返回错误信息7.decrby key decrement：将指定的key的value原子性减少decrement，如果该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能 转成整型，如hello则失败并返回错误信息8.append key value：如果该key存在，则在原有的value后追加该值；如果该key 不存在，则重新创建一个key&#x2F;value 存储list类型 1.lpush key value1 value2…：在指定的key所关联的list的头部插入所有的values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。 2.rpush key value1、value2…：在该list的尾部添加元素 3.lrange key start end：获取链表中从start到end的元素的值，start、end可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推… 4.lpushx key value：仅当参数中指定的key存在时（如果与key管理的list中没有值时，则该key是不存在的）在指定的key所关联的list的头部插入value。 5.rpushx key value：在该list的尾部添加元素 6.lpop key：返回并弹出指定的key关联的链表中的第一个元素，即头部元素 7.rpop key：从尾部弹出元素 8.rpoplpush resource destination：将链表中的尾部元素弹出并添加到头部 9.llen key：返回指定的key关联的链表中的元素的数量。 10.lset key index value：设置链表中的index的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素。 1234567891011121314151617181920212223242526272829303132333435存储Set添加或删除元素1.sadd key values[value1、value2……]:向set中添加数据，如果该key的值有则不会重复添加例如:sadd myset a b c2.srem key members[member1、menber2…]:删除set中的指定成员例如:srem myset 1 2 3获得集合中的元素1.smembers key :获取set中所有的成员smembers myset2.sismember key menber :判断参数中指定的成员是否在该set中，1表示存在，0表示不存在或者该key本身就不存在(无论集合中有多少元素都可以极速的返回结果)集合的差集运算 A-Bsdiff key1 key2 … : 返回key1与key2中相差的成员，而且与key的顺序有关。即返回差集。集合的交集运算 sinter key1 key2 key3… :返回交集集合的并集运算 sunion key1 key2 key3… : 返回并集扩展命令(了解)scard key : 获取set中的成员数量例子:scard mysetsrandmember key : 随机返回set中的一个成员sdiffstore destination key1 key2 …: 将key1 key2 相差的成员存储到destination中sinterstore destination key[key…] : 将返回的交集存储在destination上suninonstore destination key[key…] : 将返回的并集存储在destination上 12345678910111213141516171819202122232425262728293031323334353637存储hash1.赋值hset key field value : 为指定的key设定field&#x2F;value对hmset key field1 value1 field2 value2 field3 value3 为指定的key设定多个field&#x2F;value对2.取值hget key field : 返回指定的key中的field的值hmget key field1 field2 field3 : 获取key中的多个field值hkeys key : 获取所有的keyhvals key :获取所有的valuehgetall key : 获取key中的所有field 中的所有field-value3.删除hdel key field[field…] : 可以删除一个或多个字段，返回是被删除的字段个数del key : 删除整个list4.增加数字hincrby key field increment ：设置key中field的值增加increment，如: age增加20hincrby myhash age 5自学命令:hexists key field : 判断指定的key中的field是否存在hlen key : 获取key所包含的field的数量hkeys key ：获得所有的key hkeys myhashhvals key ：获得所有的valuehvals myhash 1234567891011121314151617181920212223242526272829存储sortedset1.添加元素zadd key score member score2 member2…:将所有成员以及该成员的分数存放到sorted-set中。如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数。(根据分数升序排列)2.获得元素zscore key member ：返回指定成员的分数zcard key ：获得集合中的成员数量3.删除元素zrem key member[member…] ：移除集合中指定的成员，可以指定多个成员4.范围查询zrange key strat end [withscores]：获取集合中角标为start-end的成员，[withscore]参数表明返回的成员包含其分数。zremrangebyrank key start stop ：按照排名范围删除元素zremrangescore key min max ：按照分数范围删除元素扩展命令(了解)zrangebyscore key min max [withscore] [limit offset count] ：返回分数在[min,max]的成员并按照分数从低到高排序。[withscore]：显示分数；[limit offset count]；offset，表明从脚标为offset的元素开始并返回count个成员zincrby key increment member ：设置指定成员的增加分数。返回值是修改后的分数zcount key min max：获取分数在[min，max]之间的成员个数zrank key member：返回成员在集合中的排名(从小到大)zrevrank key member ：返回成员在集合中的排名(从大到小) 123456789101112131415161718192021222324key的通用操作 keys pattern : 获取所有与pattern匹配的key ，返回所有与该key匹配的keys。 *表示任意一个或者多个字符， ?表示任意一个字符del key1 key2… ：删除指定的key del my1 my2 my3exists key ：判断该key是否存在，1代表存在，0代表不存在rename key newkey ：为key重命名expire key second：设置过期时间，单位秒ttl key：获取该key所剩的超时时间，如果没有设置超时，返回-1，如果返回-2表示超时不存在。persist key:持久化key 192.168.25.153:6379&gt; expire Hello 100(integer) 1192.168.25.153:6379&gt; ttl Hello(integer) 77type key：获取指定key的类型。该命令将以字符串的格式返回。返回的字符串为string 、list 、set 、hash 和 zset，如果key不存在返回none。例如: type newcompanynone redis的数据类型，以及每种数据类型的使用场景(一)String这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。 (二)hash这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 (三)list使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。 (四)set因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 (五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。另外，参照另一篇《分布式之延时任务方案解析》，该文指出了sorted set可以用来做延时任务。最后一个应用就是可以做范围查找。 redis的过期策略以及内存淘汰机制分析:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?回答:redis采用的是定期删除+惰性删除策略。为什么不用定时删除策略?定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.定期删除+惰性删除是如何工作的呢?定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。采用定期删除+惰性删除就没其他问题了么?不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。在redis.conf中有一行配置 1maxmemory-policy allkeys-lru 该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用。3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。 redis和数据库双写一致性问题分析:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。回答:首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。 如何应对缓存穿透和缓存雪崩问题分析:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。回答:如下所示 缓存穿透：即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。 解决方案:(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。 缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。 解决方案:(一)给缓存的失效时间，加上一个随机值，避免集体失效。(二)使用互斥锁，但是该方案吞吐量明显下降了。(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点 I 从缓存A读数据库，有则直接返回 II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。 III 更新线程同时更新缓存A和缓存B。 如何解决redis的并发竞争key问题分析:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。 回答:如下所示(1)如果对这个key操作，不要求顺序这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。(2)如果对这个key操作，要求顺序假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下 123系统A key 1 &#123;valueA 3:00&#125;系统B key 1 &#123;valueB 3:05&#125;系统C key 1 &#123;valueC 3:10&#125; 那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。 其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。 redis中支持事务吗？【了解即可】支持，使用multi开启事务，使用exec提交事务。 redis发布订阅【了解即可】Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 Redis 客户端可以订阅任意数量的频道。 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： 12345678910111213141516171819202122232425redis 127.0.0.1:6379&gt; SUBSCRIBE redisChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 1现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;What &#39;s your name?&quot;(integer) 1# 订阅者的客户端会显示如下消息1) &quot;message&quot;2) &quot;redisChat&quot;3) &quot;hello&quot;1) &quot;message&quot;2) &quot;redisChat&quot;3) &quot;What &#39;s your name?&quot; 另外我还写了几篇关于redis的文章：1、关于redis的持久化(rdb/aof)与备份 https://blog.csdn.net/itcats_cn/article/details/82432530 2、redis如何实现高可用【主从复制、哨兵机制】 https://blog.csdn.net/itcats_cn/article/details/82428716 部分内容参考 作者：孤独烟 来自：http://rjzheng.cnblogs.com/ https://mp.weixin.qq.com/s/gEU8HtsQNPXY8bzkK-Qllg————————————————版权声明：本文为CSDN博主「itcats_cn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/itcats_cn/java/article/details/82391719","categories":[{"name":"redis","slug":"redis","permalink":"https://conanisbest.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://conanisbest.github.io/tags/redis/"}]},{"title":"jvm之java类加载机制和类加载器(ClassLoader)的详解","slug":"java类加载器","date":"2020-07-08T07:20:09.000Z","updated":"2020-07-14T03:32:06.674Z","comments":true,"path":"2020/07/08/java类加载器/","link":"","permalink":"https://conanisbest.github.io/2020/07/08/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"jvm之java类加载机制和类加载器(ClassLoader)的详解分类专栏： java jvm 当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。 一、类加载过程1.加载 加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。 类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。 通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。通过网络加载class文件。把一个Java源文件动态编译，并执行加载。 类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。 2.链接 当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。 1)验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 四种验证做进一步说明： 文件格式验证：主要验证字节流是否符合Class文件格式规范，并且能被当前的虚拟机加载处理。例如：主，次版本号是否在当前虚拟机处理的范围之内。常量池中是否有不被支持的常量类型。指向常量的中的索引值是否存在不存在的常量或不符合类型的常量。 元数据验证：对字节码描述的信息进行语义的分析，分析是否符合java的语言语法的规范。 字节码验证：最重要的验证环节，分析数据流和控制，确定语义是合法的，符合逻辑的。主要的针对元数据验证后对方法体的验证。保证类方法在运行时不会有危害出现。 符号引用验证：主要是针对符号引用转换为直接引用的时候，是会延伸到第三解析阶段，主要去确定访问类型等涉及到引用的情况，主要是要保证引用一定会被访问到，不会出现类等无法访问的问题。 2)准备：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。 3)解析：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。 3.初始化 初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。 二、类加载时机创建类的实例，也就是new一个对象访问某个类或接口的静态变量，或者对该静态变量赋值调用类的静态方法反射（Class.forName(“com.lyj.load”)）初始化一个类的子类（会首先初始化子类的父类）JVM启动时标明的启动类，即文件名和类名相同的那个类 除此之外，下面几种情形需要特别指出： 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。三、类加载器 类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。 JVM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器： 1)根类加载器（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径： public class ClassLoaderTest { 1234567public static void main(String[] args) &#123; URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for(URL url : urls)&#123; System.out.println(url.toExternalForm()); &#125;&#125; }运行结果： 2)扩展类加载器（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。 3)系统类加载器（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。 类加载器加载Class大致要经过如下8个步骤： 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。从文件中载入Class，成功后跳至第8步。抛出ClassNotFountException异常。返回对应的java.lang.Class对象。四、类加载机制：1.JVM的类加载机制主要有如下3种。 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。2.这里说明一下双亲委派机制： 双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。 双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。————————————————版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/m0_38075425/java/article/details/81627349","categories":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/categories/java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://conanisbest.github.io/tags/jvm/"}]},{"title":"java基础知识","slug":"java基础知识","date":"2020-07-07T06:46:42.000Z","updated":"2020-07-14T03:31:40.230Z","comments":true,"path":"2020/07/07/java基础知识/","link":"","permalink":"https://conanisbest.github.io/2020/07/07/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"本文知识点目录 Java概述 何为编程 什么是Java jdk1.5之后的三大版本 JVM、JRE和JDK的关系 什么是跨平台性？原理是什么 Java语言有哪些特点？ 什么是字节码？采用字节码的最大好处是什么 什么是Java程序的主类？应用程序和小程序的主类有何不同？ Java应用程序与小程序之间有那些差别？ Java和C++的区别 Oracle JDK 和 OpenJDK 的对比 基础语法 数据类型 Java有哪些数据类型 switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上 用最有效率的方法计算 2 乘以 8 Math.round(11.5) 等于多少？Math.round(-11.5)等于多少 float f=3.4;是否正确 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗 编码 Java语言采用何种编码方案？有何特点？ 注释 什么是Java注释 访问修饰符 访问修饰符 public,private,protected,以及不写（默认）时的区别 运算符 &amp;和&amp;&amp;的区别 关键字 Java 有没有 goto final 有什么用？ final finally finalize区别 this关键字的用法 super关键字的用法 this与super的区别 static存在的主要意义 static的独特之处 static应用场景 static注意事项 流程控制语句 break ,continue ,return 的区别及作用 在 Java 中，如何跳出当前的多重嵌套循环 面向对象 面向对象概述 面向对象和面向过程的区别 面向对象三大特性 面向对象的特征有哪些方面 什么是多态机制？Java语言是如何实现多态的？ 面向对象五大基本原则是什么（可选） 类与接口 抽象类和接口的对比 普通类和抽象类有哪些区别？ 抽象类能使用 final 修饰吗？ 创建一个对象用什么关键字？对象实例与对象引用有何不同？ 变量与方法 成员变量与局部变量的区别有哪些 在Java中定义一个不做事且没有参数的构造方法的作用 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？ 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？ 构造方法有哪些特性？ 静态变量和实例变量区别 静态变量与普通变量区别 静态方法和实例方法有何不同？ 在一个静态方法内调用一个非静态成员为什么是非法的？ 什么是方法的返回值？返回值的作用是什么？ 内部类 什么是内部类？ 内部类的分类有哪些 静态内部类 成员内部类 局部内部类 匿名内部类 内部类的优点 内部类有哪些应用场景 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？ 内部类相关，看程序说出运行结果 重写与重载 构造器（constructor）是否可被重写（override） 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 对象相等判断 == 和 equals 的区别是什么 hashCode 与 equals (重要) 对象的相等与指向他们的引用相等，两者有什么不同？ 值传递 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递 为什么 Java 中只有值传递 值传递和引用传递有什么区别 Java包 JDK 中常用的包有哪些 import java和javax有什么区别 IO流 java 中 IO 流分为几种? BIO,NIO,AIO 有什么区别? Files的常用方法都有哪些？ 反射 什么是反射机制？ 反射机制优缺点 反射机制的应用场景有哪些？ Java获取反射的三种方法 网络编程 常用API String相关 字符型常量和字符串常量的区别 什么是字符串常量池？ String 是最基本的数据类型吗 String有哪些特性 String为什么是不可变的吗？ String真的是不可变的吗？ 是否可以继承 String 类 String str=”i”与 String str=new String(“i”)一样吗？ String s = new String(“xyz”);创建了几个字符串对象 如何将字符串反转？ 数组有没有 length()方法？String 有没有 length()方法 String 类的常用方法都有那些？ 在使用 HashMap 的时候，用 String 做 key 有什么好处？ String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的 Date相关 包装类相关 自动装箱与拆箱 int 和 Integer 有什么区别 Integer a= 127 与 Integer b = 127相等吗 Java概述何为编程编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。 为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。 什么是JavaJava是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。 jdk1.5之后的三大版本 Java SE（J2SE，Java 2 Platform Standard Edition，标准版）Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。 Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE Java ME（J2ME，Java 2 Platform Micro Edition，微型版）Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。 JVM、JRE和JDK的关系JVMJava Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。 JREJava Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 JDKJava Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等 JVM&amp;JRE&amp;JDK关系图 什么是跨平台性？原理是什么所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。 实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。 Java语言有哪些特点简单易学（Java语言的语法与C语言和C++语言很接近） 面向对象（封装，继承，多态） 平台无关性（Java虚拟机实现平台无关性） 支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的） 支持多线程（多线程机制使应用程序在同一时间并行执行多项任） 健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等） 安全性 什么是字节码？采用字节码的最大好处是什么字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。 采用字节码的好处： Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。 先看下java中的编译器和解释器： Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。 1Java源代码----&gt;编译器----&gt;jvm可执行的Java字节码(即虚拟指令)----&gt;jvm----&gt;jvm中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。 什么是Java程序的主类？应用程序和小程序的主类有何不同？一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。 Java应用程序与小程序之间有那些差别？简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。 Java和C++的区别我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！ 都是面向对象的语言，都支持封装、继承和多态 Java不提供指针来直接访问内存，程序内存更加安全 Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。 Java有自动内存管理机制，不需要程序员手动释放无用内存 Oracle JDK 和 OpenJDK 的对比 Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次； OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题； 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能； Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。 基础语法数据类型Java有哪些数据类型定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。 分类 基本数据类型 整数类型(byte,short,int,long) 浮点类型(float,double) 数值型 字符型(char) 布尔型(boolean) 引用数据类型 类(class) 接口(interface) 数组([]) Java基本数据类型图 switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 用最有效率的方法计算 2 乘以 82 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。 Math.round(11.5) 等于多少？Math.round(-11.5)等于多少Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。 float f=3.4;是否正确不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。 而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。 编码Java语言采用何种编码方案？有何特点？Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。 注释什么Java注释定义：用于解释说明程序的文字 分类 单行注释格式：// 注释文字 多行注释格式：/* 注释文字 */ 文档注释格式：/** 注释文字 */ 作用 在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。 注意事项：多行和文档注释都不能嵌套使用。 访问修饰符访问修饰符 public,private,protected,以及不写（默认）时的区别定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 分类 private : 在同一类内可见。使用对象：变量、方法。注意：不能修饰类（外部类）default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。注意：不能修饰类（外部类）。public : 对所有类可见。使用对象：类、接口、变量、方法 访问修饰符图 运算符&amp;和&amp;&amp;的区别&amp;运算符有两种用法：(1)按位与；(2)逻辑与。 &amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。 注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 关键字Java 有没有 gotogoto 是 Java 中的保留字，在目前版本的 Java 中没有使用。 final 有什么用？用于修饰类、属性和方法； 被final修饰的类不可以被继承 被final修饰的方法不可以被重写 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的 final finally finalize区别 final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。 finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。 this关键字的用法this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this的用法在java中大体可以分为3种： 1.普通的直接引用，this相当于是指向当前对象本身。 2.形参与成员名字重名，用this来区分： 1234public Person(String name, int age) &#123; this.name = name; this.age = age;&#125; 3.引用本类的构造函数 123456789101112131415class Person&#123; private String name; private int age; public Person() &#123; &#125; public Person(String name) &#123; this.name = name; &#125; public Person(String name, int age) &#123; this(name); this.age = age; &#125;&#125; super关键字的用法super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super也有三种用法： 1.普通的直接引用 与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。 2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分 123456789101112131415161718192021222324252627282930class Person&#123; protected String name; public Person(String name) &#123; this.name = name; &#125; &#125; class Student extends Person&#123; private String name; public Student(String name, String name1) &#123; super(name); this.name = name1; &#125; public void getInfo()&#123; System.out.println(this.name); //Child System.out.println(super.name); //Father &#125; &#125;public class Test &#123; public static void main(String[] args) &#123; Student s1 = new Student(\"Father\",\"Child\"); s1.getInfo(); &#125;&#125; 3.引用父类构造函数 3、引用父类构造函数 super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 this与super的区别 super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。 static存在的主要意义static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！ static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 static的独特之处1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。 怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？ 2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。 3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！ 4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。 static应用场景因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。 因此比较常见的static应用场景有： 1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包 static注意事项1、静态只能访问静态。2、非静态既可以访问非静态的，也可以访问静态的。 流程控制语句break ,continue ,return 的区别及作用break 跳出总上一层循环，不再执行循环(结束当前的循环体) continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件) return 程序返回，不再执行下面的代码(结束当前的方法 直接返回) 在 Java 中，如何跳出当前的多重嵌套循环在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如： 123456789101112public static void main(String[] args) &#123; ok: for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.println(\"i=\" + i + \",j=\" + j); if (j == 5) &#123; break ok; &#125; &#125; &#125;&#125; 面向过程： 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点：没有面向对象易维护、易复用、易扩展 面向对象优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点：性能比面向过程低 面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。 面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。 面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。 面向对象的特征主要有以下几个方面： 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 关于继承如下 3 点请记住： 子类拥有父类非 private 的属性和方法。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 多态 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。 在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。 方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。 一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事： 方法重写（子类继承父类并重写父类中已有的或抽象的方法）； 对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 什么是多态机制？Java语言是如何实现多态的？所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。 多态的实现 Java实现多态有三个必要条件：继承、重写、向上转型。 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。 对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 面向对象五大基本原则是什么（可选） 单一职责原则SRP(Single Responsibility Principle)类的功能要单一，不能包罗万象，跟杂货铺似的。 开放封闭原则OCP(Open－Close Principle)一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。 里式替换原则LSP(the Liskov Substitution Principle LSP)子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~ 依赖倒置原则DIP(the Dependency Inversion Principle DIP)高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。 接口分离原则ISP(the Interface Segregation Principle ISP)设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。 类与接口抽象类和接口的对比抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。 从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 相同点 接口和抽象类都不能实例化 都位于继承的顶端，用于被其他实现或继承 都包含抽象方法，其子类都必须覆写这些抽象方法 不同点 参数 抽象类 接口 声明 抽象类使用abstract关键字声明 接口使用interface关键字声明 实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 访问修饰符 抽象类中的方法可以是任意访问修饰符 接口方法默认修饰符是public。并且不允许定义为 private 或者 protected 多继承 一个类最多只能继承一个抽象类 一个类可以实现多个接口 字段声明 抽象类的字段声明可以是任意的 接口的字段默认都是 static 和 final 的 备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。 现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。 接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则： 行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。 选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。 普通类和抽象类有哪些区别？ 普通类不能包含抽象方法，抽象类可以包含抽象方法。 抽象类不能直接实例化，普通类可以直接实例化。 抽象类能使用 final 修饰吗？不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类 创建一个对象用什么关键字？对象实例与对象引用有何不同？new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球） 变量与方法成员变量与局部变量的区别有哪些变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域 成员变量：方法外部，类内部定义的变量 局部变量：类的方法中的变量。 成员变量和局部变量的区别 作用域 成员变量：针对整个类有效。局部变量：只在某个范围内有效。(一般指的就是方法,语句体内) 存储位置 成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。 生命周期 成员变量：随着对象的创建而存在，随着对象的消失而消失局部变量：当方法调用完，或者语句结束后，就自动释放。 初始值 成员变量：有默认初始值。 局部变量：没有默认初始值，使用前必须赋值。 使用原则 在使用变量时需要遵循的原则为：就近原则首先在局部范围找，有就使用；接着在成员位置找。 在Java中定义一个不做事且没有参数的构造方法的作用Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？帮助子类做初始化工作。 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。 构造方法有哪些特性？名字与类名相同； 没有返回值，但不能用void声明构造函数； 生成类的对象时自动执行，无需调用。 静态变量和实例变量区别静态变量：静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。 实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。 静态变量与普通变量区别static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。 静态方法和实例方法有何不同？静态方法和实例方法的区别主要体现在两个方面： 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 在一个静态方法内调用一个非静态成员为什么是非法的？由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。 什么是方法的返回值？返回值的作用是什么？方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！ 内部类什么是内部类？在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。 内部类的分类有哪些内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。 静态内部类定义在类内部的静态类，就是静态内部类。 12345678910public class Outer &#123; private static int radius = 1; static class StaticInner &#123; public void visit() &#123; System.out.println(\"visit outer static variable:\" + radius); &#125; &#125;&#125; 静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下： 12Outer.StaticInner inner = new Outer.StaticInner();inner.visit(); 成员内部类定义在类内部，成员位置上的非静态类，就是成员内部类。 123456789101112public class Outer &#123; private static int radius = 1; private int count =2; class Inner &#123; public void visit() &#123; System.out.println(\"visit outer static variable:\" + radius); System.out.println(\"visit outer variable:\" + count); &#125; &#125;&#125; 成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下： 123Outer outer = new Outer();Outer.Inner inner = outer.new Inner();inner.visit(); 局部内部类定义在方法中的内部类，就是局部内部类。 123456789101112131415161718192021222324252627282930public class Outer &#123; private int out_a = 1; private static int STATIC_b = 2; public void testFunctionClass()&#123; int inner_c =3; class Inner &#123; private void fun()&#123; System.out.println(out_a); System.out.println(STATIC_b); System.out.println(inner_c); &#125; &#125; Inner inner = new Inner(); inner.fun(); &#125; public static void testStaticFunctionClass()&#123; int d =3; class Inner &#123; private void fun()&#123; // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量 System.out.println(STATIC_b); System.out.println(d); &#125; &#125; Inner inner = new Inner(); inner.fun(); &#125;&#125; 定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下： 12345public static void testStaticFunctionClass()&#123; class Inner &#123; &#125; Inner inner = new Inner();&#125; 匿名内部类匿名内部类就是没有名字的内部类，日常开发中使用的比较多。 12345678910111213141516public class Outer &#123; private void test(final int i) &#123; new Service() &#123; public void method() &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.println(\"匿名内部类\" ); &#125; &#125; &#125;.method(); &#125; &#125; //匿名内部类必须继承或实现一个已有的接口 interface Service&#123; void method();&#125; 除了没有名字，匿名内部类还有以下特点： 匿名内部类必须继承一个抽象类或者实现一个接口。 匿名内部类不能定义任何静态成员和静态方法。 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 匿名内部类创建方式： 123new 类/接口&#123; //匿名内部类实现部分&#125; 内部类的优点我们为什么要使用内部类呢？因为它有以下优点： 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！ 内部类不为同一包的其他类所见，具有很好的封装性； 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。 匿名内部类可以很方便的定义回调。 内部类有哪些应用场景 一些多算法场合 解决一些非面向对象的语句块。 适当使用内部类，使得代码更加灵活和富有扩展性。 当某个类除了它的外部类，不再被其他的类使用时。 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？ 先看这段代码： 123456789101112public class Outer &#123; void outMethod()&#123; final int a =10; class Inner &#123; void innerMethod()&#123; System.out.println(a); &#125; &#125; &#125;&#125; 以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。 内部类相关，看程序说出运行结果12345678910111213141516171819public class Outer &#123; private int age = 12; class Inner &#123; private int age = 13; public void print() &#123; int age = 14; System.out.println(\"局部变量：\" + age); System.out.println(\"内部类变量：\" + this.age); System.out.println(\"外部类变量：\" + Outer.this.age); &#125; &#125; public static void main(String[] args) &#123; Outer.Inner in = new Outer().new Inner(); in.print(); &#125;&#125; 运行结果： 123局部变量：14内部类变量：13外部类变量：12 重写与重载构造器（constructor）是否可被重写（override）构造器不能被继承，因此不能被重写，但可以被重载。 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。 重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。 对象相等判断== 和 equals 的区别是什么== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址) equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 *举个例子：* 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String(\"ab\"); // a 为一个引用 String b = new String(\"ab\"); // b为另一个引用,对象的内容一样 String aa = \"ab\"; // 放在常量池中 String bb = \"ab\"; // 从常量池中查找 if (aa == bb) // true System.out.println(\"aa==bb\"); if (a == b) // false，非同一对象 System.out.println(\"a==b\"); if (a.equals(b)) // true System.out.println(\"aEQb\"); if (42 == 42.0) &#123; // true System.out.println(\"true\"); &#125; &#125;&#125; 说明： String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。 hashCode 与 equals (重要)HashSet如何检查重复 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？ hashCode和equals方法的关系 面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？” hashCode()介绍 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode 我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 hashCode()与equals()的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 对象的相等与指向他们的引用相等，两者有什么不同？对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。 值传递当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的 为什么 Java 中只有值传递首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。 Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 下面通过 3 个例子来给大家说明 example 1 123456789101112131415161718public static void main(String[] args) &#123; int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\"num1 = \" + num1); System.out.println(\"num2 = \" + num2);&#125;public static void swap(int a, int b) &#123; int temp = a; a = b; b = temp; System.out.println(\"a = \" + a); System.out.println(\"b = \" + b);&#125; 结果： 1234a &#x3D; 20b &#x3D; 10num1 &#x3D; 10num2 &#x3D; 20 在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2. example 2 1234567891011public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; System.out.println(arr[0]); change(arr); System.out.println(arr[0]); &#125; public static void change(int[] array) &#123; // 将数组的第一个元素变为0 array[0] = 0; &#125; 结果： 1210 解析： array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。因此，外部对引用对象的改变会反映到所对应的对象上。 通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。 很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。 example 3 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Student s1 = new Student(\"小张\"); Student s2 = new Student(\"小李\"); Test.swap(s1, s2); System.out.println(\"s1:\" + s1.getName()); System.out.println(\"s2:\" + s2.getName()); &#125; public static void swap(Student x, Student y) &#123; Student temp = x; x = y; y = temp; System.out.println(\"x:\" + x.getName()); System.out.println(\"y:\" + y.getName()); &#125;&#125; 结果： 1234x:小李y:小张s1:小张s2:小李 解析： 交换之前： 通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝 总结Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。 下面再总结一下Java中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 值传递和引用传递有什么区别值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。 Java包JDK 中常用的包有哪些 java.lang：这个是系统的基础类； java.io：这里面是所有输入输出有关的类，比如文件操作等； java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包； java.net：这里面是与网络有关的类； java.util：这个是系统辅助类，特别是集合类； java.sql：这个是数据库操作的类。 import java和javax有什么区别刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。 所以，实际上java和javax没有区别。这都是一个名字。 IO流java 中 IO 流分为几种? 按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 按操作方式分类结构图： 按操作对象分类结构图： BIO,NIO,AIO 有什么区别?简答 BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 详细回答 BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发 AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。 Files的常用方法都有哪些？ Files. exists()：检测文件路径是否存在。 Files. createFile()：创建文件。 Files. createDirectory()：创建文件夹。 Files. delete()：删除一个文件或目录。 Files. copy()：复制文件。 Files. move()：移动文件。 Files. size()：查看文件个数。 Files. read()：读取文件。 Files. write()：写入文件。 反射什么是反射机制？JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 静态编译和动态编译 静态编译：在编译时确定类型，绑定对象 动态编译：运行时确定类型，绑定对象 反射机制优缺点 优点： 运行期类型的判断，动态加载类，提高代码灵活度。 缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。 反射机制的应用场景有哪些？反射是框架设计的灵魂。 在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。 举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性 Java获取反射的三种方法1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制 123456789101112131415161718192021public class Student &#123; private int id; String name; protected boolean sex; public float score;&#125;public class Get &#123; //获取反射机制三种方式 public static void main(String[] args) throws ClassNotFoundException &#123; //方式一(通过建立对象) Student stu = new Student(); Class classobj1 = stu.getClass(); System.out.println(classobj1.getName()); //方式二（所在通过路径-相对路径） Class classobj2 = Class.forName(\"fanshe.Student\"); System.out.println(classobj2.getName()); //方式三（通过类名） Class classobj3 = Student.class; System.out.println(classobj3.getName()); &#125;&#125; 网络编程网络编程的面试题可以查看我的这篇文章重学TCP/IP协议和三次握手四次挥手，内容不仅包括TCP/IP协议和三次握手四次挥手的知识，还包括计算机网络体系结构，HTTP协议，get请求和post请求区别，session和cookie的区别等，欢迎大家阅读。 常用APIString相关字符型常量和字符串常量的区别 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符 含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志) 什么是字符串常量池？字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。 String 是最基本的数据类型吗不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。 这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’}; 但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。 String有哪些特性 不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。 常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。 final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。 String为什么是不可变的吗？简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以： 12/** The value is used for character storage. */private final char value[]; String真的是不可变的吗？ 我觉得如果别人问这个问题的话，回答不可变就可以了。下面只是给大家看两个有代表性的例子： 1) String不可变但不代表引用不可以变 12345String str = \"Hello\";str = str + \" World\";System.out.println(\"str=\" + str);结果：str=Hello World 解析： 实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。 2) 通过反射是可以修改所谓的“不可变”对象 12345678910111213141516171819202122// 创建字符串\"Hello World\"， 并赋给引用sString s = \"Hello World\";System.out.println(\"s = \" + s); // Hello World// 获取String类中的value字段Field valueFieldOfString = String.class.getDeclaredField(\"value\");// 改变value属性的访问权限valueFieldOfString.setAccessible(true);// 获取s对象上的value属性的值char[] value = (char[]) valueFieldOfString.get(s);// 改变value所引用的数组中的第5个字符value[5] = '_';System.out.println(\"s = \" + s); // Hello_World结果：s = Hello Worlds = Hello_World 解析： 用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。 是否可以继承 String 类String 类是 final 类，不可以被继承。 String str=”i”与 String str=new String(“i”)一样吗？不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。 String s = new String(“xyz”);创建了几个字符串对象两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。 123456789101112String str1 = \"hello\"; //str1指向静态区String str2 = new String(\"hello\"); //str2指向堆上的对象String str3 = \"hello\";String str4 = new String(\"hello\");System.out.println(str1.equals(str2)); //trueSystem.out.println(str2.equals(str4)); //trueSystem.out.println(str1 == str3); //trueSystem.out.println(str1 == str2); //falseSystem.out.println(str2 == str4); //falseSystem.out.println(str2 == \"hello\"); //falsestr2 = str1;System.out.println(str2 == \"hello\"); //true 如何将字符串反转？ 使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。 示例代码： 12345678// StringBuffer reverseStringBuffer stringBuffer = new StringBuffer();stringBuffer. append(\"abcdefg\");System. out. println(stringBuffer. reverse()); // gfedcba// StringBuilder reverseStringBuilder stringBuilder = new StringBuilder();stringBuilder. append(\"abcdefg\");System. out. println(stringBuilder. reverse()); // gfedcba 数组有没有 length()方法？String 有没有 length()方法 数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。 String 类的常用方法都有那些？ indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。 在使用 HashMap 的时候，用 String 做 key 有什么好处？HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。 String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的可变性 String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。 线程安全性 String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结 如果要操作少量的数据用 = String 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer Date相关包装类相关自动装箱与拆箱装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； int 和 Integer 有什么区别Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型**：** 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double Integer a= 127 与 Integer b = 127相等吗对于对象引用类型：==比较的是对象的内存地址。对于基本数据类型：==比较的是值。 如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false 12345678910111213141516public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 System.out.println(b == c); // true Integer a1 = 128; Integer b1 = 128; System.out.println(a1 == b1); // false Integer a2 = 127; Integer b2 = 127; System.out.println(a2 == b2); // true&#125;","categories":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"工作流","slug":"工作流","date":"2020-07-03T08:25:36.000Z","updated":"2020-07-03T08:38:09.471Z","comments":true,"path":"2020/07/03/工作流/","link":"","permalink":"https://conanisbest.github.io/2020/07/03/%E5%B7%A5%E4%BD%9C%E6%B5%81/","excerpt":"","text":"博主更新中…","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"解决java导出文件时文件名中文不显示/乱码","slug":"five","date":"2020-07-02T07:39:23.000Z","updated":"2020-07-14T03:30:07.299Z","comments":true,"path":"2020/07/02/five/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/five/","excerpt":"","text":"解决java导出文件时文件名中文不显示/乱码 直接把中文文件名改为iso-8859-1就可以了~ response.setHeader(“Content-Disposition”, “attachment;filename=” + new String(fileName.getBytes(),”iso-8859-1”) + “.xls”);","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}]},{"title":"hibernate工作原理及作用","slug":"four","date":"2020-07-02T07:30:06.000Z","updated":"2020-07-14T03:29:34.885Z","comments":true,"path":"2020/07/02/four/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/four/","excerpt":"","text":"hibernate工作原理及作用 转载自 http://www.cnblogs.com/dashi/p/3597969.html#commentform JAVA Hibernate工作原理及为什么要用 hibernate 简介： hibernate是一个开源框架，它是对象关联关系映射的框架，它对JDBC做了轻量级的封装，而我们java程序员可以使用面向对象的思想来操纵数据库。 hibernate核心接口 session：负责被持久化对象CRUD操作 sessionFactory:负责初始化hibernate，创建session对象 configuration:负责配置并启动hibernate，创建SessionFactory Transaction:负责事物相关的操作 Query和Criteria接口：负责执行各种数据库查询 hibernate工作原理： 1.通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件 2.由hibernate.cfg.xml中的读取并解析映射信息 3.通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory 4.Session session = sf.openSession();//打开Sesssion 5.Transaction tx = session.beginTransaction();//创建并启动事务Transation 6.persistent operate操作数据，持久化操作 7.tx.commit();//提交事务 8.关闭Session 9.关闭SesstionFactory 为什么要用hibernate： \\1. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 \\2. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 \\3. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 \\4. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 Hibernate是如何延迟加载?get与load的区别 \\1. 对于Hibernate get方法，Hibernate会确认一下该id对应的数据是否存在，首先在session缓存中查找，然后在二级缓存中查找，还没有就查询数据库，数据 库中没有就返回null。这个相对比较简单，也没有太大的争议。主要要说明的一点就是在这个版本(bibernate3.2以上)中get方法也会查找二级缓存！ \\2. Hibernate load方法加载实体对象的时候，根据映射文件上类级别的lazy属性的配置(默认为true)，分情况讨论： (1)若为true,则首先在Session缓存中查找，看看该id对应的对象是否存在，不存在则使用延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)。等到具体使用该对象(除获取OID以外)的时候，再查询二级缓存和数据库，若仍没发现符合条件的记录，则会抛出一个ObjectNotFoundException。 (2)若为false,就跟Hibernateget方法查找顺序一样，只是最终若没发现符合条件的记录，则会抛出一个ObjectNotFoundException。 这里get和load有两个重要区别: 如果未能发现符合条件的记录，Hibernate get方法返回null，而load方法会抛出一个ObjectNotFoundException。 load方法可返回没有加载实体数据的代 理类实例，而get方法永远返回有实体数据的对象。 (对于load和get方法返回类型：好多书中都说：“get方法永远只返回实体类”，实际上并不正 确，get方法如果在session缓存中找到了该id对应的对象，如果刚好该对象前面是被代理过的，如被load方法使用过，或者被其他关联对象延迟加 载过，那么返回的还是原先的代理对象，而不是实体类对象，如果该代理对象还没有加载实体数据（就是id以外的其他属性数据），那么它会查询二级缓存或者数 据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据。) 总之对于get和load的根本区别，一句话，hibernate对于 load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get方 法，hibernate一定要获取到真实的数据，否则返回null。 Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系) 类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、 说下Hibernate的缓存机制： Hibernate缓存的作用： Hibernate是一个持久层框架，经常访问物理数据库，为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据 Hibernate缓存分类： Hibernate缓存包括两大类：Hibernate一级缓存和Hibernate二级缓存 Hibernate一级缓存又称为“Session的缓存”，它是内置的，意思就是说，只要你使用hibernate就必须使用session缓存。由于Session对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。在第一级缓存中，持久化类的每个实例都具有唯一的OID。 Hibernate二级缓存又称为“SessionFactory的缓存”，由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。第二级缓存是可选的，是一个可配置的插件，在默认情况下，SessionFactory不会启用这个插件。 什么样的数据适合存放到第二级缓存中？ 1 很少被修改的数据 2 不是很重要的数据，允许出现偶尔并发的数据 3 不会被并发访问的数据 4 常量数据 不适合存放到第二级缓存的数据？ 1经常被修改的数据 2 .绝对不允许出现并发访问的数据，如财务数据，绝对不允许出现并发 3 与其他应用共享的数据。 Hibernate查找对象如何应用缓存？ 当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；如果都查不到，再查询数据库，把结果按照ID放入到缓存 删除、更新、增加数据的时候，同时更新缓存 Hibernate管理缓存实例 无论何时，我们在管理Hibernate缓存（Managing the caches）时，当你给save()、update()或saveOrUpdate()方法传递一个对象时，或使用load()、 get()、list()、iterate() 或scroll()方法获得一个对象时, 该对象都将被加入到Session的内部缓存中。 当随后flush()方法被调用时，对象的状态会和数据库取得同步。 如果你不希望此同步操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用evict() 方法，从一级缓存中去掉这些对象及其集合。 Hibernate的查询方式 Sql、Criteria,object comptosition Hql： 1、 属性查询 2、 参数查询、命名参数查询 3、 关联查询 4、 分页查询 5、 统计函数 如何优化Hibernate？ 1.使用双向一对多关联，不使用单向一对多 2.灵活使用单向一对多关联 3.不用一对一，用多对一取代 4.配置对象缓存，不使用集合缓存 5.一对多集合使用Bag,多对多集合使用Set \\6. 继承类使用显式多态 \\7. 表字段要少，表关联不要怕多，有二级缓存撑腰 hibernate的开发步骤： 开发步骤 1)搭建好环境 ​ 引入hibernate最小的jar包 ​ 准备Hibernate.cfg.xml启动配置文件 2)写实体类(pojo) 3)为实体类写映射文件”User.hbm.xml” ​ 在hibernate.cfg.xml添加映射的实体 4)创建库表 5)写测试类 ​ 获得Configuration ​ 创建SessionFactory ​ 打开Session ​ 开启事务 ​ 使用session操作数据 ​ 提交事务 ​ 关闭资源","categories":[{"name":"数据库相关","slug":"数据库相关","permalink":"https://conanisbest.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"hibernate","slug":"hibernate","permalink":"https://conanisbest.github.io/tags/hibernate/"}]},{"title":"JVM 发生 OOM 的 8 种原因、及解决办法","slug":"three","date":"2020-07-02T07:26:13.000Z","updated":"2020-07-14T03:28:47.809Z","comments":true,"path":"2020/07/02/three/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/three/","excerpt":"","text":"JVM 发生 OOM（out of memory 内存溢出） 的 8 种原因、及解决办法 来源：www.importnew.com/author/tangyouhua 1. Java 堆空间 发生频率：5颗星 造成原因 无法在 Java 堆中分配对象 吞吐量增加 应用程序无意中保存了对象引用，对象无法被 GC 回收 应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长 解决方案 使用 -Xmx 增加堆大小 修复应用程序中的内存泄漏 2. GC 开销超过限制 发生频率：5颗星 造成原因 Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。 解决方案 使用 -Xmx 增加堆大小 使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制 修复应用程序中的内存泄漏 3. 请求的数组大小超过虚拟机限制 发生频率：2颗星 造成原因 应用程序试图分配一个超过堆大小的数组 解决方案 使用 -Xmx 增加堆大小 修复应用程序中分配巨大数组的 bug 4. Perm gen 空间 发生频率：3颗星 造成原因 Perm gen 空间包含： 类的名字、字段、方法 与类相关的对象数组和类型数组 JIT 编译器优化 当 Perm gen 空间用尽时，将抛出异常。 解决方案 使用 -XX: MaxPermSize 增加 Permgen 大小 不重启应用部署应用程序可能会导致此问题。重启 JVM 解决 5. Metaspace 发生频率：3颗星 造成原因 从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常 解决方案 通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小 取消 -XX: maxmetsspacedize 减小 Java 堆大小,为 MetaSpace 提供更多的可用空间 为服务器分配更多的内存 可能是应用程序 bug，修复 bug 6. 无法新建本机线程 发生频率：5颗星 造成原因 内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足 解决方案 为机器分配更多的内存 减少 Java 堆空间 修复应用程序中的线程泄漏。 增加操作系统级别的限制 ulimit -a 用户进程数增大 (-u) 1800 使用 -Xss 减小线程堆栈大小 7. 杀死进程或子进程 发生频率：1颗星 造成原因 内核任务：内存不足结束器，在可用内存极低的情况下会杀死进程 解决方案 将进程迁移到不同的机器上 给机器增加更多内存 与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的。 8. 发生 stack_trace_with_native_method 发生频率：1颗星 造成原因 本机方法（native method）分配失败 打印的堆栈跟踪信息，最顶层的帧是本机方法 解决方案 使用操作系统本地工具进行诊断","categories":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/categories/java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://conanisbest.github.io/tags/JVM/"}]},{"title":"Java多线程学习","slug":"second","date":"2020-07-02T07:18:50.000Z","updated":"2020-07-14T03:28:11.889Z","comments":true,"path":"2020/07/02/second/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/second/","excerpt":"","text":"Java总结篇系列：Java多线程（一） 多线程作为Java中很重要的一个知识点，在此还是有必要总结一下的。 一.线程的生命周期及五种基本状态 关于Java中线程的生命周期，首先看一下下面这张较为经典的图： 上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括： Java线程具有五种基本状态 新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread(); 就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行； 运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种： 1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态； 2.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态； 3.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 二. Java多线程的创建及启动 Java中线程的创建常见有如三种基本形式 1.继承Thread类，重写该类的run()方法。 1234567891011 1 class MyThread extends Thread &#123; 2 3 private int i = 0; 4 5 @Override 6 public void run() &#123; 7 for (i = 0; i &lt; 100; i++) &#123; 8 System.out.println(Thread.currentThread().getName() + \" \" + i); 9 &#125;10 &#125;11 &#125; 123456789101112131415 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 for (int i = 0; i &lt; 100; i++) &#123; 5 System.out.println(Thread.currentThread().getName() + \" \" + i); 6 if (i == 30) &#123; 7 Th; // 调用start()方法使得线程进入就绪状态11 &#125;12 &#125;13 &#125;14 &#125;read myThread1 = new MyThread(); // 创建一个新的线程 myThread1 此线程进入新建状态 8 Thread myThread2 = new MyThread(); // 创建一个新的线程 myThread2 此线程进入新建状态 9 myThread1.start(); // 调用start()方法使得线程进入就绪状态10 myThread2.start() 如上所示，继承Thread类，通过重写run()方法定义了一个新的线程类MyThread，其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。 2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。 12345678910 1 class MyRunnable implements Runnable &#123; 2 private int i = 0; 3 4 @Override 5 public void run() &#123; 6 for (i = 0; i &lt; 100; i++) &#123; 7 System.out.println(Thread.currentThread().getName() + \" \" + i); 8 &#125; 9 &#125;10 &#125; 1234567891011121314151 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 for (int i = 0; i &lt; 100; i++) &#123; 5 System.out.println(Thread.currentThread().getName() + \" \" + i); 6 if (i == 30) &#123; 7 Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象 8 Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程 9 Thread thread2 = new Thread(myRunnable);10 thread1.start(); // 调用start()方法使得线程进入就绪状态11 thread2.start();12 &#125;13 &#125;14 &#125;15 &#125; 相信以上两种创建新线程的方式大家都很熟悉了，那么Thread和Runnable之间到底是什么关系呢？我们首先来看一下下面这个例子。 123456789101112131415161718192021222324252627282930313233343536373839404142 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 for (int i = 0; i &lt; 100; i++) &#123; 5 System.out.println(Thread.currentThread().getName() + \" \" + i); 6 if (i == 30) &#123; 7 Runnable myRunnable = new MyRunnable(); 8 Thread thread = new MyThread(myRunnable); 9 thread.start();10 &#125;11 &#125;12 &#125;13 &#125;14 15 class MyRunnable implements Runnable &#123;16 private int i = 0;17 18 @Override19 public void run() &#123;20 System.out.println(\"in MyRunnable run\");21 for (i = 0; i &lt; 100; i++) &#123;22 System.out.println(Thread.currentThread().getName() + \" \" + i);23 &#125;24 &#125;25 &#125;26 27 class MyThread extends Thread &#123;28 29 private int i = 0;30 31 public MyThread(Runnable runnable)&#123;32 super(runnable);33 &#125;34 35 @Override36 public void run() &#123;37 System.out.println(\"in MyThread run\");38 for (i = 0; i &lt; 100; i++) &#123;39 System.out.println(Thread.currentThread().getName() + \" \" + i);40 &#125;41 &#125;42 &#125; 同样的，与实现Runnable接口创建线程方式相似，不同的地方在于 11 Thread thread = new MyThread(myRunnable); 那么这种方式可以顺利创建出一个新的线程么？答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的run()方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而run()方法最先是在Runnable接口中定义的方法。 123451 public interface Runnable &#123;2 3 public abstract void run();4 5 &#125; 我们看一下Thread类中对Runnable接口中run()方法的实现： 123456 @Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 也就是说，当执行到Thread类中的run()方法时，会首先判断target是否存在，存在则执行target中的run()方法，也就是实现了Runnable接口并重写了run()方法的类中的run()方法。但是上述给到的列子中，由于多态的存在，根本就没有执行到Thread类中的run()方法，而是直接先执行了运行时类型即MyThread类中的run()方法。 3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。 看着好像有点复杂，直接来看一个例子就清晰了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 Callable&lt;Integer&gt; myCallable = new MyCallable(); // 创建MyCallable对象 6 FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(myCallable); //使用FutureTask来包装MyCallable对象 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 Thread thread = new Thread(ft); //FutureTask对象作为Thread对象的target创建新的线程12 thread.start(); //线程进入到就绪状态13 &#125;14 &#125;15 16 System.out.println(\"主线程for循环执行完毕..\");17 18 try &#123;19 int sum = ft.get(); //取得新创建的新线程中的call()方法返回的结果20 System.out.println(\"sum = \" + sum);21 &#125; catch (InterruptedException e) &#123;22 e.printStackTrace();23 &#125; catch (ExecutionException e) &#123;24 e.printStackTrace();25 &#125;26 27 &#125;28 &#125;29 30 31 class MyCallable implements Callable&lt;Integer&gt; &#123;32 private int i = 0;33 34 // 与run()方法不同的是，call()方法具有返回值35 @Override36 public Integer call() &#123;37 int sum = 0;38 for (; i &lt; 100; i++) &#123;39 System.out.println(Thread.currentThread().getName() + \" \" + i);40 sum += i;41 &#125;42 return sum;43 &#125;44 45 &#125; 首先，我们发现，在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyCallable对象，同时作为了Thread对象的target。那么看下FutureTask类的定义： 123451 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;2 3 //....4 5 &#125; 123451 public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;2 3 void run();4 5 &#125; 于是，我们发现FutureTask类实际上是同时实现了Runnable和Future接口，由此才使得其具有Future和Runnable双重特性。通过Runnable特性，可以作为Thread对象的target，而Future特性，使得其可以取得新创建线程中的call()方法的返回值。 执行下此程序，我们发现sum = 4950永远都是最后输出的。而“主线程for循环执行完毕..”则很可能是在子线程循环中间输出。由CPU的线程调度机制，我们知道，“主线程for循环执行完毕..”的输出时机是没有任何问题的，那么为什么sum =4950会永远最后输出呢？ 原因在于通过ft.get()方法获取子线程call()方法的返回值时，当子线程此方法还未执行完毕，ft.get()方法会一直阻塞，直到call()方法执行完毕才能取到返回值。 上述主要讲解了三种常见的线程创建方式，对于线程的启动而言，都是调用线程对象的start()方法，需要特别注意的是：不能对同一线程对象两次调用start()方法。 三. Java多线程的就绪、运行和死亡状态 就绪状态转换为运行状态：当此线程得到处理器资源； 运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。 运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。 此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。 由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。如： 1234567891011121314151617181920212223242526272829303132333435 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 MyRunnable myRunnable = new MyRunnable(); 6 Thread thread = new Thread(myRunnable); 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 thread.start();12 &#125;13 if(i == 40)&#123;14 myRunnable.stopThread();15 &#125;16 &#125;17 &#125;18 &#125;19 20 class MyRunnable implements Runnable &#123;21 22 private boolean stop;23 24 @Override25 public void run() &#123;26 for (int i = 0; i &lt; 100 &amp;&amp; !stop; i++) &#123;27 System.out.println(Thread.currentThread().getName() + \" \" + i);28 &#125;29 &#125;30 31 public void stopThread() &#123;32 this.stop = true;33 &#125;34 35 &#125; Java总结篇系列：Java多线程（二） 本文承接上一篇文章《Java总结篇系列：Java多线程（一）》。 四.Java多线程的阻塞状态与线程控制 上文已经提到Java阻塞的几种具体类型。下面分别看下引起Java线程阻塞的主要方法。 1.join() join —— 让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，知道B线程执行完为止，A才能得以继续执行。 123456789101112131415161718192021222324252627282930 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 MyRunnable myRunnable = new MyRunnable(); 6 Thread thread = new Thread(myRunnable); 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 thread.start();12 try &#123;13 thread.join(); // main线程需要等待thread线程执行完后才能继续执行14 &#125; catch (InterruptedException e) &#123;15 e.printStackTrace();16 &#125;17 &#125;18 &#125;19 &#125;20 &#125;21 22 class MyRunnable implements Runnable &#123;23 24 @Override25 public void run() &#123;26 for (int i = 0; i &lt; 100; i++) &#123;27 System.out.println(Thread.currentThread().getName() + \" \" + i);28 &#125;29 &#125;30 &#125; 2.sleep() sleep —— 让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。在其睡眠的时间段内，该线程由于不是处于就绪状态，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，出于sleep()中的线程也不会执行。因此sleep()方法常用来暂停线程执行。 前面有讲到，当调用了新建的线程的start()方法后，线程进入到就绪状态，可能会在接下来的某个时间获取CPU时间片得以执行，如果希望这个新线程必然性的立即执行，直接调用原来线程的sleep(1)即可。 123456789101112131415161718192021222324252627282930 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 MyRunnable myRunnable = new MyRunnable(); 6 Thread thread = new Thread(myRunnable); 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 thread.start();12 try &#123;13 Thread.sleep(1); // 使得thread必然能够马上得以执行14 &#125; catch (InterruptedException e) &#123;15 e.printStackTrace();16 &#125;17 &#125;18 &#125;19 &#125;20 &#125;21 22 class MyRunnable implements Runnable &#123;23 24 @Override25 public void run() &#123;26 for (int i = 0; i &lt; 100; i++) &#123;27 System.out.println(Thread.currentThread().getName() + \" \" + i);28 &#125;29 &#125;30 &#125; 注：睡一个毫秒级够了，因为CPU不会空闲，会切换到新建的线程。 3.后台线程（Daemon Thread） 概念/目的：后台线程主要是为其他线程（相对可以称之为前台线程）提供服务，或“守护线程”。如JVM中的垃圾回收线程。 生命周期：后台线程的生命周期与前台线程生命周期有一定关联。主要体现在：当所有的前台线程都进入死亡状态时，后台线程会自动死亡(其实这个也很好理解，因为后台线程存在的目的在于为前台线程服务的，既然所有的前台线程都死亡了，那它自己还留着有什么用…伟大啊 ! !)。 设置后台线程：调用Thread对象的setDaemon(true)方法可以将指定的线程设置为后台线程。 1234567891011121314151617181920212223242526272829 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Thread myThread = new MyThread(); 5 for (int i = 0; i &lt; 100; i++) &#123; 6 System.out.println(\"main thread i = \" + i); 7 if (i == 20) &#123; 8 myThread.setDaemon(true); 9 myThread.start();10 &#125;11 &#125;12 &#125;13 14 &#125;15 16 class MyThread extends Thread &#123;17 18 public void run() &#123;19 for (int i = 0; i &lt; 100; i++) &#123;20 System.out.println(\"i = \" + i);21 try &#123;22 Thread.sleep(1);23 &#125; catch (InterruptedException e) &#123;24 // TODO Auto-generated catch block25 e.printStackTrace();26 &#125;27 &#125;28 &#125;29 &#125; 判断线程是否是后台线程：调用thread对象的isDeamon()方法。 注：main线程默认是前台线程，前台线程创建中创建的子线程默认是前台线程，后台线程中创建的线程默认是后台线程。调用setDeamon(true)方法将前台线程设置为后台线程时，需要在start()方法调用之前。前天线程都死亡后，JVM通知后台线程死亡，但从接收指令到作出响应，需要一定的时间。 4.改变线程的优先级/setPriority()： 每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。 设置线程优先级：setPriority(int priorityLevel)。参数priorityLevel范围在1-10之间，常用的有如下三个静态常量值： MAX_PRIORITY:10 MIN_PRIORITY:1 NORM_PRIORITY:5 获取线程优先级：getPriority()。 注：具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。 1234567891011121314151617181920212223 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Thread myThread = new MyThread(); 5 for (int i = 0; i &lt; 100; i++) &#123; 6 System.out.println(\"main thread i = \" + i); 7 if (i == 20) &#123; 8 myThread.setPriority(Thread.MAX_PRIORITY); 9 myThread.start();10 &#125;11 &#125;12 &#125;13 14 &#125;15 16 class MyThread extends Thread &#123;17 18 public void run() &#123;19 for (int i = 0; i &lt; 100; i++) &#123;20 System.out.println(\"i = \" + i);21 &#125;22 &#125;23 &#125; 5.线程让步：yield() 上一篇博文中已经讲到了yield()的基本作用，同时，yield()方法还与线程优先级有关，当某个线程调用yiled()方法从运行状态转换到就绪状态后，CPU从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。 123456789101112131415161718192021222324252627282930313233343536 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Thread myThread1 = new MyThread1(); 5 Thread myThread2 = new MyThread2(); 6 myThread1.setPriority(Thread.MAX_PRIORITY); 7 myThread2.setPriority(Thread.MIN_PRIORITY); 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(\"main thread i = \" + i);10 if (i == 20) &#123;11 myThread1.start();12 myThread2.start();13 Thread.yield();14 &#125;15 &#125;16 &#125;17 18 &#125;19 20 class MyThread1 extends Thread &#123;21 22 public void run() &#123;23 for (int i = 0; i &lt; 100; i++) &#123;24 System.out.println(\"myThread 1 -- i = \" + i);25 &#125;26 &#125;27 &#125;28 29 class MyThread2 extends Thread &#123;30 31 public void run() &#123;32 for (int i = 0; i &lt; 100; i++) &#123;33 System.out.println(\"myThread 2 -- i = \" + i);34 &#125;35 &#125;36 &#125; Java总结篇系列：Java多线程（三） 本文主要接着前面多线程的两篇文章总结Java多线程中的线程安全问题。 一.一个典型的Java线程安全例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Account account = new Account(\"123456\", 1000); 5 DrawMoneyRunnable drawMoneyRunnable = new DrawMoneyRunnable(account, 700); 6 Thread myThread1 = new Thread(drawMoneyRunnable); 7 Thread myThread2 = new Thread(drawMoneyRunnable); 8 myThread1.start(); 9 myThread2.start();10 &#125;11 12 &#125;13 14 class DrawMoneyRunnable implements Runnable &#123;15 16 private Account account;17 private double drawAmount;18 19 public DrawMoneyRunnable(Account account, double drawAmount) &#123;20 super();21 this.account = account;22 this.drawAmount = drawAmount;23 &#125;24 25 public void run() &#123;26 if (account.getBalance() &gt;= drawAmount) &#123; //127 System.out.println(\"取钱成功， 取出钱数为：\" + drawAmount);28 double balance = account.getBalance() - drawAmount;29 account.setBalance(balance);30 System.out.println(\"余额为：\" + balance);31 &#125;32 &#125;33 &#125;34 35 class Account &#123;36 37 private String accountNo;38 private double balance;39 40 public Account() &#123;41 42 &#125;43 44 public Account(String accountNo, double balance) &#123;45 this.accountNo = accountNo;46 this.balance = balance;47 &#125;48 49 public String getAccountNo() &#123;50 return accountNo;51 &#125;52 53 public void setAccountNo(String accountNo) &#123;54 this.accountNo = accountNo;55 &#125;56 57 public double getBalance() &#123;58 return balance;59 &#125;60 61 public void setBalance(double balance) &#123;62 this.balance = balance;63 &#125;64 65 &#125; 上面例子很容易理解，有一张银行卡，里面有1000的余额，程序模拟你和你老婆同时在取款机进行取钱操作的场景。多次运行此程序，可能具有多个不同组合的输出结果。其中一种可能的输出为： 1 取钱成功， 取出钱数为：700.0 2 余额为：300.0 3 取钱成功， 取出钱数为：700.0 4 余额为：-400.0 也就是说，对于一张只有1000余额的银行卡，你们一共可以取出1400，这显然是有问题的。 经过分析，问题在于Java多线程环境下的执行的不确定性。CPU可能随机的在多个处于就绪状态中的线程中进行切换，因此，很有可能出现如下情况：当thread1执行到//1处代码时，判断条件为true，此时CPU切换到thread2，执行//1处代码，发现依然为真，然后执行完thread2，接着切换到thread1，接着执行完毕。此时，就会出现上述结果。 因此，讲到线程安全问题，其实是指多线程环境下对共享资源的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问。 二.同步方法 对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。可以简单理解成对此方法进行了加锁，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推… 在上例中，共享资源为account对象，当使用同步方法时，可以解决线程安全问题。只需在run()方法前加上synshronized关键字即可。 123451 public synchronized void run() &#123;2 3 // ....4 5 &#125; 三.同步代码块 正如上面所分析的那样，解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。 同步代码块的格式为： 123451 synchronized (obj) &#123;2 3 //...4 5 &#125; 其中，obj为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是选择此共享资源对象作为锁对象。 如上例中，最好选用account对象作为锁对象。（当然，选用this也是可以的，那是因为创建线程使用了runnable方式，如果是直接继承Thread方式创建的线程，使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心…） 四.Lock对象同步锁 上面我们可以看出，正因为对同步锁对象的选择需要如此小心，有没有什么简单点的解决方案呢？以方便同步锁对象与共享资源解耦，同时又能很好的解决线程安全问题。 使用Lock对象同步锁可以方便的解决此问题，唯一需要注意的一点是Lock对象需要与资源对象同样具有一对一的关系。Lock对象同步锁一般格式为： 12345678910111213141516 1 class X &#123; 2 3 // 显示定义Lock同步锁对象，此对象与共享资源具有一对一关系 4 private final Lock lock = new ReentrantLock(); 5 6 public void m()&#123; 7 // 加锁 8 lock.lock(); 9 10 //... 需要进行线程安全同步的代码11 12 // 释放Lock锁13 lock.unlock();14 &#125;15 16 &#125; 五.wait()/notify()/notifyAll()线程通信 在博文《Java总结篇系列：java.lang.Object》中有提及到这三个方法，虽然这三个方法主要都是用于多线程中，但实际上都是Object类中的本地方法。因此，理论上，任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，只有同步锁对象调这三个方法，才能完成对多线程间的线程通信。 wait()：导致当前线程等待并使其进入到等待阻塞状态。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。 notify()：唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。 notifyAll()：唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150 1 package com.qqyumidi; 2 3 public class ThreadTest &#123; 4 5 public static void main(String[] args) &#123; 6 Account account = new Account(\"123456\", 0); 7 8 Thread drawMoneyThread = new DrawMoneyThread(\"取钱线程\", account, 700); 9 Thread depositeMoneyThread = new DepositeMoneyThread(\"存钱线程\", account, 700); 10 11 drawMoneyThread.start(); 12 depositeMoneyThread.start(); 13 &#125; 14 15 &#125; 16 17 class DrawMoneyThread extends Thread &#123; 18 19 private Account account; 20 private double amount; 21 22 public DrawMoneyThread(String threadName, Account account, double amount) &#123; 23 super(threadName); 24 this.account = account; 25 this.amount = amount; 26 &#125; 27 28 public void run() &#123; 29 for (int i = 0; i &lt; 100; i++) &#123; 30 account.draw(amount, i); 31 &#125; 32 &#125; 33 &#125; 34 35 class DepositeMoneyThread extends Thread &#123; 36 37 private Account account; 38 private double amount; 39 40 public DepositeMoneyThread(String threadName, Account account, double amount) &#123; 41 super(threadName); 42 this.account = account; 43 this.amount = amount; 44 &#125; 45 46 public void run() &#123; 47 for (int i = 0; i &lt; 100; i++) &#123; 48 account.deposite(amount, i); 49 &#125; 50 &#125; 51 &#125; 52 53 class Account &#123; 54 55 private String accountNo; 56 private double balance; 57 // 标识账户中是否已有存款 58 private boolean flag = false; 59 60 public Account() &#123; 61 62 &#125; 63 64 public Account(String accountNo, double balance) &#123; 65 this.accountNo = accountNo; 66 this.balance = balance; 67 &#125; 68 69 public String getAccountNo() &#123; 70 return accountNo; 71 &#125; 72 73 public void setAccountNo(String accountNo) &#123; 74 this.accountNo = accountNo; 75 &#125; 76 77 public double getBalance() &#123; 78 return balance; 79 &#125; 80 81 public void setBalance(double balance) &#123; 82 this.balance = balance; 83 &#125; 84 85 /** 86 * 存钱 87 * 88 * @param depositeAmount 89 */ 90 public synchronized void deposite(double depositeAmount, int i) &#123; 91 92 if (flag) &#123; 93 // 账户中已有人存钱进去，此时当前线程需要等待阻塞 94 try &#123; 95 System.out.println(Thread.currentThread().getName() + \" 开始要执行wait操作\" + \" -- i=\" + i); 96 wait(); 97 // 1 98 System.out.println(Thread.currentThread().getName() + \" 执行了wait操作\" + \" -- i=\" + i); 99 &#125; catch (InterruptedException e) &#123;100 e.printStackTrace();101 &#125;102 &#125; else &#123;103 // 开始存钱104 System.out.println(Thread.currentThread().getName() + \" 存款:\" + depositeAmount + \" -- i=\" + i);105 setBalance(balance + depositeAmount);106 flag = true;107 108 // 唤醒其他线程109 notifyAll();110 111 // 2112 try &#123;113 Thread.sleep(3000);114 &#125; catch (InterruptedException e) &#123;115 e.printStackTrace();116 &#125;117 System.out.println(Thread.currentThread().getName() + \"-- 存钱 -- 执行完毕\" + \" -- i=\" + i);118 &#125;119 &#125;120 121 /**122 * 取钱123 * 124 * @param drawAmount125 */126 public synchronized void draw(double drawAmount, int i) &#123;127 if (!flag) &#123;128 // 账户中还没人存钱进去，此时当前线程需要等待阻塞129 try &#123;130 System.out.println(Thread.currentThread().getName() + \" 开始要执行wait操作\" + \" 执行了wait操作\" + \" -- i=\" + i);131 wait();132 System.out.println(Thread.currentThread().getName() + \" 执行了wait操作\" + \" 执行了wait操作\" + \" -- i=\" + i);133 &#125; catch (InterruptedException e) &#123;134 e.printStackTrace();135 &#125;136 &#125; else &#123;137 // 开始取钱138 System.out.println(Thread.currentThread().getName() + \" 取钱：\" + drawAmount + \" -- i=\" + i);139 setBalance(getBalance() - drawAmount);140 141 flag = false;142 143 // 唤醒其他线程144 notifyAll();145 146 System.out.println(Thread.currentThread().getName() + \"-- 取钱 -- 执行完毕\" + \" -- i=\" + i); // 3147 &#125;148 &#125;149 150 &#125; 上面的例子演示了wait()/notify()/notifyAll()的用法。部分输出结果为： 1234567891011121314151617181920212223242526272829303132 1 取钱线程 开始要执行wait操作 执行了wait操作 -- i=0 2 存钱线程 存款:700.0 -- i=0 3 存钱线程-- 存钱 -- 执行完毕 -- i=0 4 存钱线程 开始要执行wait操作 -- i=1 5 取钱线程 执行了wait操作 执行了wait操作 -- i=0 6 取钱线程 取钱：700.0 -- i=1 7 取钱线程-- 取钱 -- 执行完毕 -- i=1 8 取钱线程 开始要执行wait操作 执行了wait操作 -- i=2 9 存钱线程 执行了wait操作 -- i=110 存钱线程 存款:700.0 -- i=211 存钱线程-- 存钱 -- 执行完毕 -- i=212 取钱线程 执行了wait操作 执行了wait操作 -- i=213 取钱线程 取钱：700.0 -- i=314 取钱线程-- 取钱 -- 执行完毕 -- i=315 取钱线程 开始要执行wait操作 执行了wait操作 -- i=416 存钱线程 存款:700.0 -- i=317 存钱线程-- 存钱 -- 执行完毕 -- i=318 存钱线程 开始要执行wait操作 -- i=419 取钱线程 执行了wait操作 执行了wait操作 -- i=420 取钱线程 取钱：700.0 -- i=521 取钱线程-- 取钱 -- 执行完毕 -- i=522 取钱线程 开始要执行wait操作 执行了wait操作 -- i=623 存钱线程 执行了wait操作 -- i=424 存钱线程 存款:700.0 -- i=525 存钱线程-- 存钱 -- 执行完毕 -- i=526 存钱线程 开始要执行wait操作 -- i=627 取钱线程 执行了wait操作 执行了wait操作 -- i=628 取钱线程 取钱：700.0 -- i=729 取钱线程-- 取钱 -- 执行完毕 -- i=730 取钱线程 开始要执行wait操作 执行了wait操作 -- i=831 存钱线程 执行了wait操作 -- i=632 存钱线程 存款:700.0 -- i=7 由此，我们需要注意如下几点： 1.wait()方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行； 2.notify()/notifyAll()方法执行后，将唤醒此同步锁对象上的（任意一个-notify()/所有-notifyAll()）线程对象，但是，此时还并没有释放同步锁对象，也就是说，如果notify()/notifyAll()后面还有代码，还会继续进行，知道当前线程执行完毕才会释放同步锁对象； 3.notify()/notifyAll()执行后，如果右面有sleep()方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程，接下来同2； 4.wait()/notify()/nitifyAll()完成线程间的通信或协作都是基于不同对象锁的，因此，如果是不同的同步对象锁将失去意义，同时，同步对象锁最好是与共享资源对象保持一一对应关系； 5.当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的。 当然，上面的例子相对来说比较简单，只是为了简单示例wait()/notify()/noitifyAll()方法的用法，但其本质上说，已经是一个简单的生产者-消费者模式了。","categories":[{"name":"多线程","slug":"多线程","permalink":"https://conanisbest.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"Java高级特性——反射","slug":"first","date":"2020-07-02T06:34:39.000Z","updated":"2020-07-13T09:05:04.671Z","comments":true,"path":"2020/07/02/first/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/first/","excerpt":"","text":"Java高级特性——反射 peter_RD_nj 概述 定义 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 用途 在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。 反射机制的相关类 与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 Class类 Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。 获得类相关的方法 方法 用途 asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或是接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 类中其他重要的方法 方法 用途 isAnnotation() 如果是注解类型则返回true isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回true isAnonymousClass() 如果是匿名类则返回true isArray() 如果是一个数组类则返回true isEnum() 如果是枚举类则返回true isInstance(Object obj) 如果obj是该类的实例则返回true isInterface() 如果是接口类则返回true isLocalClass() 如果是局部类则返回true isMemberClass() 如果是内部类则返回true Field类 Field代表类的成员变量（成员变量也称为类的属性）。 方法 用途 equals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 Method类 Method代表类的方法。 方法 用途 invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类 Constructor代表类的构造方法。 方法 用途 newInstance(Object… initargs) 根据传递的参数创建类的对象 示例 为了演示反射的使用，首先构造一个与书籍相关的model——Book.java，然后通过反射方法示例创建对象、反射私有构造方法、反射私有属性、反射私有方法，最后给出两个比较复杂的反射示例——获得当前ZenMode和关机Shutdown。 被反射类Book.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Book&#123; private final static String TAG = \"BookTag\"; private String name; private String author; @Override public String toString() &#123; return \"Book&#123;\" + \"name='\" + name + '\\'' + \", author='\" + author + '\\'' + '&#125;'; &#125; public Book() &#123; &#125; private Book(String name, String author) &#123; this.name = name; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; private String declaredMethod(int index) &#123; String string = null; switch (index) &#123; case 0: string = \"I am declaredMethod 1 !\"; break; case 1: string = \"I am declaredMethod 2 !\"; break; default: string = \"I am declaredMethod 1 !\"; &#125; return string; &#125;&#125; 反射逻辑封装在ReflectClass.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class ReflectClass &#123; private final static String TAG = \"peter.log.ReflectClass\"; // 创建对象 public static void reflectNewInstance() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Object objectBook = classBook.newInstance(); Book book = (Book) objectBook; book.setName(\"Android进阶之光\"); book.setAuthor(\"刘望舒\"); Log.d(TAG,\"reflectNewInstance book = \" + book.toString()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有的构造方法 public static void reflectPrivateConstructor() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Constructor&lt;?&gt; declaredConstructorBook = classBook.getDeclaredConstructor(String.class,String.class); declaredConstructorBook.setAccessible(true); Object objectBook = declaredConstructorBook.newInstance(\"Android开发艺术探索\",\"任玉刚\"); Book book = (Book) objectBook; Log.d(TAG,\"reflectPrivateConstructor book = \" + book.toString()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有属性 public static void reflectPrivateField() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Object objectBook = classBook.newInstance(); Field fieldTag = classBook.getDeclaredField(\"TAG\"); fieldTag.setAccessible(true); String tag = (String) fieldTag.get(objectBook); Log.d(TAG,\"reflectPrivateField tag = \" + tag); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有方法 public static void reflectPrivateMethod() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Method methodBook = classBook.getDeclaredMethod(\"declaredMethod\",int.class); methodBook.setAccessible(true); Object objectBook = classBook.newInstance(); String string = (String) methodBook.invoke(objectBook,0); Log.d(TAG,\"reflectPrivateMethod string = \" + string); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 获得系统Zenmode值 public static int getZenMode() &#123; int zenMode = -1; try &#123; Class&lt;?&gt; cServiceManager = Class.forName(\"android.os.ServiceManager\"); Method mGetService = cServiceManager.getMethod(\"getService\", String.class); Object oNotificationManagerService = mGetService.invoke(null, Context.NOTIFICATION_SERVICE); Class&lt;?&gt; cINotificationManagerStub = Class.forName(\"android.app.INotificationManager$Stub\"); Method mAsInterface = cINotificationManagerStub.getMethod(\"asInterface\",IBinder.class); Object oINotificationManager = mAsInterface.invoke(null,oNotificationManagerService); Method mGetZenMode = cINotificationManagerStub.getMethod(\"getZenMode\"); zenMode = (int) mGetZenMode.invoke(oINotificationManager); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return zenMode; &#125; // 关闭手机 public static void shutDown() &#123; try &#123; Class&lt;?&gt; cServiceManager = Class.forName(\"android.os.ServiceManager\"); Method mGetService = cServiceManager.getMethod(\"getService\",String.class); Object oPowerManagerService = mGetService.invoke(null,Context.POWER_SERVICE); Class&lt;?&gt; cIPowerManagerStub = Class.forName(\"android.os.IPowerManager$Stub\"); Method mShutdown = cIPowerManagerStub.getMethod(\"shutdown\",boolean.class,String.class,boolean.class); Method mAsInterface = cIPowerManagerStub.getMethod(\"asInterface\",IBinder.class); Object oIPowerManager = mAsInterface.invoke(null,oPowerManagerService); mShutdown.invoke(oIPowerManager,true,null,true); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; public static void shutdownOrReboot(final boolean shutdown, final boolean confirm) &#123; try &#123; Class&lt;?&gt; ServiceManager = Class.forName(\"android.os.ServiceManager\"); // 获得ServiceManager的getService方法 Method getService = ServiceManager.getMethod(\"getService\", java.lang.String.class); // 调用getService获取RemoteService Object oRemoteService = getService.invoke(null, Context.POWER_SERVICE); // 获得IPowerManager.Stub类 Class&lt;?&gt; cStub = Class.forName(\"android.os.IPowerManager$Stub\"); // 获得asInterface方法 Method asInterface = cStub.getMethod(\"asInterface\", android.os.IBinder.class); // 调用asInterface方法获取IPowerManager对象 Object oIPowerManager = asInterface.invoke(null, oRemoteService); if (shutdown) &#123; // 获得shutdown()方法 Method shutdownMethod = oIPowerManager.getClass().getMethod( \"shutdown\", boolean.class, String.class, boolean.class); // 调用shutdown()方法 shutdownMethod.invoke(oIPowerManager, confirm, null, false); &#125; else &#123; // 获得reboot()方法 Method rebootMethod = oIPowerManager.getClass().getMethod(\"reboot\", boolean.class, String.class, boolean.class); // 调用reboot()方法 rebootMethod.invoke(oIPowerManager, confirm, null, false); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 调用相应反射逻辑方法 1234567891011121314151617try &#123; // 创建对象 ReflectClass.reflectNewInstance(); // 反射私有的构造方法 ReflectClass.reflectPrivateConstructor(); // 反射私有属性 ReflectClass.reflectPrivateField(); // 反射私有方法 ReflectClass.reflectPrivateMethod(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; Log.d(TAG,\" zenmode = \" + ReflectClass.getZenMode()); Log输出结果如下： 1234508-27 15:11:37.999 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectNewInstance book = Book&#123;name='Android进阶之光', author='刘望舒'&#125;08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateConstructor book = Book&#123;name='Android开发艺术探索', author='任玉刚'&#125;08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateField tag = BookTag08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateMethod string = I am declaredMethod 1 !08-27 15:11:38.004 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectDemo: zenmode = 0 总结 本文列举了反射机制使用过程中常用的、重要的一些类及其方法，更多信息和用法需要近一步的阅读Google提供的相关文档和示例。 在阅读Class类文档时发现一个特点，以通过反射获得Method对象为例，一般会提供四种方法，getMethod(parameterTypes)、getMethods()、getDeclaredMethod(parameterTypes)和getDeclaredMethods()。getMethod(parameterTypes)用来获取某个公有的方法的对象，getMethods()获得该类所有公有的方法，getDeclaredMethod(parameterTypes)获得该类某个方法，getDeclaredMethods()获得该类所有方法。带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法。其他的Annotation、Field、Constructor也是如此。 在ReflectClass类中还提供了两种反射PowerManager.shutdown()的方法，在调用的时候会输出如下log，提示没有相关权限。之前在项目中尝试反射其他方法的时候还遇到过有权限和没权限返回的值不一样的情况。如果源码中明确进行了权限验证，而你的应用又无法获得这个权限的话，建议就不要浪费时间反射了。 1234567891011121314151617W&#x2F;System.err: java.lang.reflect.InvocationTargetExceptionW&#x2F;System.err: at java.lang.reflect.Method.invoke(Native Method)W&#x2F;System.err: at .ReflectClass.shutDown(ReflectClass.java:104)W&#x2F;System.err: at .MainActivity$1.onClick(MainActivity.java:25)W&#x2F;System.err: at android.view.View.performClick(View.java:6259)W&#x2F;System.err: at android.view.View$PerformClick.run(View.java:24732)W&#x2F;System.err: at android.os.Handler.handleCallback(Handler.java:789)W&#x2F;System.err: at android.os.Handler.dispatchMessage(Handler.java:98)W&#x2F;System.err: at android.os.Looper.loop(Looper.java:164)W&#x2F;System.err: at android.app.ActivityThread.main(ActivityThread.java:6592)W&#x2F;System.err: at java.lang.reflect.Method.invoke(Native Method)W&#x2F;System.err: at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)W&#x2F;System.err: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:769)W&#x2F;System.err: Caused by: java.lang.SecurityException: Neither user 10224 nor current process has android.permission.REBOOT.W&#x2F;System.err: at android.os.Parcel.readException(Parcel.java:1942)W&#x2F;System.err: at android.os.Parcel.readException(Parcel.java:1888)W&#x2F;System.err: at android.os.IPowerManager$Stub$Proxy.shutdown(IPowerManager.java:787) ReflectDemo 参考文献 认识反射机制（Reflection） Java 反射机制 一个例子让你了解Java反射机制 Java反射机制的原理及在Android下的简单应用 java中的反射机制 Android注解与反射机制 java.lang.reflect.Method","categories":[{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"辨析 Sass 中的 Map 和 List","slug":"demo","date":"2019-10-21T02:34:12.000Z","updated":"2020-07-03T08:41:53.354Z","comments":true,"path":"2019/10/21/demo/","link":"","permalink":"https://conanisbest.github.io/2019/10/21/demo/","excerpt":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。","text":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。 使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。 测试表格 Variable Description site Sitewide information. page Page specific information and custom variables set in front-matter. config Site configuration theme Theme configuration. Inherits from site configuration. _ (single underscore) Lodash library path Path of current page url Full URL of current page env Environment variables 语法比较 测试标题 在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。 Map 语法下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。 1234567891011121314151617181920212223242526$breakpoint-map: ( small: ( min-width: null, max-width: 479px, base-font: 16px, vertical-rhythm: 1.3 ), medium: ( min-width: 480px, max-width: 959px, base-font: 18px, vertical-rhythm: 1.414 ), large: ( min-width: 960px, max-width: 1099px, base-font: 18px, vertical-rhythm: 1.5 ), xlarge: ( min-width: 1100px, max-width: null, base-font: 21px, vertical-rhythm: 1.618 )); 多重列表语法下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 nth() 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。 123456$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, null, 21px, 1.618)); 遍历比较 测试标题 从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？ 遍历 Map我们可以使用如下的代码遍历 Map： 1@each $label, $map in $breakpoint-map &#123;&#125; 这里的变量 $label 和 $map 会随着对 $breakpoint-map 的遍历被动态地赋值，$label 将会被赋值为 $breakpoint-map 的 Key，而 $map 会被赋值为 $breakpoint-map 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 map-get() 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。 具体的做法就是使用 @each 遍历 Map，然后使用 map-get() 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历： 123456@each $label, $map in $breakpoint-map &#123; $min-width: map-get($map, min-width); $max-width: map-get($map, max-width); $base-font: map-get($map, base-font); $vertical-rhythm: map-get($map, vertical-rhythm);&#125; 遍历多重列表遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 map-get() 函数取特定值，直接遍历一遍即可获得特定值。 因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 map-get()，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符： 12@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#125; 慎用多重列表 测试标题 经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。 遗漏键值如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况： 1234567891011121314151617181920$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, 21px, 1.618));p &#123; @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123; @if $min-width &#123; @include breakpoint( $min-width ) &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125; @else &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125;&#125; 当我们尝试运行这段代码时，结果肯定是错误地，因为在 $breakpoint-list 的最后一行，xlarge 被赋值给了 $label，1100px 被赋值给了 $min-width，21px 被赋值给了 $max-width, 1.618 被赋值给了 $base-font，最终导致 $vertical-rhythm 没有被赋值，结果就是 font-size 的属性值是错的，line-height 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。 如果我们使用 Map 来代替这里的多重列表，那么使用 map-get() 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。 查找特定列表在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 map-get() 函数可以快速定位到特定子 Map： 1$medium-map: map-get($maps, medium); 但如果要获取多种列表 medium 列表，麻烦可就大了： 123456789@function get-list($label) &#123; @each $list in $breakpoint-list &#123; @if nth($list, 1) &#x3D;&#x3D; $label &#123; @return $list; &#125; &#125; @return null;&#125;$medium-list: get-list(medium); 这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 null。这实际上就是手工实现了 map-get() 的逻辑。 缺少原生的 Map 函数Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 map-merge() 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 join() 或 append() 来增加新列表，从而模拟出 map-merge() 的效果。 另一个实用的 Map 函数就是 map-has-key()，对于依赖 map-get() 的自定义函数来说，map-has-key() 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。 总结 Test Title 相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。 虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://conanisbest.github.io/tags/css/"}]}],"categories":[{"name":"数据库","slug":"数据库","permalink":"https://conanisbest.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"static关键字","slug":"static关键字","permalink":"https://conanisbest.github.io/categories/static%E5%85%B3%E9%94%AE%E5%AD%97/"},{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"},{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"redis","slug":"redis","permalink":"https://conanisbest.github.io/categories/redis/"},{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/categories/java/"},{"name":"数据库相关","slug":"数据库相关","permalink":"https://conanisbest.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"},{"name":"多线程","slug":"多线程","permalink":"https://conanisbest.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://conanisbest.github.io/tags/mysql/"},{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"},{"name":"jsp","slug":"jsp","permalink":"https://conanisbest.github.io/tags/jsp/"},{"name":"hashmap","slug":"hashmap","permalink":"https://conanisbest.github.io/tags/hashmap/"},{"name":"http","slug":"http","permalink":"https://conanisbest.github.io/tags/http/"},{"name":"设计模式","slug":"设计模式","permalink":"https://conanisbest.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"sql","slug":"sql","permalink":"https://conanisbest.github.io/tags/sql/"},{"name":"序列化","slug":"序列化","permalink":"https://conanisbest.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"Windows","slug":"Windows","permalink":"https://conanisbest.github.io/tags/Windows/"},{"name":"redis","slug":"redis","permalink":"https://conanisbest.github.io/tags/redis/"},{"name":"jvm","slug":"jvm","permalink":"https://conanisbest.github.io/tags/jvm/"},{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"hibernate","slug":"hibernate","permalink":"https://conanisbest.github.io/tags/hibernate/"},{"name":"JVM","slug":"JVM","permalink":"https://conanisbest.github.io/tags/JVM/"},{"name":"css","slug":"css","permalink":"https://conanisbest.github.io/tags/css/"}]}