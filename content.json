{"meta":{"title":"Conan的博客","subtitle":"","description":"愚者不努力，懒人盼巅峰","author":"John Doe","url":"https://Conanisbest.github.io","root":"/"},"pages":[{"title":"categories","date":"2020-07-13T09:04:31.116Z","updated":"2020-07-13T09:04:31.116Z","comments":true,"path":"categories/index.html","permalink":"https://conanisbest.github.io/categories/index.html","excerpt":"","text":""},{"title":"About Me","date":"2020-07-02T08:34:49.000Z","updated":"2020-07-14T04:36:26.388Z","comments":true,"path":"about/index.html","permalink":"https://conanisbest.github.io/about/index.html","excerpt":"","text":"A Coder, live in Beijing, China. 姓名：Conan现居：北京GitHub: ConanisbestQQ: 1437354122微信: Conan_keepmoving 愚者不努力，懒人盼巅峰"},{"title":"tags","date":"2020-07-07T09:23:32.000Z","updated":"2020-07-13T09:04:22.530Z","comments":true,"path":"tags/index.html","permalink":"https://conanisbest.github.io/tags/index.html","excerpt":"","text":""},{"title":"Gallery","date":"2020-07-14T04:38:17.415Z","updated":"2020-07-14T04:38:17.415Z","comments":true,"path":"photos/index.html","permalink":"https://conanisbest.github.io/photos/index.html","excerpt":"","text":""}],"posts":[{"title":"Windows10远程桌面连接提示：出现身份验证错误，要求的函数不受支持。。。","slug":"yczm","date":"2020-07-17T02:38:56.000Z","updated":"2020-07-17T02:50:17.767Z","comments":true,"path":"2020/07/17/yczm/","link":"","permalink":"https://conanisbest.github.io/2020/07/17/yczm/","excerpt":"","text":"Windows10远程桌面连接提示：出现身份验证错误，要求的函数不受支持。。。分类专栏： Windows 错误信息：出现身份验证错误，要求的函数不受支持。。。 解决办法：1、按Windows键+R，或者在CMD命令窗口，输入“运行”，打开运行窗口， 2、输入regedit，打开注册表编辑器， 找到路径：计算机\\HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\System 然后在System文件夹内创建文件夹项：\\CredSSP\\Parameters 然后在Parameters文件夹内，新建 DWORD（32）位值（D），文件名为 AllowEncryptionOracle，值为2 3、重新远程连接一下，错误消失，可以正常连接。 也可以尝试使用：IIS7服务器管理工具 ————————————————版权声明：本文为CSDN博主「daqiang012」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/daqiang012/java/article/details/82385720","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://conanisbest.github.io/tags/Windows/"}]},{"title":"redis全面解析","slug":"redis","date":"2020-07-14T02:51:13.000Z","updated":"2020-07-14T03:11:17.206Z","comments":true,"path":"2020/07/14/redis/","link":"","permalink":"https://conanisbest.github.io/2020/07/14/redis/","excerpt":"","text":"redis全面解析分类专栏： 数据库 什么是Redis?Redis 是开源免费的，遵守BSD协议，是一个高性能的key-value非关系型数据库。 redis单线程问题所谓的单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。 redis采用多路复用机制：即多个网络socket复用一个io线程，实际是单个线程通过记录跟踪每一个Sock(I/O流)的状态来同时管理多个I/O流. Redis特点：Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis不仅仅支持简单的key-value类型的数据，同时还提供String，list，set，zset，hash等数据结构的存储。 Redis支持数据的备份，即master-slave模式的数据备份。 性能极高 – Redis能读的速度是110000次/s,写的速度是81000次/s 。 原子 – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。 丰富的特性 – Redis还支持 publish/subscribe, 通知, 设置key有效期等等特性。 redis作用:可以减轻数据库压力，查询内存比查询数据库效率高。 Redis应用：token生成、session共享、分布式锁、自增id、验证码等。 比较重要的3个可执行文件：redis-server：Redis服务器程序 redis-cli：Redis客户端程序，它是一个命令行操作工具。也可以使用telnet根据其纯文本协议操作。 redis-benchmark：Redis性能测试工具，测试Redis在你的系统及配置下的读写性能。 redis数据结构123456789存储字符串1.set key value：设定key持有指定的字符串value，如果该key存在则进行覆盖操作,总是返回OK2.get key: 获取key的value。如果与该key关联的value不是String类型，redis将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回null。3.getset key value：先获取该key的值，然后在设置该key的值。4.incr key：将指定的key的value原子性的递增1. 如果该key不存在，其初始值为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息5.decr key：将指定的key的value原子性的递减1.如果该key不存在，其初始值为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执 行失败并返回相应的错误信息。6.incrby key increment：将指定的key的value原子性增加increment，如果该key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成 整型，如hello则失败并返回错误信息7.decrby key decrement：将指定的key的value原子性减少decrement，如果该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能 转成整型，如hello则失败并返回错误信息8.append key value：如果该key存在，则在原有的value后追加该值；如果该key 不存在，则重新创建一个key&#x2F;value 存储list类型 1.lpush key value1 value2…：在指定的key所关联的list的头部插入所有的values，如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的头部插入数据。插入成功，返回元素的个数。 2.rpush key value1、value2…：在该list的尾部添加元素 3.lrange key start end：获取链表中从start到end的元素的值，start、end可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推… 4.lpushx key value：仅当参数中指定的key存在时（如果与key管理的list中没有值时，则该key是不存在的）在指定的key所关联的list的头部插入value。 5.rpushx key value：在该list的尾部添加元素 6.lpop key：返回并弹出指定的key关联的链表中的第一个元素，即头部元素 7.rpop key：从尾部弹出元素 8.rpoplpush resource destination：将链表中的尾部元素弹出并添加到头部 9.llen key：返回指定的key关联的链表中的元素的数量。 10.lset key index value：设置链表中的index的脚标的元素值，0代表链表的头元素，-1代表链表的尾元素。 1234567891011121314151617181920212223242526272829303132333435存储Set添加或删除元素1.sadd key values[value1、value2……]:向set中添加数据，如果该key的值有则不会重复添加例如:sadd myset a b c2.srem key members[member1、menber2…]:删除set中的指定成员例如:srem myset 1 2 3获得集合中的元素1.smembers key :获取set中所有的成员smembers myset2.sismember key menber :判断参数中指定的成员是否在该set中，1表示存在，0表示不存在或者该key本身就不存在(无论集合中有多少元素都可以极速的返回结果)集合的差集运算 A-Bsdiff key1 key2 … : 返回key1与key2中相差的成员，而且与key的顺序有关。即返回差集。集合的交集运算 sinter key1 key2 key3… :返回交集集合的并集运算 sunion key1 key2 key3… : 返回并集扩展命令(了解)scard key : 获取set中的成员数量例子:scard mysetsrandmember key : 随机返回set中的一个成员sdiffstore destination key1 key2 …: 将key1 key2 相差的成员存储到destination中sinterstore destination key[key…] : 将返回的交集存储在destination上suninonstore destination key[key…] : 将返回的并集存储在destination上 12345678910111213141516171819202122232425262728293031323334353637存储hash1.赋值hset key field value : 为指定的key设定field&#x2F;value对hmset key field1 value1 field2 value2 field3 value3 为指定的key设定多个field&#x2F;value对2.取值hget key field : 返回指定的key中的field的值hmget key field1 field2 field3 : 获取key中的多个field值hkeys key : 获取所有的keyhvals key :获取所有的valuehgetall key : 获取key中的所有field 中的所有field-value3.删除hdel key field[field…] : 可以删除一个或多个字段，返回是被删除的字段个数del key : 删除整个list4.增加数字hincrby key field increment ：设置key中field的值增加increment，如: age增加20hincrby myhash age 5自学命令:hexists key field : 判断指定的key中的field是否存在hlen key : 获取key所包含的field的数量hkeys key ：获得所有的key hkeys myhashhvals key ：获得所有的valuehvals myhash 1234567891011121314151617181920212223242526272829存储sortedset1.添加元素zadd key score member score2 member2…:将所有成员以及该成员的分数存放到sorted-set中。如果该元素已经存在则会用新的分数替换原有的分数。返回值是新加入到集合中的元素个数。(根据分数升序排列)2.获得元素zscore key member ：返回指定成员的分数zcard key ：获得集合中的成员数量3.删除元素zrem key member[member…] ：移除集合中指定的成员，可以指定多个成员4.范围查询zrange key strat end [withscores]：获取集合中角标为start-end的成员，[withscore]参数表明返回的成员包含其分数。zremrangebyrank key start stop ：按照排名范围删除元素zremrangescore key min max ：按照分数范围删除元素扩展命令(了解)zrangebyscore key min max [withscore] [limit offset count] ：返回分数在[min,max]的成员并按照分数从低到高排序。[withscore]：显示分数；[limit offset count]；offset，表明从脚标为offset的元素开始并返回count个成员zincrby key increment member ：设置指定成员的增加分数。返回值是修改后的分数zcount key min max：获取分数在[min，max]之间的成员个数zrank key member：返回成员在集合中的排名(从小到大)zrevrank key member ：返回成员在集合中的排名(从大到小) 123456789101112131415161718192021222324key的通用操作 keys pattern : 获取所有与pattern匹配的key ，返回所有与该key匹配的keys。 *表示任意一个或者多个字符， ?表示任意一个字符del key1 key2… ：删除指定的key del my1 my2 my3exists key ：判断该key是否存在，1代表存在，0代表不存在rename key newkey ：为key重命名expire key second：设置过期时间，单位秒ttl key：获取该key所剩的超时时间，如果没有设置超时，返回-1，如果返回-2表示超时不存在。persist key:持久化key 192.168.25.153:6379&gt; expire Hello 100(integer) 1192.168.25.153:6379&gt; ttl Hello(integer) 77type key：获取指定key的类型。该命令将以字符串的格式返回。返回的字符串为string 、list 、set 、hash 和 zset，如果key不存在返回none。例如: type newcompanynone redis的数据类型，以及每种数据类型的使用场景(一)String这个其实没啥好说的，最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。 (二)hash这里value存放的是结构化的对象，比较方便的就是操作其中的某个字段。博主在做单点登录的时候，就是用这种数据结构存储用户信息，以cookieId作为key，设置30分钟为缓存过期时间，能很好的模拟出类似session的效果。 (三)list使用List的数据结构，可以做简单的消息队列的功能。另外还有一个就是，可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。 (四)set因为set堆放的是一堆不重复值的集合。所以可以做全局去重的功能。为什么不用JVM自带的Set进行去重？因为我们的系统一般都是集群部署，使用JVM自带的Set，比较麻烦，难道为了一个做一个全局去重，再起一个公共服务，太麻烦了。另外，就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。 (五)sorted set sorted set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。另外，参照另一篇《分布式之延时任务方案解析》，该文指出了sorted set可以用来做延时任务。最后一个应用就是可以做范围查找。 redis的过期策略以及内存淘汰机制分析:这个问题其实相当重要，到底redis有没用到家，这个问题就可以看出来。比如你redis只能存5G数据，可是你写了10G，那会删5G的数据。怎么删的，这个问题思考过么？还有，你的数据已经设置了过期时间，但是时间到了，内存占用率还是比较高，有思考过原因么?回答:redis采用的是定期删除+惰性删除策略。为什么不用定时删除策略?定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.定期删除+惰性删除是如何工作的呢?定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。采用定期删除+惰性删除就没其他问题了么?不是的，如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。在redis.conf中有一行配置 1maxmemory-policy allkeys-lru 该配置就是配内存淘汰策略的(什么，你没配过？好好反省一下自己)1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用。3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐ps：如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。 redis和数据库双写一致性问题分析:一致性问题是分布式常见问题，还可以再分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。答这个问题，先明白一个前提。就是如果对数据有强一致性要求，不能放缓存。我们所做的一切，只能保证最终一致性。另外，我们所做的方案其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。回答:首先，采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。 如何应对缓存穿透和缓存雪崩问题分析:这两个问题，说句实在话，一般中小型传统软件企业，很难碰到这个问题。如果有大并发的项目，流量有几百万左右。这两个问题一定要深刻考虑。回答:如下所示 缓存穿透：即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。 解决方案:(一)利用互斥锁，缓存失效的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试(二)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。(三)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。 缓存雪崩，即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。 解决方案:(一)给缓存的失效时间，加上一个随机值，避免集体失效。(二)使用互斥锁，但是该方案吞吐量明显下降了。(三)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点 I 从缓存A读数据库，有则直接返回 II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。 III 更新线程同时更新缓存A和缓存B。 如何解决redis的并发竞争key问题分析:这个问题大致就是，同时有多个子系统去set一个key。这个时候要注意什么呢？大家思考过么。需要说明一下，博主提前百度了一下，发现答案基本都是推荐用redis事务机制。博主不推荐使用redis的事务机制。因为我们的生产环境，基本都是redis集群环境，做了数据分片操作。你一个事务中有涉及到多个key操作的时候，这多个key不一定都存储在同一个redis-server上。因此，redis的事务机制，十分鸡肋。 回答:如下所示(1)如果对这个key操作，不要求顺序这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。(2)如果对这个key操作，要求顺序假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC.期望按照key1的value值按照 valueA–&gt;valueB–&gt;valueC的顺序变化。这种时候我们在数据写入数据库的时候，需要保存一个时间戳。假设时间戳如下 123系统A key 1 &#123;valueA 3:00&#125;系统B key 1 &#123;valueB 3:05&#125;系统C key 1 &#123;valueC 3:10&#125; 那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。 其他方法，比如利用队列，将set方法变成串行访问也可以。总之，灵活变通。 redis中支持事务吗？【了解即可】支持，使用multi开启事务，使用exec提交事务。 redis发布订阅【了解即可】Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。 Redis 客户端可以订阅任意数量的频道。 下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系： 当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端： 12345678910111213141516171819202122232425redis 127.0.0.1:6379&gt; SUBSCRIBE redisChatReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;redisChat&quot;3) (integer) 1现在，我们先重新开启个 redis 客户端，然后在同一个频道 redisChat 发布两次消息，订阅者就能接收到消息。redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;hello&quot;(integer) 1redis 127.0.0.1:6379&gt; PUBLISH redisChat &quot;What &#39;s your name?&quot;(integer) 1# 订阅者的客户端会显示如下消息1) &quot;message&quot;2) &quot;redisChat&quot;3) &quot;hello&quot;1) &quot;message&quot;2) &quot;redisChat&quot;3) &quot;What &#39;s your name?&quot; 另外我还写了几篇关于redis的文章：1、关于redis的持久化(rdb/aof)与备份 https://blog.csdn.net/itcats_cn/article/details/82432530 2、redis如何实现高可用【主从复制、哨兵机制】 https://blog.csdn.net/itcats_cn/article/details/82428716 部分内容参考 作者：孤独烟 来自：http://rjzheng.cnblogs.com/ https://mp.weixin.qq.com/s/gEU8HtsQNPXY8bzkK-Qllg————————————————版权声明：本文为CSDN博主「itcats_cn」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/itcats_cn/java/article/details/82391719","categories":[{"name":"redis","slug":"redis","permalink":"https://conanisbest.github.io/categories/redis/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://conanisbest.github.io/tags/redis/"}]},{"title":"jvm之java类加载机制和类加载器(ClassLoader)的详解","slug":"java类加载器","date":"2020-07-08T07:20:09.000Z","updated":"2020-07-14T03:32:06.674Z","comments":true,"path":"2020/07/08/java类加载器/","link":"","permalink":"https://conanisbest.github.io/2020/07/08/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/","excerpt":"","text":"jvm之java类加载机制和类加载器(ClassLoader)的详解分类专栏： java jvm 当程序主动使用某个类时，如果该类还未被加载到内存中，则JVM会通过加载、连接、初始化3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为类加载或类初始化。 一、类加载过程1.加载 加载指的是将类的class文件读入到内存，并为之创建一个java.lang.Class对象，也就是说，当程序中使用任何类时，系统都会为之建立一个java.lang.Class对象。 类的加载由类加载器完成，类加载器通常由JVM提供，这些类加载器也是前面所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。 通过使用不同的类加载器，可以从不同来源加载类的二进制数据，通常有如下几种来源。从本地文件系统加载class文件，这是前面绝大部分示例程序的类加载方式。从JAR包加载class文件，这种方式也是很常见的，前面介绍JDBC编程时用到的数据库驱动类就放在JAR文件中，JVM可以从JAR文件中直接加载该class文件。通过网络加载class文件。把一个Java源文件动态编译，并执行加载。 类加载器通常无须等到“首次使用”该类时才加载该类，Java虚拟机规范允许系统预先加载某些类。 2.链接 当类被加载之后，系统为之生成一个对应的Class对象，接着将会进入连接阶段，连接阶段负责把类的二进制数据合并到JRE中。类连接又可分为如下3个阶段。 1)验证：验证阶段用于检验被加载的类是否有正确的内部结构，并和其他类协调一致。Java是相对C++语言是安全的语言，例如它有C++不具有的数组越界的检查。这本身就是对自身安全的一种保护。验证阶段是Java非常重要的一个阶段，它会直接的保证应用是否会被恶意入侵的一道重要的防线，越是严谨的验证机制越安全。验证的目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，不会危害虚拟机自身安全。其主要包括四种验证，文件格式验证，元数据验证，字节码验证，符号引用验证。 四种验证做进一步说明： 文件格式验证：主要验证字节流是否符合Class文件格式规范，并且能被当前的虚拟机加载处理。例如：主，次版本号是否在当前虚拟机处理的范围之内。常量池中是否有不被支持的常量类型。指向常量的中的索引值是否存在不存在的常量或不符合类型的常量。 元数据验证：对字节码描述的信息进行语义的分析，分析是否符合java的语言语法的规范。 字节码验证：最重要的验证环节，分析数据流和控制，确定语义是合法的，符合逻辑的。主要的针对元数据验证后对方法体的验证。保证类方法在运行时不会有危害出现。 符号引用验证：主要是针对符号引用转换为直接引用的时候，是会延伸到第三解析阶段，主要去确定访问类型等涉及到引用的情况，主要是要保证引用一定会被访问到，不会出现类等无法访问的问题。 2)准备：类准备阶段负责为类的静态变量分配内存，并设置默认初始值。 3)解析：将类的二进制数据中的符号引用替换成直接引用。说明一下：符号引用：符号引用是以一组符号来描述所引用的目标，符号可以是任何的字面形式的字面量，只要不会出现冲突能够定位到就行。布局和内存无关。直接引用：是指向目标的指针，偏移量或者能够直接定位的句柄。该引用是和内存中的布局有关的，并且一定加载进来的。 3.初始化 初始化是为类的静态变量赋予正确的初始值，准备阶段和初始化阶段看似有点矛盾，其实是不矛盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。 二、类加载时机创建类的实例，也就是new一个对象访问某个类或接口的静态变量，或者对该静态变量赋值调用类的静态方法反射（Class.forName(“com.lyj.load”)）初始化一个类的子类（会首先初始化子类的父类）JVM启动时标明的启动类，即文件名和类名相同的那个类 除此之外，下面几种情形需要特别指出： 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。三、类加载器 类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。这意味着两个类加载器加载的同名类：（Person.pg.kl）和（Person.pg.kl2）是不同的、它们所加载的类也是完全不同、互不兼容的。 JVM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器： 1)根类加载器（bootstrap class loader）:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中jre/lib/rt.jar里所有的class，由C++实现，不是ClassLoader子类）。由于引导类加载器涉及到虚拟机本地实现细节，开发者无法直接获取到启动类加载器的引用，所以不允许直接通过引用进行操作。 下面程序可以获得根类加载器所加载的核心类库,并会看到本机安装的Java环境变量指定的jdk中提供的核心jar包路径： public class ClassLoaderTest { 1234567public static void main(String[] args) &#123; URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for(URL url : urls)&#123; System.out.println(url.toExternalForm()); &#125;&#125; }运行结果： 2)扩展类加载器（extensions class loader）：它负责加载JRE的扩展目录，lib/ext或者由java.ext.dirs系统属性指定的目录中的JAR包的类。由Java语言实现，父类加载器为null。 3)系统类加载器（system class loader）：被称为系统（也称为应用）类加载器，它负责在JVM启动时加载来自Java命令的-classpath选项、java.class.path系统属性，或者CLASSPATH换将变量所指定的JAR包和类路径。程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现，父类加载器为ExtClassLoader。 类加载器加载Class大致要经过如下8个步骤： 检测此Class是否载入过，即在缓冲区中是否有此Class，如果有直接进入第8步，否则进入第2步。如果没有父类加载器，则要么Parent是根类加载器，要么本身就是根类加载器，则跳到第4步，如果父类加载器存在，则进入第3步。请求使用父类加载器去载入目标类，如果载入成功则跳至第8步，否则接着执行第5步。请求使用根类加载器去载入目标类，如果载入成功则跳至第8步，否则跳至第7步。当前类加载器尝试寻找Class文件，如果找到则执行第6步，如果找不到则执行第7步。从文件中载入Class，成功后跳至第8步。抛出ClassNotFountException异常。返回对应的java.lang.Class对象。四、类加载机制：1.JVM的类加载机制主要有如下3种。 全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。双亲委派：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。2.这里说明一下双亲委派机制： 双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。 双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。————————————————版权声明：本文为CSDN博主「超级战斗王」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/m0_38075425/java/article/details/81627349","categories":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/categories/java/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"https://conanisbest.github.io/tags/jvm/"}]},{"title":"java基础知识","slug":"java基础知识","date":"2020-07-07T06:46:42.000Z","updated":"2020-07-14T03:31:40.230Z","comments":true,"path":"2020/07/07/java基础知识/","link":"","permalink":"https://conanisbest.github.io/2020/07/07/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","excerpt":"","text":"本文知识点目录 Java概述 何为编程 什么是Java jdk1.5之后的三大版本 JVM、JRE和JDK的关系 什么是跨平台性？原理是什么 Java语言有哪些特点？ 什么是字节码？采用字节码的最大好处是什么 什么是Java程序的主类？应用程序和小程序的主类有何不同？ Java应用程序与小程序之间有那些差别？ Java和C++的区别 Oracle JDK 和 OpenJDK 的对比 基础语法 数据类型 Java有哪些数据类型 switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上 用最有效率的方法计算 2 乘以 8 Math.round(11.5) 等于多少？Math.round(-11.5)等于多少 float f=3.4;是否正确 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗 编码 Java语言采用何种编码方案？有何特点？ 注释 什么是Java注释 访问修饰符 访问修饰符 public,private,protected,以及不写（默认）时的区别 运算符 &amp;和&amp;&amp;的区别 关键字 Java 有没有 goto final 有什么用？ final finally finalize区别 this关键字的用法 super关键字的用法 this与super的区别 static存在的主要意义 static的独特之处 static应用场景 static注意事项 流程控制语句 break ,continue ,return 的区别及作用 在 Java 中，如何跳出当前的多重嵌套循环 面向对象 面向对象概述 面向对象和面向过程的区别 面向对象三大特性 面向对象的特征有哪些方面 什么是多态机制？Java语言是如何实现多态的？ 面向对象五大基本原则是什么（可选） 类与接口 抽象类和接口的对比 普通类和抽象类有哪些区别？ 抽象类能使用 final 修饰吗？ 创建一个对象用什么关键字？对象实例与对象引用有何不同？ 变量与方法 成员变量与局部变量的区别有哪些 在Java中定义一个不做事且没有参数的构造方法的作用 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？ 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？ 构造方法有哪些特性？ 静态变量和实例变量区别 静态变量与普通变量区别 静态方法和实例方法有何不同？ 在一个静态方法内调用一个非静态成员为什么是非法的？ 什么是方法的返回值？返回值的作用是什么？ 内部类 什么是内部类？ 内部类的分类有哪些 静态内部类 成员内部类 局部内部类 匿名内部类 内部类的优点 内部类有哪些应用场景 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？ 内部类相关，看程序说出运行结果 重写与重载 构造器（constructor）是否可被重写（override） 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？ 对象相等判断 == 和 equals 的区别是什么 hashCode 与 equals (重要) 对象的相等与指向他们的引用相等，两者有什么不同？ 值传递 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递 为什么 Java 中只有值传递 值传递和引用传递有什么区别 Java包 JDK 中常用的包有哪些 import java和javax有什么区别 IO流 java 中 IO 流分为几种? BIO,NIO,AIO 有什么区别? Files的常用方法都有哪些？ 反射 什么是反射机制？ 反射机制优缺点 反射机制的应用场景有哪些？ Java获取反射的三种方法 网络编程 常用API String相关 字符型常量和字符串常量的区别 什么是字符串常量池？ String 是最基本的数据类型吗 String有哪些特性 String为什么是不可变的吗？ String真的是不可变的吗？ 是否可以继承 String 类 String str=”i”与 String str=new String(“i”)一样吗？ String s = new String(“xyz”);创建了几个字符串对象 如何将字符串反转？ 数组有没有 length()方法？String 有没有 length()方法 String 类的常用方法都有那些？ 在使用 HashMap 的时候，用 String 做 key 有什么好处？ String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的 Date相关 包装类相关 自动装箱与拆箱 int 和 Integer 有什么区别 Integer a= 127 与 Integer b = 127相等吗 Java概述何为编程编程就是让计算机为解决某个问题而使用某种程序设计语言编写程序代码，并最终得到结果的过程。 为了使计算机能够理解人的意图，人类就必须要将需解决的问题的思路、方法、和手段通过计算机能够理解的形式告诉计算机，使得计算机能够根据人的指令一步一步去工作，完成某种特定的任务。这种人和计算机之间交流的过程就是编程。 什么是JavaJava是一门面向对象编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。Java语言作为静态面向对象编程语言的代表，极好地实现了面向对象理论，允许程序员以优雅的思维方式进行复杂的编程 。 jdk1.5之后的三大版本 Java SE（J2SE，Java 2 Platform Standard Edition，标准版）Java SE 以前称为 J2SE。它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序。Java SE 包含了支持 Java Web 服务开发的类，并为Java EE和Java ME提供基础。 Java EE（J2EE，Java 2 Platform Enterprise Edition，企业版）Java EE 以前称为 J2EE。企业版本帮助开发和部署可移植、健壮、可伸缩且安全的服务器端Java 应用程序。Java EE 是在 Java SE 的基础上构建的，它提供 Web 服务、组件模型、管理和通信 API，可以用来实现企业级的面向服务体系结构（service-oriented architecture，SOA）和 Web2.0应用程序。2018年2月，Eclipse 宣布正式将 JavaEE 更名为 JakartaEE Java ME（J2ME，Java 2 Platform Micro Edition，微型版）Java ME 以前称为 J2ME。Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。Java ME 包括灵活的用户界面、健壮的安全模型、许多内置的网络协议以及对可以动态下载的连网和离线应用程序的丰富支持。基于 Java ME 规范的应用程序只需编写一次，就可以用于许多设备，而且可以利用每个设备的本机功能。 JVM、JRE和JDK的关系JVMJava Virtual Machine是Java虚拟机，Java程序需要运行在虚拟机上，不同的平台有自己的虚拟机，因此Java语言可以实现跨平台。 JREJava Runtime Environment包括Java虚拟机和Java程序所需的核心类库等。核心类库主要是java.lang包：包含了运行Java程序必不可少的系统类，如基本数据类型、基本数学函数、字符串处理、线程、异常处理类等，系统缺省加载这个包 如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。 JDKJava Development Kit是提供给Java开发人员使用的，其中包含了Java的开发工具，也包括了JRE。所以安装了JDK，就无需再单独安装JRE了。其中的开发工具：编译工具(javac.exe)，打包工具(jar.exe)等 JVM&amp;JRE&amp;JDK关系图 什么是跨平台性？原理是什么所谓跨平台性，是指java语言编写的程序，一次编译后，可以在多个系统平台上运行。 实现原理：Java程序是通过java虚拟机在系统平台上运行的，只要该系统可以安装相应的java虚拟机，该系统就可以运行java程序。 Java语言有哪些特点简单易学（Java语言的语法与C语言和C++语言很接近） 面向对象（封装，继承，多态） 平台无关性（Java虚拟机实现平台无关性） 支持网络编程并且很方便（Java语言诞生本身就是为简化网络编程设计的） 支持多线程（多线程机制使应用程序在同一时间并行执行多项任） 健壮性（Java语言的强类型机制、异常处理、垃圾的自动收集等） 安全性 什么是字节码？采用字节码的最大好处是什么字节码：Java源代码经过虚拟机编译器编译后产生的文件（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。 采用字节码的好处： Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。 先看下java中的编译器和解释器： Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器。这台虚拟的机器在任何平台上都提供给编译程序一个的共同的接口。编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来将虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码（即扩展为.class的文件），它不面向任何特定的处理器，只面向虚拟机。每一种平台的解释器是不同的，但是实现的虚拟机是相同的。Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定的机器上运行，这就是上面提到的Java的特点的编译与解释并存的解释。 1Java源代码----&gt;编译器----&gt;jvm可执行的Java字节码(即虚拟指令)----&gt;jvm----&gt;jvm中解释器-----&gt;机器可执行的二进制机器码----&gt;程序运行。 什么是Java程序的主类？应用程序和小程序的主类有何不同？一个程序中可以有多个类，但只能有一个类是主类。在Java应用程序中，这个主类是指包含main()方法的类。而在Java小程序中，这个主类是一个继承自系统类JApplet或Applet的子类。应用程序的主类不一定要求是public类，但小程序的主类要求必须是public类。主类是Java程序执行的入口点。 Java应用程序与小程序之间有那些差别？简单说应用程序是从主线程启动(也就是main()方法)。applet小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟flash的小游戏类似。 Java和C++的区别我知道很多人没学过C++，但是面试官就是没事喜欢拿咱们Java和C++比呀！没办法！！！就算没学过C++，也要记下来！ 都是面向对象的语言，都支持封装、继承和多态 Java不提供指针来直接访问内存，程序内存更加安全 Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承。 Java有自动内存管理机制，不需要程序员手动释放无用内存 Oracle JDK 和 OpenJDK 的对比 Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次； OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题； 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能； Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。 基础语法数据类型Java有哪些数据类型定义：Java语言是强类型语言，对于每一种数据都定义了明确的具体的数据类型，在内存中分配了不同大小的内存空间。 分类 基本数据类型 整数类型(byte,short,int,long) 浮点类型(float,double) 数值型 字符型(char) 布尔型(boolean) 引用数据类型 类(class) 接口(interface) 数组([]) Java基本数据类型图 switch 是否能作用在 byte 上，是否能作用在 long 上，是否能作用在 String 上在 Java 5 以前，switch(expr)中，expr 只能是 byte、short、char、int。从 Java5 开始，Java 中引入了枚举类型，expr 也可以是 enum 类型，从 Java 7 开始，expr 还可以是字符串（String），但是长整型（long）在目前所有的版本中都是不可以的。 用最有效率的方法计算 2 乘以 82 &lt;&lt; 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。 Math.round(11.5) 等于多少？Math.round(-11.5)等于多少Math.round(11.5)的返回值是 12，Math.round(-11.5)的返回值是-11。四舍五入的原理是在参数上加 0.5 然后进行下取整。 float f=3.4;是否正确不正确。3.4 是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型（down-casting，也称为窄化）会造成精度损失，因此需要强制类型转换float f =(float)3.4; 或者写成 float f =3.4F;。 short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗对于 short s1 = 1; s1 = s1 + 1;由于 1 是 int 类型，因此 s1+1 运算结果也是 int型，需要强制转换类型才能赋值给 short 型。 而 short s1 = 1; s1 += 1;可以正确编译，因为 s1+= 1;相当于 s1 = (short(s1 + 1);其中有隐含的强制类型转换。 编码Java语言采用何种编码方案？有何特点？Java语言采用Unicode编码标准，Unicode（标准码），它为每个字符制订了一个唯一的数值，因此在任何的语言，平台，程序都可以放心的使用。 注释什么Java注释定义：用于解释说明程序的文字 分类 单行注释格式：// 注释文字 多行注释格式：/* 注释文字 */ 文档注释格式：/** 注释文字 */ 作用 在程序中，尤其是复杂的程序中，适当地加入注释可以增加程序的可读性，有利于程序的修改、调试和交流。注释的内容在程序编译的时候会被忽视，不会产生目标代码，注释的部分不会对程序的执行结果产生任何影响。 注意事项：多行和文档注释都不能嵌套使用。 访问修饰符访问修饰符 public,private,protected,以及不写（默认）时的区别定义：Java中，可以使用访问修饰符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限。 分类 private : 在同一类内可见。使用对象：变量、方法。注意：不能修饰类（外部类）default (即缺省，什么也不写，不使用任何关键字）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。注意：不能修饰类（外部类）。public : 对所有类可见。使用对象：类、接口、变量、方法 访问修饰符图 运算符&amp;和&amp;&amp;的区别&amp;运算符有两种用法：(1)按位与；(2)逻辑与。 &amp;&amp;运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&amp;&amp;之所以称为短路运算，是因为如果&amp;&amp;左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。 注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。 关键字Java 有没有 gotogoto 是 Java 中的保留字，在目前版本的 Java 中没有使用。 final 有什么用？用于修饰类、属性和方法； 被final修饰的类不可以被继承 被final修饰的方法不可以被重写 被final修饰的变量不可以被改变，被final修饰不可变的是变量的引用，而不是引用指向的内容，引用指向的内容是可以改变的 final finally finalize区别 final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。 finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。 finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，该方法一般由垃圾回收器来调用，当我们调用System.gc() 方法的时候，由垃圾回收器调用finalize()，回收垃圾，一个对象是否可回收的最后判断。 this关键字的用法this是自身的一个对象，代表对象本身，可以理解为：指向对象本身的一个指针。 this的用法在java中大体可以分为3种： 1.普通的直接引用，this相当于是指向当前对象本身。 2.形参与成员名字重名，用this来区分： 1234public Person(String name, int age) &#123; this.name = name; this.age = age;&#125; 3.引用本类的构造函数 123456789101112131415class Person&#123; private String name; private int age; public Person() &#123; &#125; public Person(String name) &#123; this.name = name; &#125; public Person(String name, int age) &#123; this(name); this.age = age; &#125;&#125; super关键字的用法super可以理解为是指向自己超（父）类对象的一个指针，而这个超类指的是离自己最近的一个父类。 super也有三种用法： 1.普通的直接引用 与this类似，super相当于是指向当前对象的父类的引用，这样就可以用super.xxx来引用父类的成员。 2.子类中的成员变量或方法与父类中的成员变量或方法同名时，用super进行区分 123456789101112131415161718192021222324252627282930class Person&#123; protected String name; public Person(String name) &#123; this.name = name; &#125; &#125; class Student extends Person&#123; private String name; public Student(String name, String name1) &#123; super(name); this.name = name1; &#125; public void getInfo()&#123; System.out.println(this.name); //Child System.out.println(super.name); //Father &#125; &#125;public class Test &#123; public static void main(String[] args) &#123; Student s1 = new Student(\"Father\",\"Child\"); s1.getInfo(); &#125;&#125; 3.引用父类构造函数 3、引用父类构造函数 super（参数）：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。 this（参数）：调用本类中另一种形式的构造函数（应该为构造函数中的第一条语句）。 this与super的区别 super: 它引用当前对象的直接父类中的成员（用来访问直接父类中被隐藏的父类中成员数据或函数，基类与派生类中有相同成员定义时如：super.变量名 super.成员函数据名（实参） this：它代表当前对象名（在程序中易产生二义性之处，应使用this来指明当前对象；如果函数的形参与类中的成员数据同名，这时需用this来指明成员变量名） super()和this()类似,区别是，super()在子类中调用父类的构造方法，this()在本类内调用本类的其它构造方法。 super()和this()均需放在构造方法内第一行。 尽管可以用this调用一个构造器，但却不能调用两个。 this和super不能同时出现在一个构造函数里面，因为this必然会调用其它的构造函数，其它的构造函数必然也会有super语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。 this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块。 从本质上讲，this是一个指向本对象的指针, 然而super是一个Java关键字。 static存在的主要意义static的主要意义是在于创建独立于具体对象的域变量或者方法。以致于即使没有创建对象，也能使用属性和调用方法！ static关键字还有一个比较关键的作用就是 用来形成静态代码块以优化程序性能。static块可以置于类中的任何地方，类中可以有多个static块。在类初次被加载的时候，会按照static块的顺序来执行每个static块，并且只会执行一次。 为什么说static块可以用来优化程序性能，是因为它的特性:只会在类加载的时候执行一次。因此，很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行。 static的独特之处1、被static修饰的变量或者方法是独立于该类的任何对象，也就是说，这些变量和方法不属于任何一个实例对象，而是被类的实例对象所共享。 怎么理解 “被类的实例对象所共享” 这句话呢？就是说，一个类的静态成员，它是属于大伙的【大伙指的是这个类的多个对象实例，我们都知道一个类可以创建多个实例！】，所有的类对象共享的，不像成员变量是自个的【自个指的是这个类的单个实例对象】…我觉得我已经讲的很通俗了，你明白了咩？ 2、在该类被第一次加载的时候，就会去加载被static修饰的部分，而且只在类第一次使用时加载并进行初始化，注意这是第一次用就要初始化，后面根据需要是可以再次赋值的。 3、static变量值在类加载的时候分配空间，以后创建类对象的时候不会重新分配。赋值的话，是可以任意赋值的！ 4、被static修饰的变量或者方法是优先于对象存在的，也就是说当一个类加载完毕之后，即便没有创建对象，也可以去访问。 static应用场景因为static是被类的实例对象所共享，因此如果某个成员变量是被所有对象所共享的，那么这个成员变量就应该定义为静态变量。 因此比较常见的static应用场景有： 1、修饰成员变量 2、修饰成员方法 3、静态代码块 4、修饰类【只能修饰内部类也就是静态内部类】 5、静态导包 static注意事项1、静态只能访问静态。2、非静态既可以访问非静态的，也可以访问静态的。 流程控制语句break ,continue ,return 的区别及作用break 跳出总上一层循环，不再执行循环(结束当前的循环体) continue 跳出本次循环，继续执行下次循环(结束正在执行的循环 进入下一个循环条件) return 程序返回，不再执行下面的代码(结束当前的方法 直接返回) 在 Java 中，如何跳出当前的多重嵌套循环在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如： 123456789101112public static void main(String[] args) &#123; ok: for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; 10; j++) &#123; System.out.println(\"i=\" + i + \",j=\" + j); if (j == 5) &#123; break ok; &#125; &#125; &#125;&#125; 面向过程： 优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点：没有面向对象易维护、易复用、易扩展 面向对象优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点：性能比面向过程低 面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现。 面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。需要什么功能直接使用就可以了，不必去一步一步的实现，至于这个功能是如何实现的，管我们什么事？我们会用就可以了。 面向对象的底层其实还是面向过程，把面向过程抽象成类，然后封装，方便我们使用的就是面向对象了。 面向对象的特征主要有以下几个方面： 抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。 封装：封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。 继承：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 关于继承如下 3 点请记住： 子类拥有父类非 private 的属性和方法。 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。（以后介绍）。 多态 所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。 多态性：父类或接口定义的引用变量可以指向子类或具体实现类的实例对象。提高了程序的拓展性。 在Java中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。 方法重载（overload）实现的是编译时的多态性（也称为前绑定），而方法重写（override）实现的是运行时的多态性（也称为后绑定）。 一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事： 方法重写（子类继承父类并重写父类中已有的或抽象的方法）； 对象造型（用父类型引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）。 什么是多态机制？Java语言是如何实现多态的？所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是多态性。 多态分为编译时多态和运行时多态。其中编辑时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。 多态的实现 Java实现多态有三个必要条件：继承、重写、向上转型。 继承：在多态中必须存在有继承关系的子类和父类。 重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。 向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才能够具备技能调用父类的方法和子类的方法。 只有满足了上述三个条件，我们才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而达到执行不同的行为。 对于Java而言，它多态的实现机制遵循一个原则：当超类对象引用变量引用子类对象时，被引用对象的类型而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 面向对象五大基本原则是什么（可选） 单一职责原则SRP(Single Responsibility Principle)类的功能要单一，不能包罗万象，跟杂货铺似的。 开放封闭原则OCP(Open－Close Principle)一个模块对于拓展是开放的，对于修改是封闭的，想要增加功能热烈欢迎，想要修改，哼，一万个不乐意。 里式替换原则LSP(the Liskov Substitution Principle LSP)子类可以替换父类出现在父类能够出现的任何地方。比如你能代表你爸去你姥姥家干活。哈哈~~ 依赖倒置原则DIP(the Dependency Inversion Principle DIP)高层次的模块不应该依赖于低层次的模块，他们都应该依赖于抽象。抽象不应该依赖于具体实现，具体实现应该依赖于抽象。就是你出国要说你是中国人，而不能说你是哪个村子的。比如说中国人是抽象的，下面有具体的xx省，xx市，xx县。你要依赖的抽象是中国人，而不是你是xx村的。 接口分离原则ISP(the Interface Segregation Principle ISP)设计时采用多个与特定客户类有关的接口比采用一个通用的接口要好。就比如一个手机拥有打电话，看视频，玩游戏等功能，把这几个功能拆分成不同的接口，比在一个接口里要好的多。 类与接口抽象类和接口的对比抽象类是用来捕捉子类的通用特性的。接口是抽象方法的集合。 从设计层面来说，抽象类是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。 相同点 接口和抽象类都不能实例化 都位于继承的顶端，用于被其他实现或继承 都包含抽象方法，其子类都必须覆写这些抽象方法 不同点 参数 抽象类 接口 声明 抽象类使用abstract关键字声明 接口使用interface关键字声明 实现 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 访问修饰符 抽象类中的方法可以是任意访问修饰符 接口方法默认修饰符是public。并且不允许定义为 private 或者 protected 多继承 一个类最多只能继承一个抽象类 一个类可以实现多个接口 字段声明 抽象类的字段声明可以是任意的 接口的字段默认都是 static 和 final 的 备注：Java8中接口中引入默认方法和静态方法，以此来减少抽象类和接口之间的差异。 现在，我们可以为接口提供默认实现的方法了，并且不用强制子类来实现它。 接口和抽象类各有优缺点，在接口和抽象类的选择上，必须遵守这样一个原则： 行为模型应该总是通过接口而不是抽象类定义，所以通常是优先选用接口，尽量少用抽象类。 选择抽象类的时候通常是如下情况：需要定义子类的行为，又要为子类提供通用的功能。 普通类和抽象类有哪些区别？ 普通类不能包含抽象方法，抽象类可以包含抽象方法。 抽象类不能直接实例化，普通类可以直接实例化。 抽象类能使用 final 修饰吗？不能，定义抽象类就是让其他类继承的，如果定义为 final 该类就不能被继承，这样彼此就会产生矛盾，所以 final 不能修饰抽象类 创建一个对象用什么关键字？对象实例与对象引用有何不同？new关键字，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指向它（可以用n条绳子系住一个气球） 变量与方法成员变量与局部变量的区别有哪些变量：在程序执行的过程中，在某个范围内其值可以发生改变的量。从本质上讲，变量其实是内存中的一小块区域 成员变量：方法外部，类内部定义的变量 局部变量：类的方法中的变量。 成员变量和局部变量的区别 作用域 成员变量：针对整个类有效。局部变量：只在某个范围内有效。(一般指的就是方法,语句体内) 存储位置 成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。 生命周期 成员变量：随着对象的创建而存在，随着对象的消失而消失局部变量：当方法调用完，或者语句结束后，就自动释放。 初始值 成员变量：有默认初始值。 局部变量：没有默认初始值，使用前必须赋值。 使用原则 在使用变量时需要遵循的原则为：就近原则首先在局部范围找，有就使用；接着在成员位置找。 在Java中定义一个不做事且没有参数的构造方法的作用Java程序在执行子类的构造方法之前，如果没有用super()来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用super()来调用父类中特定的构造方法，则编译时将发生错误，因为Java程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。 在调用子类构造方法之前会先调用父类没有参数的构造方法，其目的是？帮助子类做初始化工作。 一个类的构造方法的作用是什么？若一个类没有声明构造方法，改程序能正确执行吗？为什么？主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。 构造方法有哪些特性？名字与类名相同； 没有返回值，但不能用void声明构造函数； 生成类的对象时自动执行，无需调用。 静态变量和实例变量区别静态变量：静态变量由于不属于任何实例对象，属于类的，所以在内存中只会有一份，在类的加载过程中，JVM只为静态变量分配一次内存空间。 实例变量：每次创建对象，都会为每个对象分配成员变量内存空间，实例变量是属于实例对象的，在内存中，创建几次对象，就有几份成员变量。 静态变量与普通变量区别static变量也称作静态变量，静态变量和非静态变量的区别是：静态变量被所有的对象所共享，在内存中只有一个副本，它当且仅当在类初次加载时会被初始化。而非静态变量是对象所拥有的，在创建对象的时候被初始化，存在多个副本，各个对象拥有的副本互不影响。 还有一点就是static成员变量的初始化顺序按照定义的顺序进行初始化。 静态方法和实例方法有何不同？静态方法和实例方法的区别主要体现在两个方面： 在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制 在一个静态方法内调用一个非静态成员为什么是非法的？由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。 什么是方法的返回值？返回值的作用是什么？方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！ 内部类什么是内部类？在Java中，可以将一个类的定义放在另外一个类的定义内部，这就是内部类。内部类本身就是类的一个属性，与其他属性定义方式一致。 内部类的分类有哪些内部类可以分为四种：成员内部类、局部内部类、匿名内部类和静态内部类。 静态内部类定义在类内部的静态类，就是静态内部类。 12345678910public class Outer &#123; private static int radius = 1; static class StaticInner &#123; public void visit() &#123; System.out.println(\"visit outer static variable:\" + radius); &#125; &#125;&#125; 静态内部类可以访问外部类所有的静态变量，而不可访问外部类的非静态变量；静态内部类的创建方式，new 外部类.静态内部类()，如下： 12Outer.StaticInner inner = new Outer.StaticInner();inner.visit(); 成员内部类定义在类内部，成员位置上的非静态类，就是成员内部类。 123456789101112public class Outer &#123; private static int radius = 1; private int count =2; class Inner &#123; public void visit() &#123; System.out.println(\"visit outer static variable:\" + radius); System.out.println(\"visit outer variable:\" + count); &#125; &#125;&#125; 成员内部类可以访问外部类所有的变量和方法，包括静态和非静态，私有和公有。成员内部类依赖于外部类的实例，它的创建方式外部类实例.new 内部类()，如下： 123Outer outer = new Outer();Outer.Inner inner = outer.new Inner();inner.visit(); 局部内部类定义在方法中的内部类，就是局部内部类。 123456789101112131415161718192021222324252627282930public class Outer &#123; private int out_a = 1; private static int STATIC_b = 2; public void testFunctionClass()&#123; int inner_c =3; class Inner &#123; private void fun()&#123; System.out.println(out_a); System.out.println(STATIC_b); System.out.println(inner_c); &#125; &#125; Inner inner = new Inner(); inner.fun(); &#125; public static void testStaticFunctionClass()&#123; int d =3; class Inner &#123; private void fun()&#123; // System.out.println(out_a); 编译错误，定义在静态方法中的局部类不可以访问外部类的实例变量 System.out.println(STATIC_b); System.out.println(d); &#125; &#125; Inner inner = new Inner(); inner.fun(); &#125;&#125; 定义在实例方法中的局部类可以访问外部类的所有变量和方法，定义在静态方法中的局部类只能访问外部类的静态变量和方法。局部内部类的创建方式，在对应方法内，new 内部类()，如下： 12345public static void testStaticFunctionClass()&#123; class Inner &#123; &#125; Inner inner = new Inner();&#125; 匿名内部类匿名内部类就是没有名字的内部类，日常开发中使用的比较多。 12345678910111213141516public class Outer &#123; private void test(final int i) &#123; new Service() &#123; public void method() &#123; for (int j = 0; j &lt; i; j++) &#123; System.out.println(\"匿名内部类\" ); &#125; &#125; &#125;.method(); &#125; &#125; //匿名内部类必须继承或实现一个已有的接口 interface Service&#123; void method();&#125; 除了没有名字，匿名内部类还有以下特点： 匿名内部类必须继承一个抽象类或者实现一个接口。 匿名内部类不能定义任何静态成员和静态方法。 当所在的方法的形参需要被匿名内部类使用时，必须声明为 final。 匿名内部类不能是抽象的，它必须要实现继承的类或者实现的接口的所有抽象方法。 匿名内部类创建方式： 123new 类/接口&#123; //匿名内部类实现部分&#125; 内部类的优点我们为什么要使用内部类呢？因为它有以下优点： 一个内部类对象可以访问创建它的外部类对象的内容，包括私有数据！ 内部类不为同一包的其他类所见，具有很好的封装性； 内部类有效实现了“多重继承”，优化 java 单继承的缺陷。 匿名内部类可以很方便的定义回调。 内部类有哪些应用场景 一些多算法场合 解决一些非面向对象的语句块。 适当使用内部类，使得代码更加灵活和富有扩展性。 当某个类除了它的外部类，不再被其他的类使用时。 局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final？局部内部类和匿名内部类访问局部变量的时候，为什么变量必须要加上final呢？它内部原理是什么呢？ 先看这段代码： 123456789101112public class Outer &#123; void outMethod()&#123; final int a =10; class Inner &#123; void innerMethod()&#123; System.out.println(a); &#125; &#125; &#125;&#125; 以上例子，为什么要加final呢？是因为生命周期不一致， 局部变量直接存储在栈中，当方法执行结束后，非final的局部变量就被销毁。而局部内部类对局部变量的引用依然存在，如果局部内部类要调用局部变量时，就会出错。加了final，可以确保局部内部类使用的变量与外层的局部变量区分开，解决了这个问题。 内部类相关，看程序说出运行结果12345678910111213141516171819public class Outer &#123; private int age = 12; class Inner &#123; private int age = 13; public void print() &#123; int age = 14; System.out.println(\"局部变量：\" + age); System.out.println(\"内部类变量：\" + this.age); System.out.println(\"外部类变量：\" + Outer.this.age); &#125; &#125; public static void main(String[] args) &#123; Outer.Inner in = new Outer().new Inner(); in.print(); &#125;&#125; 运行结果： 123局部变量：14内部类变量：13外部类变量：12 重写与重载构造器（constructor）是否可被重写（override）构造器不能被继承，因此不能被重写，但可以被重载。 重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？方法的重载和重写都是实现多态的方式，区别在于前者实现的是编译时的多态性，而后者实现的是运行时的多态性。 重载：发生在同一个类中，方法名相同参数列表不同（参数类型不同、个数不同、顺序不同），与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分 重写：发生在父子类中，方法名、参数列表必须相同，返回值小于等于父类，抛出的异常小于等于父类，访问修饰符大于等于父类（里氏代换原则）；如果父类方法访问修饰符为private则子类中就不是重写。 对象相等判断== 和 equals 的区别是什么== : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象。(基本数据类型 == 比较的是值，引用数据类型 == 比较的是内存地址) equals() : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况： 情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。 *举个例子：* 1234567891011121314151617public class test1 &#123; public static void main(String[] args) &#123; String a = new String(\"ab\"); // a 为一个引用 String b = new String(\"ab\"); // b为另一个引用,对象的内容一样 String aa = \"ab\"; // 放在常量池中 String bb = \"ab\"; // 从常量池中查找 if (aa == bb) // true System.out.println(\"aa==bb\"); if (a == b) // false，非同一对象 System.out.println(\"a==b\"); if (a.equals(b)) // true System.out.println(\"aEQb\"); if (42 == 42.0) &#123; // true System.out.println(\"true\"); &#125; &#125;&#125; 说明： String中的equals方法是被重写过的，因为object的equals方法是比较的对象的内存地址，而String的equals方法比较的是对象的值。 当创建String类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个String对象。 hashCode 与 equals (重要)HashSet如何检查重复 两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？ hashCode和equals方法的关系 面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？” hashCode()介绍 hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在JDK的Object.java中，这就意味着Java中的任何类都包含有hashCode()函数。 散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象） 为什么要有 hashCode 我们以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode： 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals()方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。 hashCode()与equals()的相关规定 如果两个对象相等，则hashcode一定也是相同的 两个对象相等，对两个对象分别调用equals方法都返回true 两个对象有相同的hashcode值，它们也不一定是相等的 因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖 hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据） 对象的相等与指向他们的引用相等，两者有什么不同？对象的相等 比的是内存中存放的内容是否相等而 引用相等 比较的是他们指向的内存地址是否相等。 值传递当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递是值传递。Java 语言的方法调用只支持参数的值传递。当一个对象实例作为一个参数被传递到方法中时，参数的值就是对该对象的引用。对象的属性可以在被调用过程中被改变，但对对象引用的改变是不会影响到调用者的 为什么 Java 中只有值传递首先回顾一下在程序设计语言中有关将参数传递给方法（或函数）的一些专业术语。按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。 Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。 下面通过 3 个例子来给大家说明 example 1 123456789101112131415161718public static void main(String[] args) &#123; int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(\"num1 = \" + num1); System.out.println(\"num2 = \" + num2);&#125;public static void swap(int a, int b) &#123; int temp = a; a = b; b = temp; System.out.println(\"a = \" + a); System.out.println(\"b = \" + b);&#125; 结果： 1234a &#x3D; 20b &#x3D; 10num1 &#x3D; 10num2 &#x3D; 20 在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看 example2. example 2 1234567891011public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; System.out.println(arr[0]); change(arr); System.out.println(arr[0]); &#125; public static void change(int[] array) &#123; // 将数组的第一个元素变为0 array[0] = 0; &#125; 结果： 1210 解析： array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。因此，外部对引用对象的改变会反映到所对应的对象上。 通过 example2 我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。 很多程序设计语言（特别是，C++和Pascal)提供了两种参数传递的方式：值调用和引用调用。有些程序员（甚至本书的作者）认为Java程序设计语言对对象采用的是引用调用，实际上，这种理解是不对的。由于这种误解具有一定的普遍性，所以下面给出一个反例来详细地阐述一下这个问题。 example 3 12345678910111213141516171819public class Test &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub Student s1 = new Student(\"小张\"); Student s2 = new Student(\"小李\"); Test.swap(s1, s2); System.out.println(\"s1:\" + s1.getName()); System.out.println(\"s2:\" + s2.getName()); &#125; public static void swap(Student x, Student y) &#123; Student temp = x; x = y; y = temp; System.out.println(\"x:\" + x.getName()); System.out.println(\"y:\" + y.getName()); &#125;&#125; 结果： 1234x:小李y:小张s1:小张s2:小李 解析： 交换之前： 通过上面两张图可以很清晰的看出： 方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝 总结Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。 下面再总结一下Java中方法参数的使用情况： 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型》 一个方法可以改变一个对象参数的状态。 一个方法不能让对象参数引用一个新的对象。 值传递和引用传递有什么区别值传递：指的是在方法调用时，传递的参数是按值的拷贝传递，传递的是值的拷贝，也就是说传递后就互不相关了。 引用传递：指的是在方法调用时，传递的参数是按引用进行传递，其实传递的引用的地址，也就是变量所对应的内存空间的地址。传递的是值的引用，也就是说传递前和传递后都指向同一个引用（也就是同一个内存空间）。 Java包JDK 中常用的包有哪些 java.lang：这个是系统的基础类； java.io：这里面是所有输入输出有关的类，比如文件操作等； java.nio：为了完善 io 包中的功能，提高 io 包中性能而写的一个新包； java.net：这里面是与网络有关的类； java.util：这个是系统辅助类，特别是集合类； java.sql：这个是数据库操作的类。 import java和javax有什么区别刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来说使用。然而随着时间的推移，javax 逐渐的扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包将是太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准API的一部分。 所以，实际上java和javax没有区别。这都是一个名字。 IO流java 中 IO 流分为几种? 按照流的流向分，可以分为输入流和输出流； 按照操作单元划分，可以划分为字节流和字符流； 按照流的角色划分为节点流和处理流。 Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。 InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。 OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。 按操作方式分类结构图： 按操作对象分类结构图： BIO,NIO,AIO 有什么区别?简答 BIO：Block IO 同步阻塞式 IO，就是我们平常使用的传统 IO，它的特点是模式简单使用方便，并发处理能力低。 NIO：Non IO 同步非阻塞 IO，是传统 IO 的升级，客户端和服务器端通过 Channel（通道）通讯，实现了多路复用。 AIO：Asynchronous IO 是 NIO 的升级，也叫 NIO2，实现了异步非堵塞 IO ，异步 IO 的操作基于事件和回调机制。 详细回答 BIO (Blocking I/O): 同步阻塞I/O模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。 NIO (New I/O): NIO是一种同步非阻塞的I/O模型，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。它支持面向缓冲的，基于通道的I/O操作方法。NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发 AIO (Asynchronous I/O): AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。 Files的常用方法都有哪些？ Files. exists()：检测文件路径是否存在。 Files. createFile()：创建文件。 Files. createDirectory()：创建文件夹。 Files. delete()：删除一个文件或目录。 Files. copy()：复制文件。 Files. move()：移动文件。 Files. size()：查看文件个数。 Files. read()：读取文件。 Files. write()：写入文件。 反射什么是反射机制？JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 静态编译和动态编译 静态编译：在编译时确定类型，绑定对象 动态编译：运行时确定类型，绑定对象 反射机制优缺点 优点： 运行期类型的判断，动态加载类，提高代码灵活度。 缺点： 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。 反射机制的应用场景有哪些？反射是框架设计的灵魂。 在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。 举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中; 2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性 Java获取反射的三种方法1.通过new对象实现反射机制 2.通过路径实现反射机制 3.通过类名实现反射机制 123456789101112131415161718192021public class Student &#123; private int id; String name; protected boolean sex; public float score;&#125;public class Get &#123; //获取反射机制三种方式 public static void main(String[] args) throws ClassNotFoundException &#123; //方式一(通过建立对象) Student stu = new Student(); Class classobj1 = stu.getClass(); System.out.println(classobj1.getName()); //方式二（所在通过路径-相对路径） Class classobj2 = Class.forName(\"fanshe.Student\"); System.out.println(classobj2.getName()); //方式三（通过类名） Class classobj3 = Student.class; System.out.println(classobj3.getName()); &#125;&#125; 网络编程网络编程的面试题可以查看我的这篇文章重学TCP/IP协议和三次握手四次挥手，内容不仅包括TCP/IP协议和三次握手四次挥手的知识，还包括计算机网络体系结构，HTTP协议，get请求和post请求区别，session和cookie的区别等，欢迎大家阅读。 常用APIString相关字符型常量和字符串常量的区别 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符 含义上: 字符常量相当于一个整形值(ASCII值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占一个字节 字符串常量占若干个字节(至少一个字符结束标志) 什么是字符串常量池？字符串常量池位于堆内存中，专门用来存储字符串常量，可以提高内存的使用率，避免开辟多块空间存储相同的字符串，在创建字符串时 JVM 会首先检查字符串常量池，如果该字符串已经存在池中，则返回它的引用，如果不存在，则实例化一个字符串放到池中，并返回其引用。 String 是最基本的数据类型吗不是。Java 中的基本数据类型只有 8 个 ：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。 这是很基础的东西，但是很多初学者却容易忽视，Java 的 8 种基本数据类型中不包括 String，基本数据类型中用来描述文本数据的是 char，但是它只能表示单个字符，比如 ‘a’,‘好’ 之类的，如果要描述一段文本，就需要用多个 char 类型的变量，也就是一个 char 类型数组，比如“你好” 就是长度为2的数组 char[] chars = {‘你’,‘好’}; 但是使用数组过于麻烦，所以就有了 String，String 底层就是一个 char 类型的数组，只是使用的时候开发者不需要直接操作底层数组，用更加简便的方式即可完成对字符串的使用。 String有哪些特性 不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并频繁访问时，可以保证数据的一致性。 常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时，会直接返回缓存的引用。 final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。 String为什么是不可变的吗？简单来说就是String类利用了final修饰的char类型数组存储字符，源码如下图所以： 12/** The value is used for character storage. */private final char value[]; String真的是不可变的吗？ 我觉得如果别人问这个问题的话，回答不可变就可以了。下面只是给大家看两个有代表性的例子： 1) String不可变但不代表引用不可以变 12345String str = \"Hello\";str = str + \" World\";System.out.println(\"str=\" + str);结果：str=Hello World 解析： 实际上，原来String的内容是不变的，只是str由原来指向”Hello”的内存地址转为指向”Hello World”的内存地址而已，也就是说多开辟了一块内存区域给”Hello World”字符串。 2) 通过反射是可以修改所谓的“不可变”对象 12345678910111213141516171819202122// 创建字符串\"Hello World\"， 并赋给引用sString s = \"Hello World\";System.out.println(\"s = \" + s); // Hello World// 获取String类中的value字段Field valueFieldOfString = String.class.getDeclaredField(\"value\");// 改变value属性的访问权限valueFieldOfString.setAccessible(true);// 获取s对象上的value属性的值char[] value = (char[]) valueFieldOfString.get(s);// 改变value所引用的数组中的第5个字符value[5] = '_';System.out.println(\"s = \" + s); // Hello_World结果：s = Hello Worlds = Hello_World 解析： 用反射可以访问私有成员， 然后反射出String对象中的value属性， 进而改变通过获得的value引用改变数组的结构。但是一般我们不会这么做，这里只是简单提一下有这个东西。 是否可以继承 String 类String 类是 final 类，不可以被继承。 String str=”i”与 String str=new String(“i”)一样吗？不一样，因为内存的分配方式不一样。String str=”i”的方式，java 虚拟机会将其分配到常量池中；而 String str=new String(“i”) 则会被分到堆内存中。 String s = new String(“xyz”);创建了几个字符串对象两个对象，一个是静态区的”xyz”，一个是用new创建在堆上的对象。 123456789101112String str1 = \"hello\"; //str1指向静态区String str2 = new String(\"hello\"); //str2指向堆上的对象String str3 = \"hello\";String str4 = new String(\"hello\");System.out.println(str1.equals(str2)); //trueSystem.out.println(str2.equals(str4)); //trueSystem.out.println(str1 == str3); //trueSystem.out.println(str1 == str2); //falseSystem.out.println(str2 == str4); //falseSystem.out.println(str2 == \"hello\"); //falsestr2 = str1;System.out.println(str2 == \"hello\"); //true 如何将字符串反转？ 使用 StringBuilder 或者 stringBuffer 的 reverse() 方法。 示例代码： 12345678// StringBuffer reverseStringBuffer stringBuffer = new StringBuffer();stringBuffer. append(\"abcdefg\");System. out. println(stringBuffer. reverse()); // gfedcba// StringBuilder reverseStringBuilder stringBuilder = new StringBuilder();stringBuilder. append(\"abcdefg\");System. out. println(stringBuilder. reverse()); // gfedcba 数组有没有 length()方法？String 有没有 length()方法 数组没有 length()方法 ，有 length 的属性。String 有 length()方法。JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。 String 类的常用方法都有那些？ indexOf()：返回指定字符的索引。 charAt()：返回指定索引处的字符。 replace()：字符串替换。 trim()：去除字符串两端空白。 split()：分割字符串，返回一个分割后的字符串数组。 getBytes()：返回字符串的 byte 类型数组。 length()：返回字符串长度。 toLowerCase()：将字符串转成小写字母。 toUpperCase()：将字符串转成大写字符。 substring()：截取字符串。 equals()：字符串比较。 在使用 HashMap 的时候，用 String 做 key 有什么好处？HashMap 内部实现是通过 key 的 hashcode 来确定 value 的存储位置，因为字符串是不可变的，所以当创建字符串时，它的 hashcode 被缓存下来，不需要再次计算，所以相比于其他对象更快。 String和StringBuffer、StringBuilder的区别是什么？String为什么是不可变的可变性 String类中使用字符数组保存字符串，private final char value[]，所以string对象是不可变的。StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，char[] value，这两种对象都是可变的。 线程安全性 String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。 性能 每次对String 类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String 对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StirngBuilder 相比使用StringBuffer 仅能获得10%~15% 左右的性能提升，但却要冒多线程不安全的风险。 对于三者使用的总结 如果要操作少量的数据用 = String 单线程操作字符串缓冲区 下操作大量数据 = StringBuilder 多线程操作字符串缓冲区 下操作大量数据 = StringBuffer Date相关包装类相关自动装箱与拆箱装箱：将基本类型用它们对应的引用类型包装起来； 拆箱：将包装类型转换为基本数据类型； int 和 Integer 有什么区别Java 是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java 为每一个基本数据类型都引入了对应的包装类型（wrapper class），int 的包装类就是 Integer，从 Java 5 开始引入了自动装箱/拆箱机制，使得二者可以相互转换。 Java 为每个原始类型提供了包装类型**：** 原始类型: boolean，char，byte，short，int，long，float，double 包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double Integer a= 127 与 Integer b = 127相等吗对于对象引用类型：==比较的是对象的内存地址。对于基本数据类型：==比较的是值。 如果整型字面量的值在-128到127之间，那么自动装箱时不会new新的Integer对象，而是直接引用常量池中的Integer对象，超过范围 a1==b1的结果是false 12345678910111213141516public static void main(String[] args) &#123; Integer a = new Integer(3); Integer b = 3; // 将3自动装箱成Integer类型 int c = 3; System.out.println(a == b); // false 两个引用没有引用同一对象 System.out.println(a == c); // true a自动拆箱成int类型再和c比较 System.out.println(b == c); // true Integer a1 = 128; Integer b1 = 128; System.out.println(a1 == b1); // false Integer a2 = 127; Integer b2 = 127; System.out.println(a2 == b2); // true&#125;","categories":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"工作流","slug":"工作流","date":"2020-07-03T08:25:36.000Z","updated":"2020-07-03T08:38:09.471Z","comments":true,"path":"2020/07/03/工作流/","link":"","permalink":"https://conanisbest.github.io/2020/07/03/%E5%B7%A5%E4%BD%9C%E6%B5%81/","excerpt":"","text":"博主更新中…","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"解决java导出文件时文件名中文不显示/乱码","slug":"five","date":"2020-07-02T07:39:23.000Z","updated":"2020-07-14T03:30:07.299Z","comments":true,"path":"2020/07/02/five/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/five/","excerpt":"","text":"解决java导出文件时文件名中文不显示/乱码 直接把中文文件名改为iso-8859-1就可以了~ response.setHeader(“Content-Disposition”, “attachment;filename=” + new String(fileName.getBytes(),”iso-8859-1”) + “.xls”);","categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}],"tags":[{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"}]},{"title":"hibernate工作原理及作用","slug":"four","date":"2020-07-02T07:30:06.000Z","updated":"2020-07-14T03:29:34.885Z","comments":true,"path":"2020/07/02/four/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/four/","excerpt":"","text":"hibernate工作原理及作用 转载自 http://www.cnblogs.com/dashi/p/3597969.html#commentform JAVA Hibernate工作原理及为什么要用 hibernate 简介： hibernate是一个开源框架，它是对象关联关系映射的框架，它对JDBC做了轻量级的封装，而我们java程序员可以使用面向对象的思想来操纵数据库。 hibernate核心接口 session：负责被持久化对象CRUD操作 sessionFactory:负责初始化hibernate，创建session对象 configuration:负责配置并启动hibernate，创建SessionFactory Transaction:负责事物相关的操作 Query和Criteria接口：负责执行各种数据库查询 hibernate工作原理： 1.通过Configuration config = new Configuration().configure();//读取并解析hibernate.cfg.xml配置文件 2.由hibernate.cfg.xml中的读取并解析映射信息 3.通过SessionFactory sf = config.buildSessionFactory();//创建SessionFactory 4.Session session = sf.openSession();//打开Sesssion 5.Transaction tx = session.beginTransaction();//创建并启动事务Transation 6.persistent operate操作数据，持久化操作 7.tx.commit();//提交事务 8.关闭Session 9.关闭SesstionFactory 为什么要用hibernate： \\1. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 \\2. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 \\3. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 \\4. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。 Hibernate是如何延迟加载?get与load的区别 \\1. 对于Hibernate get方法，Hibernate会确认一下该id对应的数据是否存在，首先在session缓存中查找，然后在二级缓存中查找，还没有就查询数据库，数据 库中没有就返回null。这个相对比较简单，也没有太大的争议。主要要说明的一点就是在这个版本(bibernate3.2以上)中get方法也会查找二级缓存！ \\2. Hibernate load方法加载实体对象的时候，根据映射文件上类级别的lazy属性的配置(默认为true)，分情况讨论： (1)若为true,则首先在Session缓存中查找，看看该id对应的对象是否存在，不存在则使用延迟加载，返回实体的代理类对象(该代理类为实体类的子类，由CGLIB动态生成)。等到具体使用该对象(除获取OID以外)的时候，再查询二级缓存和数据库，若仍没发现符合条件的记录，则会抛出一个ObjectNotFoundException。 (2)若为false,就跟Hibernateget方法查找顺序一样，只是最终若没发现符合条件的记录，则会抛出一个ObjectNotFoundException。 这里get和load有两个重要区别: 如果未能发现符合条件的记录，Hibernate get方法返回null，而load方法会抛出一个ObjectNotFoundException。 load方法可返回没有加载实体数据的代 理类实例，而get方法永远返回有实体数据的对象。 (对于load和get方法返回类型：好多书中都说：“get方法永远只返回实体类”，实际上并不正 确，get方法如果在session缓存中找到了该id对应的对象，如果刚好该对象前面是被代理过的，如被load方法使用过，或者被其他关联对象延迟加 载过，那么返回的还是原先的代理对象，而不是实体类对象，如果该代理对象还没有加载实体数据（就是id以外的其他属性数据），那么它会查询二级缓存或者数 据库来加载数据，但是返回的还是代理对象，只不过已经加载了实体数据。) 总之对于get和load的根本区别，一句话，hibernate对于 load方法认为该数据在数据库中一定存在，可以放心的使用代理来延迟加载，如果在使用过程中发现了问题，只能抛异常；而对于get方 法，hibernate一定要获取到真实的数据，否则返回null。 Hibernate中怎样实现类之间的关系?(如：一对多、多对多的关系) 类与类之间的关系主要体现在表与表之间的关系进行操作，它们都市对对象进行操作，我们程序中把所有的表与类都映射在一起，它们通过配置文件中的many-to-one、one-to-many、many-to-many、 说下Hibernate的缓存机制： Hibernate缓存的作用： Hibernate是一个持久层框架，经常访问物理数据库，为了降低应用程序对物理数据源访问的频次，从而提高应用程序的运行性能。缓存内的数据是对物理数据源中的数据的复制，应用程序在运行时从缓存读写数据，在特定的时刻或事件会同步缓存和物理数据源的数据 Hibernate缓存分类： Hibernate缓存包括两大类：Hibernate一级缓存和Hibernate二级缓存 Hibernate一级缓存又称为“Session的缓存”，它是内置的，意思就是说，只要你使用hibernate就必须使用session缓存。由于Session对象的生命周期通常对应一个数据库事务或者一个应用事务，因此它的缓存是事务范围的缓存。在第一级缓存中，持久化类的每个实例都具有唯一的OID。 Hibernate二级缓存又称为“SessionFactory的缓存”，由于SessionFactory对象的生命周期和应用程序的整个过程对应，因此Hibernate二级缓存是进程范围或者集群范围的缓存，有可能出现并发问题，因此需要采用适当的并发访问策略，该策略为被缓存的数据提供了事务隔离级别。第二级缓存是可选的，是一个可配置的插件，在默认情况下，SessionFactory不会启用这个插件。 什么样的数据适合存放到第二级缓存中？ 1 很少被修改的数据 2 不是很重要的数据，允许出现偶尔并发的数据 3 不会被并发访问的数据 4 常量数据 不适合存放到第二级缓存的数据？ 1经常被修改的数据 2 .绝对不允许出现并发访问的数据，如财务数据，绝对不允许出现并发 3 与其他应用共享的数据。 Hibernate查找对象如何应用缓存？ 当Hibernate根据ID访问数据对象的时候，首先从Session一级缓存中查；查不到，如果配置了二级缓存，那么从二级缓存中查；如果都查不到，再查询数据库，把结果按照ID放入到缓存 删除、更新、增加数据的时候，同时更新缓存 Hibernate管理缓存实例 无论何时，我们在管理Hibernate缓存（Managing the caches）时，当你给save()、update()或saveOrUpdate()方法传递一个对象时，或使用load()、 get()、list()、iterate() 或scroll()方法获得一个对象时, 该对象都将被加入到Session的内部缓存中。 当随后flush()方法被调用时，对象的状态会和数据库取得同步。 如果你不希望此同步操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用evict() 方法，从一级缓存中去掉这些对象及其集合。 Hibernate的查询方式 Sql、Criteria,object comptosition Hql： 1、 属性查询 2、 参数查询、命名参数查询 3、 关联查询 4、 分页查询 5、 统计函数 如何优化Hibernate？ 1.使用双向一对多关联，不使用单向一对多 2.灵活使用单向一对多关联 3.不用一对一，用多对一取代 4.配置对象缓存，不使用集合缓存 5.一对多集合使用Bag,多对多集合使用Set \\6. 继承类使用显式多态 \\7. 表字段要少，表关联不要怕多，有二级缓存撑腰 hibernate的开发步骤： 开发步骤 1)搭建好环境 ​ 引入hibernate最小的jar包 ​ 准备Hibernate.cfg.xml启动配置文件 2)写实体类(pojo) 3)为实体类写映射文件”User.hbm.xml” ​ 在hibernate.cfg.xml添加映射的实体 4)创建库表 5)写测试类 ​ 获得Configuration ​ 创建SessionFactory ​ 打开Session ​ 开启事务 ​ 使用session操作数据 ​ 提交事务 ​ 关闭资源","categories":[{"name":"数据库相关","slug":"数据库相关","permalink":"https://conanisbest.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"}],"tags":[{"name":"hibernate","slug":"hibernate","permalink":"https://conanisbest.github.io/tags/hibernate/"}]},{"title":"JVM 发生 OOM 的 8 种原因、及解决办法","slug":"three","date":"2020-07-02T07:26:13.000Z","updated":"2020-07-14T03:28:47.809Z","comments":true,"path":"2020/07/02/three/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/three/","excerpt":"","text":"JVM 发生 OOM（out of memory 内存溢出） 的 8 种原因、及解决办法 来源：www.importnew.com/author/tangyouhua 1. Java 堆空间 发生频率：5颗星 造成原因 无法在 Java 堆中分配对象 吞吐量增加 应用程序无意中保存了对象引用，对象无法被 GC 回收 应用程序过度使用 finalizer。finalizer 对象不能被 GC 立刻回收。finalizer 由结束队列服务的守护线程调用，有时 finalizer 线程的处理能力无法跟上结束队列的增长 解决方案 使用 -Xmx 增加堆大小 修复应用程序中的内存泄漏 2. GC 开销超过限制 发生频率：5颗星 造成原因 Java 进程98%的时间在进行垃圾回收，恢复了不到2%的堆空间，最后连续5个（编译时常量）垃圾回收一直如此。 解决方案 使用 -Xmx 增加堆大小 使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制 修复应用程序中的内存泄漏 3. 请求的数组大小超过虚拟机限制 发生频率：2颗星 造成原因 应用程序试图分配一个超过堆大小的数组 解决方案 使用 -Xmx 增加堆大小 修复应用程序中分配巨大数组的 bug 4. Perm gen 空间 发生频率：3颗星 造成原因 Perm gen 空间包含： 类的名字、字段、方法 与类相关的对象数组和类型数组 JIT 编译器优化 当 Perm gen 空间用尽时，将抛出异常。 解决方案 使用 -XX: MaxPermSize 增加 Permgen 大小 不重启应用部署应用程序可能会导致此问题。重启 JVM 解决 5. Metaspace 发生频率：3颗星 造成原因 从 Java 8 开始 Perm gen 改成了 Metaspace，在本机内存中分配 class 元数据（称为 metaspace）。如果 metaspace 耗尽，则抛出异常 解决方案 通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小 取消 -XX: maxmetsspacedize 减小 Java 堆大小,为 MetaSpace 提供更多的可用空间 为服务器分配更多的内存 可能是应用程序 bug，修复 bug 6. 无法新建本机线程 发生频率：5颗星 造成原因 内存不足，无法创建新线程。由于线程在本机内存中创建，报告这个错误表明本机内存空间不足 解决方案 为机器分配更多的内存 减少 Java 堆空间 修复应用程序中的线程泄漏。 增加操作系统级别的限制 ulimit -a 用户进程数增大 (-u) 1800 使用 -Xss 减小线程堆栈大小 7. 杀死进程或子进程 发生频率：1颗星 造成原因 内核任务：内存不足结束器，在可用内存极低的情况下会杀死进程 解决方案 将进程迁移到不同的机器上 给机器增加更多内存 与其他 OOM 错误不同，这是由操作系统而非 JVM 触发的。 8. 发生 stack_trace_with_native_method 发生频率：1颗星 造成原因 本机方法（native method）分配失败 打印的堆栈跟踪信息，最顶层的帧是本机方法 解决方案 使用操作系统本地工具进行诊断","categories":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/categories/java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://conanisbest.github.io/tags/JVM/"}]},{"title":"Java多线程学习","slug":"second","date":"2020-07-02T07:18:50.000Z","updated":"2020-07-14T03:28:11.889Z","comments":true,"path":"2020/07/02/second/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/second/","excerpt":"","text":"Java总结篇系列：Java多线程（一） 多线程作为Java中很重要的一个知识点，在此还是有必要总结一下的。 一.线程的生命周期及五种基本状态 关于Java中线程的生命周期，首先看一下下面这张较为经典的图： 上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括： Java线程具有五种基本状态 新建状态（New）：当线程对象对创建后，即进入了新建状态，如：Thread t = new MyThread(); 就绪状态（Runnable）：当调用线程对象的start()方法（t.start();），线程即进入就绪状态。处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行； 运行状态（Running）：当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。注：就绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中； 阻塞状态（Blocked）：处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。根据阻塞产生的原因不同，阻塞状态又可以分为三种： 1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态； 2.同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态； 3.其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。 死亡状态（Dead）：线程执行完了或者因异常退出了run()方法，该线程结束生命周期。 二. Java多线程的创建及启动 Java中线程的创建常见有如三种基本形式 1.继承Thread类，重写该类的run()方法。 1234567891011 1 class MyThread extends Thread &#123; 2 3 private int i = 0; 4 5 @Override 6 public void run() &#123; 7 for (i = 0; i &lt; 100; i++) &#123; 8 System.out.println(Thread.currentThread().getName() + \" \" + i); 9 &#125;10 &#125;11 &#125; 123456789101112131415 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 for (int i = 0; i &lt; 100; i++) &#123; 5 System.out.println(Thread.currentThread().getName() + \" \" + i); 6 if (i == 30) &#123; 7 Th; // 调用start()方法使得线程进入就绪状态11 &#125;12 &#125;13 &#125;14 &#125;read myThread1 = new MyThread(); // 创建一个新的线程 myThread1 此线程进入新建状态 8 Thread myThread2 = new MyThread(); // 创建一个新的线程 myThread2 此线程进入新建状态 9 myThread1.start(); // 调用start()方法使得线程进入就绪状态10 myThread2.start() 如上所示，继承Thread类，通过重写run()方法定义了一个新的线程类MyThread，其中run()方法的方法体代表了线程需要完成的任务，称之为线程执行体。当创建此线程类对象时一个新的线程得以创建，并进入到线程新建状态。通过调用线程对象引用的start()方法，使得该线程进入到就绪状态，此时此线程并不一定会马上得以执行，这取决于CPU调度时机。 2.实现Runnable接口，并重写该接口的run()方法，该run()方法同样是线程执行体，创建Runnable实现类的实例，并以此实例作为Thread类的target来创建Thread对象，该Thread对象才是真正的线程对象。 12345678910 1 class MyRunnable implements Runnable &#123; 2 private int i = 0; 3 4 @Override 5 public void run() &#123; 6 for (i = 0; i &lt; 100; i++) &#123; 7 System.out.println(Thread.currentThread().getName() + \" \" + i); 8 &#125; 9 &#125;10 &#125; 1234567891011121314151 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 for (int i = 0; i &lt; 100; i++) &#123; 5 System.out.println(Thread.currentThread().getName() + \" \" + i); 6 if (i == 30) &#123; 7 Runnable myRunnable = new MyRunnable(); // 创建一个Runnable实现类的对象 8 Thread thread1 = new Thread(myRunnable); // 将myRunnable作为Thread target创建新的线程 9 Thread thread2 = new Thread(myRunnable);10 thread1.start(); // 调用start()方法使得线程进入就绪状态11 thread2.start();12 &#125;13 &#125;14 &#125;15 &#125; 相信以上两种创建新线程的方式大家都很熟悉了，那么Thread和Runnable之间到底是什么关系呢？我们首先来看一下下面这个例子。 123456789101112131415161718192021222324252627282930313233343536373839404142 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 for (int i = 0; i &lt; 100; i++) &#123; 5 System.out.println(Thread.currentThread().getName() + \" \" + i); 6 if (i == 30) &#123; 7 Runnable myRunnable = new MyRunnable(); 8 Thread thread = new MyThread(myRunnable); 9 thread.start();10 &#125;11 &#125;12 &#125;13 &#125;14 15 class MyRunnable implements Runnable &#123;16 private int i = 0;17 18 @Override19 public void run() &#123;20 System.out.println(\"in MyRunnable run\");21 for (i = 0; i &lt; 100; i++) &#123;22 System.out.println(Thread.currentThread().getName() + \" \" + i);23 &#125;24 &#125;25 &#125;26 27 class MyThread extends Thread &#123;28 29 private int i = 0;30 31 public MyThread(Runnable runnable)&#123;32 super(runnable);33 &#125;34 35 @Override36 public void run() &#123;37 System.out.println(\"in MyThread run\");38 for (i = 0; i &lt; 100; i++) &#123;39 System.out.println(Thread.currentThread().getName() + \" \" + i);40 &#125;41 &#125;42 &#125; 同样的，与实现Runnable接口创建线程方式相似，不同的地方在于 11 Thread thread = new MyThread(myRunnable); 那么这种方式可以顺利创建出一个新的线程么？答案是肯定的。至于此时的线程执行体到底是MyRunnable接口中的run()方法还是MyThread类中的run()方法呢？通过输出我们知道线程执行体是MyThread类中的run()方法。其实原因很简单，因为Thread类本身也是实现了Runnable接口，而run()方法最先是在Runnable接口中定义的方法。 123451 public interface Runnable &#123;2 3 public abstract void run();4 5 &#125; 我们看一下Thread类中对Runnable接口中run()方法的实现： 123456 @Overridepublic void run() &#123; if (target != null) &#123; target.run(); &#125;&#125; 也就是说，当执行到Thread类中的run()方法时，会首先判断target是否存在，存在则执行target中的run()方法，也就是实现了Runnable接口并重写了run()方法的类中的run()方法。但是上述给到的列子中，由于多态的存在，根本就没有执行到Thread类中的run()方法，而是直接先执行了运行时类型即MyThread类中的run()方法。 3.使用Callable和Future接口创建线程。具体是创建Callable接口的实现类，并实现clall()方法。并使用FutureTask类来包装Callable实现类的对象，且以此FutureTask对象作为Thread对象的target来创建线程。 看着好像有点复杂，直接来看一个例子就清晰了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 Callable&lt;Integer&gt; myCallable = new MyCallable(); // 创建MyCallable对象 6 FutureTask&lt;Integer&gt; ft = new FutureTask&lt;Integer&gt;(myCallable); //使用FutureTask来包装MyCallable对象 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 Thread thread = new Thread(ft); //FutureTask对象作为Thread对象的target创建新的线程12 thread.start(); //线程进入到就绪状态13 &#125;14 &#125;15 16 System.out.println(\"主线程for循环执行完毕..\");17 18 try &#123;19 int sum = ft.get(); //取得新创建的新线程中的call()方法返回的结果20 System.out.println(\"sum = \" + sum);21 &#125; catch (InterruptedException e) &#123;22 e.printStackTrace();23 &#125; catch (ExecutionException e) &#123;24 e.printStackTrace();25 &#125;26 27 &#125;28 &#125;29 30 31 class MyCallable implements Callable&lt;Integer&gt; &#123;32 private int i = 0;33 34 // 与run()方法不同的是，call()方法具有返回值35 @Override36 public Integer call() &#123;37 int sum = 0;38 for (; i &lt; 100; i++) &#123;39 System.out.println(Thread.currentThread().getName() + \" \" + i);40 sum += i;41 &#125;42 return sum;43 &#125;44 45 &#125; 首先，我们发现，在实现Callable接口中，此时不再是run()方法了，而是call()方法，此call()方法作为线程执行体，同时还具有返回值！在创建新的线程时，是通过FutureTask来包装MyCallable对象，同时作为了Thread对象的target。那么看下FutureTask类的定义： 123451 public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123;2 3 //....4 5 &#125; 123451 public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123;2 3 void run();4 5 &#125; 于是，我们发现FutureTask类实际上是同时实现了Runnable和Future接口，由此才使得其具有Future和Runnable双重特性。通过Runnable特性，可以作为Thread对象的target，而Future特性，使得其可以取得新创建线程中的call()方法的返回值。 执行下此程序，我们发现sum = 4950永远都是最后输出的。而“主线程for循环执行完毕..”则很可能是在子线程循环中间输出。由CPU的线程调度机制，我们知道，“主线程for循环执行完毕..”的输出时机是没有任何问题的，那么为什么sum =4950会永远最后输出呢？ 原因在于通过ft.get()方法获取子线程call()方法的返回值时，当子线程此方法还未执行完毕，ft.get()方法会一直阻塞，直到call()方法执行完毕才能取到返回值。 上述主要讲解了三种常见的线程创建方式，对于线程的启动而言，都是调用线程对象的start()方法，需要特别注意的是：不能对同一线程对象两次调用start()方法。 三. Java多线程的就绪、运行和死亡状态 就绪状态转换为运行状态：当此线程得到处理器资源； 运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。 运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。 此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。 由于实际的业务需要，常常会遇到需要在特定时机终止某一线程的运行，使其进入到死亡状态。目前最通用的做法是设置一boolean型的变量，当条件满足时，使线程执行体快速执行完毕。如： 1234567891011121314151617181920212223242526272829303132333435 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 MyRunnable myRunnable = new MyRunnable(); 6 Thread thread = new Thread(myRunnable); 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 thread.start();12 &#125;13 if(i == 40)&#123;14 myRunnable.stopThread();15 &#125;16 &#125;17 &#125;18 &#125;19 20 class MyRunnable implements Runnable &#123;21 22 private boolean stop;23 24 @Override25 public void run() &#123;26 for (int i = 0; i &lt; 100 &amp;&amp; !stop; i++) &#123;27 System.out.println(Thread.currentThread().getName() + \" \" + i);28 &#125;29 &#125;30 31 public void stopThread() &#123;32 this.stop = true;33 &#125;34 35 &#125; Java总结篇系列：Java多线程（二） 本文承接上一篇文章《Java总结篇系列：Java多线程（一）》。 四.Java多线程的阻塞状态与线程控制 上文已经提到Java阻塞的几种具体类型。下面分别看下引起Java线程阻塞的主要方法。 1.join() join —— 让一个线程等待另一个线程完成才继续执行。如A线程线程执行体中调用B线程的join()方法，则A线程被阻塞，知道B线程执行完为止，A才能得以继续执行。 123456789101112131415161718192021222324252627282930 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 MyRunnable myRunnable = new MyRunnable(); 6 Thread thread = new Thread(myRunnable); 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 thread.start();12 try &#123;13 thread.join(); // main线程需要等待thread线程执行完后才能继续执行14 &#125; catch (InterruptedException e) &#123;15 e.printStackTrace();16 &#125;17 &#125;18 &#125;19 &#125;20 &#125;21 22 class MyRunnable implements Runnable &#123;23 24 @Override25 public void run() &#123;26 for (int i = 0; i &lt; 100; i++) &#123;27 System.out.println(Thread.currentThread().getName() + \" \" + i);28 &#125;29 &#125;30 &#125; 2.sleep() sleep —— 让当前的正在执行的线程暂停指定的时间，并进入阻塞状态。在其睡眠的时间段内，该线程由于不是处于就绪状态，因此不会得到执行的机会。即使此时系统中没有任何其他可执行的线程，出于sleep()中的线程也不会执行。因此sleep()方法常用来暂停线程执行。 前面有讲到，当调用了新建的线程的start()方法后，线程进入到就绪状态，可能会在接下来的某个时间获取CPU时间片得以执行，如果希望这个新线程必然性的立即执行，直接调用原来线程的sleep(1)即可。 123456789101112131415161718192021222324252627282930 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 5 MyRunnable myRunnable = new MyRunnable(); 6 Thread thread = new Thread(myRunnable); 7 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(Thread.currentThread().getName() + \" \" + i);10 if (i == 30) &#123;11 thread.start();12 try &#123;13 Thread.sleep(1); // 使得thread必然能够马上得以执行14 &#125; catch (InterruptedException e) &#123;15 e.printStackTrace();16 &#125;17 &#125;18 &#125;19 &#125;20 &#125;21 22 class MyRunnable implements Runnable &#123;23 24 @Override25 public void run() &#123;26 for (int i = 0; i &lt; 100; i++) &#123;27 System.out.println(Thread.currentThread().getName() + \" \" + i);28 &#125;29 &#125;30 &#125; 注：睡一个毫秒级够了，因为CPU不会空闲，会切换到新建的线程。 3.后台线程（Daemon Thread） 概念/目的：后台线程主要是为其他线程（相对可以称之为前台线程）提供服务，或“守护线程”。如JVM中的垃圾回收线程。 生命周期：后台线程的生命周期与前台线程生命周期有一定关联。主要体现在：当所有的前台线程都进入死亡状态时，后台线程会自动死亡(其实这个也很好理解，因为后台线程存在的目的在于为前台线程服务的，既然所有的前台线程都死亡了，那它自己还留着有什么用…伟大啊 ! !)。 设置后台线程：调用Thread对象的setDaemon(true)方法可以将指定的线程设置为后台线程。 1234567891011121314151617181920212223242526272829 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Thread myThread = new MyThread(); 5 for (int i = 0; i &lt; 100; i++) &#123; 6 System.out.println(\"main thread i = \" + i); 7 if (i == 20) &#123; 8 myThread.setDaemon(true); 9 myThread.start();10 &#125;11 &#125;12 &#125;13 14 &#125;15 16 class MyThread extends Thread &#123;17 18 public void run() &#123;19 for (int i = 0; i &lt; 100; i++) &#123;20 System.out.println(\"i = \" + i);21 try &#123;22 Thread.sleep(1);23 &#125; catch (InterruptedException e) &#123;24 // TODO Auto-generated catch block25 e.printStackTrace();26 &#125;27 &#125;28 &#125;29 &#125; 判断线程是否是后台线程：调用thread对象的isDeamon()方法。 注：main线程默认是前台线程，前台线程创建中创建的子线程默认是前台线程，后台线程中创建的线程默认是后台线程。调用setDeamon(true)方法将前台线程设置为后台线程时，需要在start()方法调用之前。前天线程都死亡后，JVM通知后台线程死亡，但从接收指令到作出响应，需要一定的时间。 4.改变线程的优先级/setPriority()： 每个线程在执行时都具有一定的优先级，优先级高的线程具有较多的执行机会。每个线程默认的优先级都与创建它的线程的优先级相同。main线程默认具有普通优先级。 设置线程优先级：setPriority(int priorityLevel)。参数priorityLevel范围在1-10之间，常用的有如下三个静态常量值： MAX_PRIORITY:10 MIN_PRIORITY:1 NORM_PRIORITY:5 获取线程优先级：getPriority()。 注：具有较高线程优先级的线程对象仅表示此线程具有较多的执行机会，而非优先执行。 1234567891011121314151617181920212223 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Thread myThread = new MyThread(); 5 for (int i = 0; i &lt; 100; i++) &#123; 6 System.out.println(\"main thread i = \" + i); 7 if (i == 20) &#123; 8 myThread.setPriority(Thread.MAX_PRIORITY); 9 myThread.start();10 &#125;11 &#125;12 &#125;13 14 &#125;15 16 class MyThread extends Thread &#123;17 18 public void run() &#123;19 for (int i = 0; i &lt; 100; i++) &#123;20 System.out.println(\"i = \" + i);21 &#125;22 &#125;23 &#125; 5.线程让步：yield() 上一篇博文中已经讲到了yield()的基本作用，同时，yield()方法还与线程优先级有关，当某个线程调用yiled()方法从运行状态转换到就绪状态后，CPU从就绪状态线程队列中只会选择与该线程优先级相同或优先级更高的线程去执行。 123456789101112131415161718192021222324252627282930313233343536 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Thread myThread1 = new MyThread1(); 5 Thread myThread2 = new MyThread2(); 6 myThread1.setPriority(Thread.MAX_PRIORITY); 7 myThread2.setPriority(Thread.MIN_PRIORITY); 8 for (int i = 0; i &lt; 100; i++) &#123; 9 System.out.println(\"main thread i = \" + i);10 if (i == 20) &#123;11 myThread1.start();12 myThread2.start();13 Thread.yield();14 &#125;15 &#125;16 &#125;17 18 &#125;19 20 class MyThread1 extends Thread &#123;21 22 public void run() &#123;23 for (int i = 0; i &lt; 100; i++) &#123;24 System.out.println(\"myThread 1 -- i = \" + i);25 &#125;26 &#125;27 &#125;28 29 class MyThread2 extends Thread &#123;30 31 public void run() &#123;32 for (int i = 0; i &lt; 100; i++) &#123;33 System.out.println(\"myThread 2 -- i = \" + i);34 &#125;35 &#125;36 &#125; Java总结篇系列：Java多线程（三） 本文主要接着前面多线程的两篇文章总结Java多线程中的线程安全问题。 一.一个典型的Java线程安全例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465 1 public class ThreadTest &#123; 2 3 public static void main(String[] args) &#123; 4 Account account = new Account(\"123456\", 1000); 5 DrawMoneyRunnable drawMoneyRunnable = new DrawMoneyRunnable(account, 700); 6 Thread myThread1 = new Thread(drawMoneyRunnable); 7 Thread myThread2 = new Thread(drawMoneyRunnable); 8 myThread1.start(); 9 myThread2.start();10 &#125;11 12 &#125;13 14 class DrawMoneyRunnable implements Runnable &#123;15 16 private Account account;17 private double drawAmount;18 19 public DrawMoneyRunnable(Account account, double drawAmount) &#123;20 super();21 this.account = account;22 this.drawAmount = drawAmount;23 &#125;24 25 public void run() &#123;26 if (account.getBalance() &gt;= drawAmount) &#123; //127 System.out.println(\"取钱成功， 取出钱数为：\" + drawAmount);28 double balance = account.getBalance() - drawAmount;29 account.setBalance(balance);30 System.out.println(\"余额为：\" + balance);31 &#125;32 &#125;33 &#125;34 35 class Account &#123;36 37 private String accountNo;38 private double balance;39 40 public Account() &#123;41 42 &#125;43 44 public Account(String accountNo, double balance) &#123;45 this.accountNo = accountNo;46 this.balance = balance;47 &#125;48 49 public String getAccountNo() &#123;50 return accountNo;51 &#125;52 53 public void setAccountNo(String accountNo) &#123;54 this.accountNo = accountNo;55 &#125;56 57 public double getBalance() &#123;58 return balance;59 &#125;60 61 public void setBalance(double balance) &#123;62 this.balance = balance;63 &#125;64 65 &#125; 上面例子很容易理解，有一张银行卡，里面有1000的余额，程序模拟你和你老婆同时在取款机进行取钱操作的场景。多次运行此程序，可能具有多个不同组合的输出结果。其中一种可能的输出为： 1 取钱成功， 取出钱数为：700.0 2 余额为：300.0 3 取钱成功， 取出钱数为：700.0 4 余额为：-400.0 也就是说，对于一张只有1000余额的银行卡，你们一共可以取出1400，这显然是有问题的。 经过分析，问题在于Java多线程环境下的执行的不确定性。CPU可能随机的在多个处于就绪状态中的线程中进行切换，因此，很有可能出现如下情况：当thread1执行到//1处代码时，判断条件为true，此时CPU切换到thread2，执行//1处代码，发现依然为真，然后执行完thread2，接着切换到thread1，接着执行完毕。此时，就会出现上述结果。 因此，讲到线程安全问题，其实是指多线程环境下对共享资源的访问可能会引起此共享资源的不一致性。因此，为避免线程安全问题，应该避免多线程环境下对此共享资源的并发访问。 二.同步方法 对共享资源进行访问的方法定义中加上synchronized关键字修饰，使得此方法称为同步方法。可以简单理解成对此方法进行了加锁，其锁对象为当前方法所在的对象自身。多线程环境下，当执行此方法时，首先都要获得此同步锁（且同时最多只有一个线程能够获得），只有当线程执行完此同步方法后，才会释放锁对象，其他的线程才有可能获取此同步锁，以此类推… 在上例中，共享资源为account对象，当使用同步方法时，可以解决线程安全问题。只需在run()方法前加上synshronized关键字即可。 123451 public synchronized void run() &#123;2 3 // ....4 5 &#125; 三.同步代码块 正如上面所分析的那样，解决线程安全问题其实只需限制对共享资源访问的不确定性即可。使用同步方法时，使得整个方法体都成为了同步执行状态，会使得可能出现同步范围过大的情况，于是，针对需要同步的代码可以直接另一种同步方式——同步代码块来解决。 同步代码块的格式为： 123451 synchronized (obj) &#123;2 3 //...4 5 &#125; 其中，obj为锁对象，因此，选择哪一个对象作为锁是至关重要的。一般情况下，都是选择此共享资源对象作为锁对象。 如上例中，最好选用account对象作为锁对象。（当然，选用this也是可以的，那是因为创建线程使用了runnable方式，如果是直接继承Thread方式创建的线程，使用this对象作为同步锁会其实没有起到任何作用，因为是不同的对象了。因此，选择同步锁时需要格外小心…） 四.Lock对象同步锁 上面我们可以看出，正因为对同步锁对象的选择需要如此小心，有没有什么简单点的解决方案呢？以方便同步锁对象与共享资源解耦，同时又能很好的解决线程安全问题。 使用Lock对象同步锁可以方便的解决此问题，唯一需要注意的一点是Lock对象需要与资源对象同样具有一对一的关系。Lock对象同步锁一般格式为： 12345678910111213141516 1 class X &#123; 2 3 // 显示定义Lock同步锁对象，此对象与共享资源具有一对一关系 4 private final Lock lock = new ReentrantLock(); 5 6 public void m()&#123; 7 // 加锁 8 lock.lock(); 9 10 //... 需要进行线程安全同步的代码11 12 // 释放Lock锁13 lock.unlock();14 &#125;15 16 &#125; 五.wait()/notify()/notifyAll()线程通信 在博文《Java总结篇系列：java.lang.Object》中有提及到这三个方法，虽然这三个方法主要都是用于多线程中，但实际上都是Object类中的本地方法。因此，理论上，任何Object对象都可以作为这三个方法的主调，在实际的多线程编程中，只有同步锁对象调这三个方法，才能完成对多线程间的线程通信。 wait()：导致当前线程等待并使其进入到等待阻塞状态。直到其他线程调用该同步锁对象的notify()或notifyAll()方法来唤醒此线程。 notify()：唤醒在此同步锁对象上等待的单个线程，如果有多个线程都在此同步锁对象上等待，则会任意选择其中某个线程进行唤醒操作，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。 notifyAll()：唤醒在此同步锁对象上等待的所有线程，只有当前线程放弃对同步锁对象的锁定，才可能执行被唤醒的线程。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150 1 package com.qqyumidi; 2 3 public class ThreadTest &#123; 4 5 public static void main(String[] args) &#123; 6 Account account = new Account(\"123456\", 0); 7 8 Thread drawMoneyThread = new DrawMoneyThread(\"取钱线程\", account, 700); 9 Thread depositeMoneyThread = new DepositeMoneyThread(\"存钱线程\", account, 700); 10 11 drawMoneyThread.start(); 12 depositeMoneyThread.start(); 13 &#125; 14 15 &#125; 16 17 class DrawMoneyThread extends Thread &#123; 18 19 private Account account; 20 private double amount; 21 22 public DrawMoneyThread(String threadName, Account account, double amount) &#123; 23 super(threadName); 24 this.account = account; 25 this.amount = amount; 26 &#125; 27 28 public void run() &#123; 29 for (int i = 0; i &lt; 100; i++) &#123; 30 account.draw(amount, i); 31 &#125; 32 &#125; 33 &#125; 34 35 class DepositeMoneyThread extends Thread &#123; 36 37 private Account account; 38 private double amount; 39 40 public DepositeMoneyThread(String threadName, Account account, double amount) &#123; 41 super(threadName); 42 this.account = account; 43 this.amount = amount; 44 &#125; 45 46 public void run() &#123; 47 for (int i = 0; i &lt; 100; i++) &#123; 48 account.deposite(amount, i); 49 &#125; 50 &#125; 51 &#125; 52 53 class Account &#123; 54 55 private String accountNo; 56 private double balance; 57 // 标识账户中是否已有存款 58 private boolean flag = false; 59 60 public Account() &#123; 61 62 &#125; 63 64 public Account(String accountNo, double balance) &#123; 65 this.accountNo = accountNo; 66 this.balance = balance; 67 &#125; 68 69 public String getAccountNo() &#123; 70 return accountNo; 71 &#125; 72 73 public void setAccountNo(String accountNo) &#123; 74 this.accountNo = accountNo; 75 &#125; 76 77 public double getBalance() &#123; 78 return balance; 79 &#125; 80 81 public void setBalance(double balance) &#123; 82 this.balance = balance; 83 &#125; 84 85 /** 86 * 存钱 87 * 88 * @param depositeAmount 89 */ 90 public synchronized void deposite(double depositeAmount, int i) &#123; 91 92 if (flag) &#123; 93 // 账户中已有人存钱进去，此时当前线程需要等待阻塞 94 try &#123; 95 System.out.println(Thread.currentThread().getName() + \" 开始要执行wait操作\" + \" -- i=\" + i); 96 wait(); 97 // 1 98 System.out.println(Thread.currentThread().getName() + \" 执行了wait操作\" + \" -- i=\" + i); 99 &#125; catch (InterruptedException e) &#123;100 e.printStackTrace();101 &#125;102 &#125; else &#123;103 // 开始存钱104 System.out.println(Thread.currentThread().getName() + \" 存款:\" + depositeAmount + \" -- i=\" + i);105 setBalance(balance + depositeAmount);106 flag = true;107 108 // 唤醒其他线程109 notifyAll();110 111 // 2112 try &#123;113 Thread.sleep(3000);114 &#125; catch (InterruptedException e) &#123;115 e.printStackTrace();116 &#125;117 System.out.println(Thread.currentThread().getName() + \"-- 存钱 -- 执行完毕\" + \" -- i=\" + i);118 &#125;119 &#125;120 121 /**122 * 取钱123 * 124 * @param drawAmount125 */126 public synchronized void draw(double drawAmount, int i) &#123;127 if (!flag) &#123;128 // 账户中还没人存钱进去，此时当前线程需要等待阻塞129 try &#123;130 System.out.println(Thread.currentThread().getName() + \" 开始要执行wait操作\" + \" 执行了wait操作\" + \" -- i=\" + i);131 wait();132 System.out.println(Thread.currentThread().getName() + \" 执行了wait操作\" + \" 执行了wait操作\" + \" -- i=\" + i);133 &#125; catch (InterruptedException e) &#123;134 e.printStackTrace();135 &#125;136 &#125; else &#123;137 // 开始取钱138 System.out.println(Thread.currentThread().getName() + \" 取钱：\" + drawAmount + \" -- i=\" + i);139 setBalance(getBalance() - drawAmount);140 141 flag = false;142 143 // 唤醒其他线程144 notifyAll();145 146 System.out.println(Thread.currentThread().getName() + \"-- 取钱 -- 执行完毕\" + \" -- i=\" + i); // 3147 &#125;148 &#125;149 150 &#125; 上面的例子演示了wait()/notify()/notifyAll()的用法。部分输出结果为： 1234567891011121314151617181920212223242526272829303132 1 取钱线程 开始要执行wait操作 执行了wait操作 -- i=0 2 存钱线程 存款:700.0 -- i=0 3 存钱线程-- 存钱 -- 执行完毕 -- i=0 4 存钱线程 开始要执行wait操作 -- i=1 5 取钱线程 执行了wait操作 执行了wait操作 -- i=0 6 取钱线程 取钱：700.0 -- i=1 7 取钱线程-- 取钱 -- 执行完毕 -- i=1 8 取钱线程 开始要执行wait操作 执行了wait操作 -- i=2 9 存钱线程 执行了wait操作 -- i=110 存钱线程 存款:700.0 -- i=211 存钱线程-- 存钱 -- 执行完毕 -- i=212 取钱线程 执行了wait操作 执行了wait操作 -- i=213 取钱线程 取钱：700.0 -- i=314 取钱线程-- 取钱 -- 执行完毕 -- i=315 取钱线程 开始要执行wait操作 执行了wait操作 -- i=416 存钱线程 存款:700.0 -- i=317 存钱线程-- 存钱 -- 执行完毕 -- i=318 存钱线程 开始要执行wait操作 -- i=419 取钱线程 执行了wait操作 执行了wait操作 -- i=420 取钱线程 取钱：700.0 -- i=521 取钱线程-- 取钱 -- 执行完毕 -- i=522 取钱线程 开始要执行wait操作 执行了wait操作 -- i=623 存钱线程 执行了wait操作 -- i=424 存钱线程 存款:700.0 -- i=525 存钱线程-- 存钱 -- 执行完毕 -- i=526 存钱线程 开始要执行wait操作 -- i=627 取钱线程 执行了wait操作 执行了wait操作 -- i=628 取钱线程 取钱：700.0 -- i=729 取钱线程-- 取钱 -- 执行完毕 -- i=730 取钱线程 开始要执行wait操作 执行了wait操作 -- i=831 存钱线程 执行了wait操作 -- i=632 存钱线程 存款:700.0 -- i=7 由此，我们需要注意如下几点： 1.wait()方法执行后，当前线程立即进入到等待阻塞状态，其后面的代码不会执行； 2.notify()/notifyAll()方法执行后，将唤醒此同步锁对象上的（任意一个-notify()/所有-notifyAll()）线程对象，但是，此时还并没有释放同步锁对象，也就是说，如果notify()/notifyAll()后面还有代码，还会继续进行，知道当前线程执行完毕才会释放同步锁对象； 3.notify()/notifyAll()执行后，如果右面有sleep()方法，则会使当前线程进入到阻塞状态，但是同步对象锁没有释放，依然自己保留，那么一定时候后还是会继续执行此线程，接下来同2； 4.wait()/notify()/nitifyAll()完成线程间的通信或协作都是基于不同对象锁的，因此，如果是不同的同步对象锁将失去意义，同时，同步对象锁最好是与共享资源对象保持一一对应关系； 5.当wait线程唤醒后并执行时，是接着上次执行到的wait()方法代码后面继续往下执行的。 当然，上面的例子相对来说比较简单，只是为了简单示例wait()/notify()/noitifyAll()方法的用法，但其本质上说，已经是一个简单的生产者-消费者模式了。","categories":[{"name":"多线程","slug":"多线程","permalink":"https://conanisbest.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"Java高级特性——反射","slug":"first","date":"2020-07-02T06:34:39.000Z","updated":"2020-07-13T09:05:04.671Z","comments":true,"path":"2020/07/02/first/","link":"","permalink":"https://conanisbest.github.io/2020/07/02/first/","excerpt":"","text":"Java高级特性——反射 peter_RD_nj 概述 定义 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 用途 在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。 反射机制的相关类 与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 Class类 Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。 获得类相关的方法 方法 用途 asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或是接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…&lt;?&gt; parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…&lt;?&gt; parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 类中其他重要的方法 方法 用途 isAnnotation() 如果是注解类型则返回true isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 如果是指定类型注解类型则返回true isAnonymousClass() 如果是匿名类则返回true isArray() 如果是一个数组类则返回true isEnum() 如果是枚举类则返回true isInstance(Object obj) 如果obj是该类的实例则返回true isInterface() 如果是接口类则返回true isLocalClass() 如果是局部类则返回true isMemberClass() 如果是内部类则返回true Field类 Field代表类的成员变量（成员变量也称为类的属性）。 方法 用途 equals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 Method类 Method代表类的方法。 方法 用途 invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类 Constructor代表类的构造方法。 方法 用途 newInstance(Object… initargs) 根据传递的参数创建类的对象 示例 为了演示反射的使用，首先构造一个与书籍相关的model——Book.java，然后通过反射方法示例创建对象、反射私有构造方法、反射私有属性、反射私有方法，最后给出两个比较复杂的反射示例——获得当前ZenMode和关机Shutdown。 被反射类Book.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Book&#123; private final static String TAG = \"BookTag\"; private String name; private String author; @Override public String toString() &#123; return \"Book&#123;\" + \"name='\" + name + '\\'' + \", author='\" + author + '\\'' + '&#125;'; &#125; public Book() &#123; &#125; private Book(String name, String author) &#123; this.name = name; this.author = author; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAuthor() &#123; return author; &#125; public void setAuthor(String author) &#123; this.author = author; &#125; private String declaredMethod(int index) &#123; String string = null; switch (index) &#123; case 0: string = \"I am declaredMethod 1 !\"; break; case 1: string = \"I am declaredMethod 2 !\"; break; default: string = \"I am declaredMethod 1 !\"; &#125; return string; &#125;&#125; 反射逻辑封装在ReflectClass.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127public class ReflectClass &#123; private final static String TAG = \"peter.log.ReflectClass\"; // 创建对象 public static void reflectNewInstance() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Object objectBook = classBook.newInstance(); Book book = (Book) objectBook; book.setName(\"Android进阶之光\"); book.setAuthor(\"刘望舒\"); Log.d(TAG,\"reflectNewInstance book = \" + book.toString()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有的构造方法 public static void reflectPrivateConstructor() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Constructor&lt;?&gt; declaredConstructorBook = classBook.getDeclaredConstructor(String.class,String.class); declaredConstructorBook.setAccessible(true); Object objectBook = declaredConstructorBook.newInstance(\"Android开发艺术探索\",\"任玉刚\"); Book book = (Book) objectBook; Log.d(TAG,\"reflectPrivateConstructor book = \" + book.toString()); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有属性 public static void reflectPrivateField() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Object objectBook = classBook.newInstance(); Field fieldTag = classBook.getDeclaredField(\"TAG\"); fieldTag.setAccessible(true); String tag = (String) fieldTag.get(objectBook); Log.d(TAG,\"reflectPrivateField tag = \" + tag); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 反射私有方法 public static void reflectPrivateMethod() &#123; try &#123; Class&lt;?&gt; classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Method methodBook = classBook.getDeclaredMethod(\"declaredMethod\",int.class); methodBook.setAccessible(true); Object objectBook = classBook.newInstance(); String string = (String) methodBook.invoke(objectBook,0); Log.d(TAG,\"reflectPrivateMethod string = \" + string); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; // 获得系统Zenmode值 public static int getZenMode() &#123; int zenMode = -1; try &#123; Class&lt;?&gt; cServiceManager = Class.forName(\"android.os.ServiceManager\"); Method mGetService = cServiceManager.getMethod(\"getService\", String.class); Object oNotificationManagerService = mGetService.invoke(null, Context.NOTIFICATION_SERVICE); Class&lt;?&gt; cINotificationManagerStub = Class.forName(\"android.app.INotificationManager$Stub\"); Method mAsInterface = cINotificationManagerStub.getMethod(\"asInterface\",IBinder.class); Object oINotificationManager = mAsInterface.invoke(null,oNotificationManagerService); Method mGetZenMode = cINotificationManagerStub.getMethod(\"getZenMode\"); zenMode = (int) mGetZenMode.invoke(oINotificationManager); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; return zenMode; &#125; // 关闭手机 public static void shutDown() &#123; try &#123; Class&lt;?&gt; cServiceManager = Class.forName(\"android.os.ServiceManager\"); Method mGetService = cServiceManager.getMethod(\"getService\",String.class); Object oPowerManagerService = mGetService.invoke(null,Context.POWER_SERVICE); Class&lt;?&gt; cIPowerManagerStub = Class.forName(\"android.os.IPowerManager$Stub\"); Method mShutdown = cIPowerManagerStub.getMethod(\"shutdown\",boolean.class,String.class,boolean.class); Method mAsInterface = cIPowerManagerStub.getMethod(\"asInterface\",IBinder.class); Object oIPowerManager = mAsInterface.invoke(null,oPowerManagerService); mShutdown.invoke(oIPowerManager,true,null,true); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; &#125; public static void shutdownOrReboot(final boolean shutdown, final boolean confirm) &#123; try &#123; Class&lt;?&gt; ServiceManager = Class.forName(\"android.os.ServiceManager\"); // 获得ServiceManager的getService方法 Method getService = ServiceManager.getMethod(\"getService\", java.lang.String.class); // 调用getService获取RemoteService Object oRemoteService = getService.invoke(null, Context.POWER_SERVICE); // 获得IPowerManager.Stub类 Class&lt;?&gt; cStub = Class.forName(\"android.os.IPowerManager$Stub\"); // 获得asInterface方法 Method asInterface = cStub.getMethod(\"asInterface\", android.os.IBinder.class); // 调用asInterface方法获取IPowerManager对象 Object oIPowerManager = asInterface.invoke(null, oRemoteService); if (shutdown) &#123; // 获得shutdown()方法 Method shutdownMethod = oIPowerManager.getClass().getMethod( \"shutdown\", boolean.class, String.class, boolean.class); // 调用shutdown()方法 shutdownMethod.invoke(oIPowerManager, confirm, null, false); &#125; else &#123; // 获得reboot()方法 Method rebootMethod = oIPowerManager.getClass().getMethod(\"reboot\", boolean.class, String.class, boolean.class); // 调用reboot()方法 rebootMethod.invoke(oIPowerManager, confirm, null, false); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 调用相应反射逻辑方法 1234567891011121314151617try &#123; // 创建对象 ReflectClass.reflectNewInstance(); // 反射私有的构造方法 ReflectClass.reflectPrivateConstructor(); // 反射私有属性 ReflectClass.reflectPrivateField(); // 反射私有方法 ReflectClass.reflectPrivateMethod(); &#125; catch (Exception ex) &#123; ex.printStackTrace(); &#125; Log.d(TAG,\" zenmode = \" + ReflectClass.getZenMode()); Log输出结果如下： 1234508-27 15:11:37.999 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectNewInstance book = Book&#123;name='Android进阶之光', author='刘望舒'&#125;08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateConstructor book = Book&#123;name='Android开发艺术探索', author='任玉刚'&#125;08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateField tag = BookTag08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateMethod string = I am declaredMethod 1 !08-27 15:11:38.004 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectDemo: zenmode = 0 总结 本文列举了反射机制使用过程中常用的、重要的一些类及其方法，更多信息和用法需要近一步的阅读Google提供的相关文档和示例。 在阅读Class类文档时发现一个特点，以通过反射获得Method对象为例，一般会提供四种方法，getMethod(parameterTypes)、getMethods()、getDeclaredMethod(parameterTypes)和getDeclaredMethods()。getMethod(parameterTypes)用来获取某个公有的方法的对象，getMethods()获得该类所有公有的方法，getDeclaredMethod(parameterTypes)获得该类某个方法，getDeclaredMethods()获得该类所有方法。带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法。其他的Annotation、Field、Constructor也是如此。 在ReflectClass类中还提供了两种反射PowerManager.shutdown()的方法，在调用的时候会输出如下log，提示没有相关权限。之前在项目中尝试反射其他方法的时候还遇到过有权限和没权限返回的值不一样的情况。如果源码中明确进行了权限验证，而你的应用又无法获得这个权限的话，建议就不要浪费时间反射了。 1234567891011121314151617W&#x2F;System.err: java.lang.reflect.InvocationTargetExceptionW&#x2F;System.err: at java.lang.reflect.Method.invoke(Native Method)W&#x2F;System.err: at .ReflectClass.shutDown(ReflectClass.java:104)W&#x2F;System.err: at .MainActivity$1.onClick(MainActivity.java:25)W&#x2F;System.err: at android.view.View.performClick(View.java:6259)W&#x2F;System.err: at android.view.View$PerformClick.run(View.java:24732)W&#x2F;System.err: at android.os.Handler.handleCallback(Handler.java:789)W&#x2F;System.err: at android.os.Handler.dispatchMessage(Handler.java:98)W&#x2F;System.err: at android.os.Looper.loop(Looper.java:164)W&#x2F;System.err: at android.app.ActivityThread.main(ActivityThread.java:6592)W&#x2F;System.err: at java.lang.reflect.Method.invoke(Native Method)W&#x2F;System.err: at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)W&#x2F;System.err: at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:769)W&#x2F;System.err: Caused by: java.lang.SecurityException: Neither user 10224 nor current process has android.permission.REBOOT.W&#x2F;System.err: at android.os.Parcel.readException(Parcel.java:1942)W&#x2F;System.err: at android.os.Parcel.readException(Parcel.java:1888)W&#x2F;System.err: at android.os.IPowerManager$Stub$Proxy.shutdown(IPowerManager.java:787) ReflectDemo 参考文献 认识反射机制（Reflection） Java 反射机制 一个例子让你了解Java反射机制 Java反射机制的原理及在Android下的简单应用 java中的反射机制 Android注解与反射机制 java.lang.reflect.Method","categories":[{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"}],"tags":[{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"}]},{"title":"辨析 Sass 中的 Map 和 List","slug":"demo","date":"2019-10-21T02:34:12.000Z","updated":"2020-07-03T08:41:53.354Z","comments":true,"path":"2019/10/21/demo/","link":"","permalink":"https://conanisbest.github.io/2019/10/21/demo/","excerpt":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。","text":"如果你使用过 Sass 3.3 之前的版本，那么你一定对那段时光颇有感触，那时候没有现如今这么好的条件，那时候的 Map 还只能用多重列表（lists of list）来模拟。多重列表可以实现复杂数据的嵌套定义，但却不是以键值对的形式实现的，所有当我们需要获取其中特定的某一项时就会比较麻烦。Map 这种数据类型天生就是基于键值对的形式，非常便于组织数据。 自从可以使用 Map 之后，开发者们开始毫无顾忌地定义 Map 存储数据，比如断点宽度、颜色值、栅格布局等等响应式排版的细节，都被一股脑的塞进了 Map 中。 那么，有了 Map 之后，我们还有必要使用 List 吗？可能某些人会觉得为了保持向后兼容应该继续使用多重列表模拟 Map，因为可能有些开发者仍然在使用老版本的 Sass 编译器，但实际上，这是多此一举了，Sass 的版本通常由 package.json 或者其他同类型的项目配置文件所控制，往往只需一条命令（gem update sass）即可更新 Sass 的版本，因此基本上无需考虑对老版本的兼容问题。 使用多重列表替代 Map 的优势之一就是减少代码量。下面让我们来比较一下多种列表和 Map 的语法结构以及遍历方式。 测试表格 Variable Description site Sitewide information. page Page specific information and custom variables set in front-matter. config Site configuration theme Theme configuration. Inherits from site configuration. _ (single underscore) Lodash library path Path of current page url Full URL of current page env Environment variables 语法比较 测试标题 在下面的示例中，我创建了一个用于控制响应式布局的数据，该数据一共有四个断点，每一个断点都包含了 `min-width`、`max-width`、`font-size` 和 `line-height` 四个样式。 Map 语法下面就是使用 Map 存储的数据，具体来说，该 Map 中首先存储了四个用于标识断点的 Key，相对应的是保存具体属性值得 Value。虽然这种形式可读性更高，但是总体代码量却高达 26 行 450 个字符。 1234567891011121314151617181920212223242526$breakpoint-map: ( small: ( min-width: null, max-width: 479px, base-font: 16px, vertical-rhythm: 1.3 ), medium: ( min-width: 480px, max-width: 959px, base-font: 18px, vertical-rhythm: 1.414 ), large: ( min-width: 960px, max-width: 1099px, base-font: 18px, vertical-rhythm: 1.5 ), xlarge: ( min-width: 1100px, max-width: null, base-font: 21px, vertical-rhythm: 1.618 )); 多重列表语法下面的多重列表存储了和上面 Map 同样的数据，在多重列表中没有 Key-Value 的对应关系，这意味着要想找到特定的值，必须使用遍历或 nth() 的方式来实现了。从另一个角度来看，多种列表又比 Map 的代码量小得多，总共只有六行 180 个字符。 123456$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, null, 21px, 1.618)); 遍历比较 测试标题 从上面简单地比较中可以粗略的看出，多种列表的代码量明显少于 Map。但是，如果我们需要遍历这些值得话，复杂度又是怎样的呢？ 遍历 Map我们可以使用如下的代码遍历 Map： 1@each $label, $map in $breakpoint-map &#123;&#125; 这里的变量 $label 和 $map 会随着对 $breakpoint-map 的遍历被动态地赋值，$label 将会被赋值为 $breakpoint-map 的 Key，而 $map 会被赋值为 $breakpoint-map 的 Value。为了在遍历过程中获取特定值，我们就需要使用 Sass 原生的 map-get() 函数，使用该函数需要传入两个参数：Map 的名字和求取的 Key，最后返回该 Map 中匹配该 Key 的 Value。 具体的做法就是使用 @each 遍历 Map，然后使用 map-get() 获取特定值，最终只需要六行代码 220 个字符即可完成整个遍历： 123456@each $label, $map in $breakpoint-map &#123; $min-width: map-get($map, min-width); $max-width: map-get($map, max-width); $base-font: map-get($map, base-font); $vertical-rhythm: map-get($map, vertical-rhythm);&#125; 遍历多重列表遍历多重列表不必像遍历 Map 一样动态获取到 Map 后再使用 map-get() 函数取特定值，直接遍历一遍即可获得特定值。 因为多种列表内层的每一个列表结构相同，都有按照相同顺序排列的五个值，所以我们可以持续遍历每个值并赋值给特定的变量。无需调用 map-get()，直接引用这些变量即可进行赋值等裸机操作。最终遍历多重列表只使用了两行代码 100 个字符： 12@each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123;&#125; 慎用多重列表 测试标题 经过上述的比对，看起来多重列表各方面都在碾压 Map，实则不然，Sass 中添加 Map 有一条非常重要的原因就是：Key-Value 的映射关系。 遗漏键值如果要使用多重列表，那么就必须保证自己非常熟悉多重列表内部的每一项所代表的意义。下面我们举个例子，来看看遗漏了某些值的情况： 1234567891011121314151617181920$breakpoint-list: ( (small, null, 479px, 16px, 1.3), (medium, 480px, 959px, 18px, 1.414), (large, 960px, 1099px, 18px, 1.5), (xlarge, 1100px, 21px, 1.618));p &#123; @each $label, $min-width, $max-width, $base-font, $vertical-rhythm in $breakpoint-list &#123; @if $min-width &#123; @include breakpoint( $min-width ) &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125; @else &#123; font-size: $base-font; line-height: $vertical-rhythm; &#125; &#125;&#125; 当我们尝试运行这段代码时，结果肯定是错误地，因为在 $breakpoint-list 的最后一行，xlarge 被赋值给了 $label，1100px 被赋值给了 $min-width，21px 被赋值给了 $max-width, 1.618 被赋值给了 $base-font，最终导致 $vertical-rhythm 没有被赋值，结果就是 font-size 的属性值是错的，line-height 的属性值是空的。此外，Sass 还不会对此抛出错误，导致我们无从知晓错误所在。 如果我们使用 Map 来代替这里的多重列表，那么使用 map-get() 函数即使遇见空值也能正确获得想要的结果。这就是值得我们慎重思考的地方：多种列表虽然简单快速，但是丧失了 Map 中的容错能力和快速取值能力。 查找特定列表在多重列表中查找特定列表简直就是一种折磨。如果使用 Map，那么配合 map-get() 函数可以快速定位到特定子 Map： 1$medium-map: map-get($maps, medium); 但如果要获取多种列表 medium 列表，麻烦可就大了： 123456789@function get-list($label) &#123; @each $list in $breakpoint-list &#123; @if nth($list, 1) &#x3D;&#x3D; $label &#123; @return $list; &#125; &#125; @return null;&#125;$medium-list: get-list(medium); 这段代码的逻辑就是遍历整个多重列表，知道找到第一个匹配项，然后返回，如果一直没有找到匹配项，就一直遍历到末尾，然后返回 null。这实际上就是手工实现了 map-get() 的逻辑。 缺少原生的 Map 函数Sass 提供了诸多的原生函数用于处理 Map 数据类型，但是多重列表是没法调用这些函数的，比如，使用 map-merge() 可以合并两个 Map，如果两个 Map 有相同的值，则取第二个 Map 的值为最终值。当然你也可以在多重列表中使用 join() 或 append() 来增加新列表，从而模拟出 map-merge() 的效果。 另一个实用的 Map 函数就是 map-has-key()，对于依赖 map-get() 的自定义函数来说，map-has-key() 可以用来验证特定的 Key 是否存在。但在列表中是完全没有相似的方法。 总结 Test Title 相比起列表来说，Key-Value 模型的 Map 显然更有力量，原生的 Sass Map 函数更是提供了强力的数据查找和验证工具。 虽然多重列表代码量少，但并不能像 Map 一样进行错误检查或验证参数。在大多数时候，相比较多重列表而言，我相信 Map 是更好的选择。如果是为了更少的代码量和其他简单地调用，那么我偶尔会用用多重列表，但是从项目的宏观控制和数据存储方面显然更优秀。","categories":[],"tags":[{"name":"css","slug":"css","permalink":"https://conanisbest.github.io/tags/css/"}]}],"categories":[{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/categories/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"redis","slug":"redis","permalink":"https://conanisbest.github.io/categories/redis/"},{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/categories/java/"},{"name":"数据库相关","slug":"数据库相关","permalink":"https://conanisbest.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"},{"name":"多线程","slug":"多线程","permalink":"https://conanisbest.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"study","slug":"study","permalink":"https://conanisbest.github.io/categories/study/"}],"tags":[{"name":"Windows","slug":"Windows","permalink":"https://conanisbest.github.io/tags/Windows/"},{"name":"redis","slug":"redis","permalink":"https://conanisbest.github.io/tags/redis/"},{"name":"jvm","slug":"jvm","permalink":"https://conanisbest.github.io/tags/jvm/"},{"name":"java","slug":"java","permalink":"https://conanisbest.github.io/tags/java/"},{"name":"问题解决","slug":"问题解决","permalink":"https://conanisbest.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"},{"name":"hibernate","slug":"hibernate","permalink":"https://conanisbest.github.io/tags/hibernate/"},{"name":"JVM","slug":"JVM","permalink":"https://conanisbest.github.io/tags/JVM/"},{"name":"css","slug":"css","permalink":"https://conanisbest.github.io/tags/css/"}]}